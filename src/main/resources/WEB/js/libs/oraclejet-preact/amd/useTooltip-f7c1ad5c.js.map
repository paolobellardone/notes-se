{"version":3,"file":"useTooltip-f7c1ad5c.js","sources":["../../src/hooks/UNSAFE_useTooltip/TooltipContent.tsx","../../src/hooks/UNSAFE_useTooltip/useTooltipControlled.tsx","../../src/hooks/UNSAFE_useTooltip/useTooltip.tsx"],"sourcesContent":["import { useAnimation } from '../UNSAFE_useAnimation';\nimport { useComponentTheme } from '../UNSAFE_useComponentTheme';\nimport { useEffect, useRef } from 'preact/hooks';\nimport { HTMLAttributesSignalExcluded } from '../../utils/UNSAFE_attributeUtils';\nimport {\n  TooltipContentVariantOptions,\n  TooltipContentStyles\n} from './themes/TooltipContentStyles.css';\n\nimport { useTestId, TestIdProps } from '../UNSAFE_useTestId';\nimport { useThemeInterpolations } from '../UNSAFE_useThemeInterpolations';\nimport { classNames } from '../../utils/UNSAFE_classNames';\nimport { TooltipContentRedwoodTheme } from './themes/redwood/TooltipContentTheme';\n\ntype IntrinsicProps = Pick<HTMLAttributesSignalExcluded<HTMLDivElement>, 'children'>;\n\ntype Status = 'mounted' | 'unmounted';\n\ntype ContentProps = IntrinsicProps & {\n  id: string;\n  isOpen: boolean;\n  isDatatip: boolean;\n  onTransitionEnd?: () => void;\n} & TestIdProps;\n\nexport const TooltipContent = ({\n  children,\n  id,\n  isOpen,\n  isDatatip,\n  onTransitionEnd,\n  testId,\n  ...props\n}: ContentProps) => {\n  const wrapperRef = useRef<HTMLDivElement>(null);\n  const popoverRef = useRef<HTMLDivElement>(null);\n\n  const testIdProps = useTestId(testId);\n\n  const { baseTheme, variantClasses, styles } = useComponentTheme<\n    TooltipContentVariantOptions,\n    TooltipContentStyles\n  >(TooltipContentRedwoodTheme, {\n    variant: isDatatip ? 'datatip' : 'tooltip'\n  });\n\n  const schemeClass = useThemeInterpolations();\n\n  const { nodeRef } = useAnimation<Status, HTMLDivElement>(isOpen ? 'mounted' : 'unmounted', {\n    animationStates: {\n      mounted: (_node) => {\n        const childNode = _node.firstChild as HTMLDivElement;\n        return {\n          from: {\n            maxHeight: '0',\n            opacity: '0%'\n          },\n          to: {\n            maxHeight: `${childNode?.offsetHeight}px`,\n            opacity: isDatatip ? '100%' : '95%'\n          },\n          options: {\n            duration: isDatatip ? 1 : 150,\n            easing: [0.0, 0.0, 0.2, 1]\n          }\n        };\n      },\n      unmounted: (_node) => {\n        return {\n          from: {\n            opacity: isDatatip ? '100%' : '95%'\n          },\n          to: {\n            maxHeight: '0',\n            opacity: '0%'\n          },\n          options: {\n            duration: isDatatip ? 1 : 150,\n            easing: [0.0, 0.0, 0.2, 1]\n          }\n        };\n      }\n    },\n    isAnimatedOnMount: true,\n    onAnimationEnd: () => onTransitionEnd?.()\n  });\n\n  // Set up initial wrapper height so Tooltip can animate from the bottom to the top\n  useEffect(() => {\n    if (wrapperRef.current && popoverRef.current?.offsetHeight) {\n      wrapperRef.current.style.height = `${popoverRef.current?.offsetHeight}px`;\n    }\n  }, []);\n\n  return (\n    <div\n      ref={wrapperRef}\n      id={id}\n      role=\"tooltip\"\n      class={classNames([styles.wrapper, schemeClass, baseTheme])}\n      {...testIdProps}>\n      <div ref={nodeRef} class={styles.inner} {...props}>\n        <div ref={popoverRef} class={classNames([variantClasses, styles.content])}>\n          {children}\n        </div>\n      </div>\n    </div>\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ComponentChild } from 'preact';\nimport { useState, useRef, useEffect, useCallback } from 'preact/hooks';\nimport { useId } from '../UNSAFE_useId';\nimport { Placement, Coords } from '../../UNSAFE_Floating';\nimport { useHover } from '../UNSAFE_useHover';\nimport { useFocus } from '../UNSAFE_useFocus';\nimport { useTouch } from '../UNSAFE_useTouch';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\nimport { TooltipContent } from './TooltipContent';\nimport { useColorScheme } from '../UNSAFE_useColorScheme';\nimport { TestIdProps } from '../UNSAFE_useTestId';\nimport {\n  getGlobalTooltipManager,\n  getWrappedTooltipContent,\n  SHOW_TOOLTIP_DELAY,\n  HIDE_TOOLTIP_DELAY\n} from '../../utils/PRIVATE_tooltipUtils';\n\nexport type Position = Omit<Placement, 'center'>;\n\nexport const anchorTos = ['element', 'pointer'] as const;\ntype AnchorTo = (typeof anchorTos)[number];\n\ntype AnchorModel = { x: AnchorTo; y: AnchorTo };\n\ntype Props = {\n  text?: string;\n  variant?: 'tooltip' | 'datatip';\n  isOpen: boolean;\n  position?: Position;\n  isDisabled?: boolean;\n  focusStrategy?: 'browser' | 'logical';\n  anchor?: AnchorModel;\n  offset?: { mainAxis?: number; crossAxis?: number };\n  onToggle?: (details: { value: boolean }) => void;\n} & TestIdProps;\n\n/**\n * The 'mounting' and 'unmounting' states are related to the animation. The 'unmounted' state\n * is used for conditional rendering. In this state, the Tooltip content is completely removed\n * from the DOM. The 'mountPending' and 'unmountPending' are used when timeout is active.\n * The 'reposition' state is used to trigger a transition with new coordinates within\n * the same element.\n */\ntype Status =\n  | 'unmounted'\n  | 'mountPending'\n  | 'mounting'\n  | 'mounted'\n  | 'unmountPending'\n  | 'unmounting';\n\nexport const useTooltipControlled = ({\n  text,\n  isOpen = false,\n  variant = 'tooltip',\n  position = 'bottom',\n  focusStrategy = 'browser',\n  isDisabled = false,\n  anchor = { x: 'element', y: 'element' },\n  offset,\n  onToggle,\n  testId\n}: Props): {\n  tooltipContent: ComponentChild;\n  tooltipProps: Record<string, any>;\n} => {\n  // Global TooltipManager singleton instance\n  const globalTooltipManager = getGlobalTooltipManager();\n\n  const disabled = isDisabled || !text;\n  const isInitialRenderState = useRef<boolean>(true);\n\n  const [state, _setState] = useState<Status>(!disabled && isOpen ? 'mounting' : 'unmounted');\n  const stateRef = useRef<Status>(state);\n  const setState = (newState: Status) => {\n    stateRef.current = newState;\n    _setState(newState);\n  };\n\n  // const tooltipId = useRef<string>(useId());\n\n  const [needsUpdate, setNeedsUpdate] = useState<boolean>(false);\n  setNeedsUpdate(false);\n\n  const isDatatip = variant === 'datatip';\n\n  const [isLogicalFocus, setLogicalFocus] = useState<boolean>(false);\n  const isLogicalFocusStrategy = focusStrategy === 'logical';\n  const isInitialRenderTrigger = useRef<boolean>(true);\n  const { hoverProps, isHover } = useHover({});\n  const { touchProps, isTouch } = useTouch({ isDisabled }); // TODO replace by useLongPress actionhook\n  // we only care about keyboard focus, don't enable useFocus hook if isHover or isTouch are active\n  const { focusProps, isFocus } = useFocus({\n    isDisabled: isLogicalFocusStrategy\n  });\n  // only enable the popoverHover hook if the tooltip is actually open\n  const { hoverProps: popoverHoverProps, isHover: popoverIsHover } = useHover({\n    isDisabled: isDisabled || !isOpen\n  });\n\n  const isPointer = anchor.x === 'pointer' || anchor.y === 'pointer';\n\n  const uniqueIdRef = useRef<string>(useId());\n  const targetRef = useRef<HTMLElement | null>(null);\n  const coordsRef = useRef<Coords>({ x: -9999, y: -9999 });\n  // if anchor is set to pointer and target does not have keyboard focus, use coords\n  const usedRef = isPointer && !isFocus ? coordsRef : targetRef;\n  const showDelay = isDatatip ? 0 : SHOW_TOOLTIP_DELAY;\n  const hideDelay = isDatatip ? 0 : HIDE_TOOLTIP_DELAY;\n  const toggleTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  const currentColorScheme = useColorScheme();\n\n  const focusActive = useRef<boolean>(false);\n  const hoverActive = useRef<boolean>(false);\n\n  const toggleTimeoutClear = () => {\n    if (toggleTimeoutRef.current) {\n      clearTimeout(toggleTimeoutRef.current);\n      toggleTimeoutRef.current = null;\n    }\n  };\n\n  /*\n   * This effect executes when isFocus/isLogicalFocus changes\n   * - focusActive ref is set if the focus change follows a Tab key\n   * - hoverActive ref is reset, if focusActive becomes true\n   */\n  useEffect(() => {\n    if (isLogicalFocusStrategy) {\n      focusActive.current = isLogicalFocus;\n    } else {\n      focusActive.current = isFocus && globalTooltipManager.isTabKeyActive();\n    }\n    if (focusActive.current) {\n      hoverActive.current = false;\n    }\n  }, [isFocus, isLogicalFocus, isLogicalFocusStrategy, globalTooltipManager]);\n\n  /*\n   * This effect executes when isHover state changes\n   * - focusActive ref is reset, if hoverActive becomes true\n   */\n  useEffect(() => {\n    hoverActive.current = isHover;\n  }, [isHover]);\n\n  useEffect(() => {\n    // inner function for state transitions on various trigger changes\n    const updateState = (open: boolean) => {\n      if (open) {\n        // At least one toggle event is set to true\n        switch (state) {\n          case 'unmounted':\n            setState('mountPending'); // Set mount pending state if tooltip is unmounted\n            break;\n          case 'unmounting': // Switch back to mounting when unmounting was in progress and the tooltip should stay on\n            setState('mounting');\n            onToggle?.({ value: true });\n            break;\n          case 'unmountPending':\n            toggleTimeoutClear();\n            setState('mounted'); // Clear timers immediately and keep the tooltip mounted\n            break;\n        }\n      } else {\n        // No toggle events are set to true\n        switch (state) {\n          case 'mounting':\n          case 'mounted':\n            setState('unmountPending'); // Set unmount pending state if tooltip is mounted or in mounting transition\n            break;\n          case 'mountPending':\n            toggleTimeoutClear();\n            __resetCoords();\n            setState('unmounted'); // Unmount tooltip immediately if mounting is pending\n            break;\n        }\n      }\n    };\n\n    if (isInitialRenderTrigger.current) {\n      // On onitial render do not trigger rerender\n      isInitialRenderTrigger.current = false;\n      return;\n    }\n    // When pointer is used, handleMouseMove method is responsible for state updates\n    // until the tooltip is mounted\n    if (isPointer && isHover && state === 'unmounted') {\n      return;\n    }\n    updateState(\n      (isHover && hoverActive.current) ||\n        ((isFocus || isLogicalFocus) && focusActive.current) ||\n        popoverIsHover ||\n        isTouch\n    );\n  }, [isHover, isFocus, isLogicalFocus, popoverIsHover, isTouch, isPointer, state, onToggle]);\n\n  const destroyCallback = useCallback(() => {\n    focusActive.current = false;\n    hoverActive.current = false;\n    onToggle?.({ value: false });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // don't want to depend on the 'onToggle' prop as some clients tend to pass a new callback on each render\n\n  /*\n   * Global mousedown handler to dismiss the tooltip on anchor click. This is especially needed\n   * for Safari which does not fire mouse events during animations when the anchor moves (JET-72605).\n   */\n  const mouseDownHandler = useCallback(\n    (event: MouseEvent) => {\n      if (usedRef.current instanceof Element && usedRef.current.contains(event.target as Element)) {\n        toggleTimeoutClear();\n        document.removeEventListener('mousedown', mouseDownHandler, true);\n        destroyCallback();\n      }\n    },\n    [usedRef, destroyCallback]\n  );\n\n  useEffect(() => {\n    if (isInitialRenderState.current) {\n      // On onitial render do not trigger rerender\n      isInitialRenderState.current = false;\n      return;\n    }\n    setState(isOpen ? 'mounting' : 'unmounting');\n  }, [isOpen]);\n\n  useEffect(() => {\n    return () => {\n      // make sure to clear the toggle timeout on unmount\n      toggleTimeoutClear();\n      // reset focusActive and hoverActive refs\n      focusActive.current = false;\n      hoverActive.current = false;\n    };\n  }, []);\n\n  /*\n   * This effect executes when the component state changes.\n   * On 'mounted' state, the tooltip registers itself with the global tooltip manager.\n   * On 'unmounted', the tooltip unregisters from the global tooltip manager.\n   */\n  useEffect(() => {\n    if (state === 'mounted') {\n      globalTooltipManager.register(destroyCallback);\n    } else if (state === 'unmounted') {\n      globalTooltipManager.unregister(destroyCallback);\n      // clean up the mousedown handler just in case\n      document.removeEventListener('mousedown', mouseDownHandler, true);\n    }\n  }, [state, destroyCallback, globalTooltipManager, mouseDownHandler]);\n\n  /*\n   * Set a timer to toggle the state afer the 'pending' period expires\n   */\n  useEffect(() => {\n    if (!toggleTimeoutRef.current && (state === 'mountPending' || state === 'unmountPending')) {\n      if (state === 'mountPending') {\n        document.addEventListener('mousedown', mouseDownHandler, true);\n      }\n      toggleTimeoutRef.current = setTimeout(\n        () => {\n          toggleTimeoutClear();\n          // make sure the state has not changed in the mean time before onToggle\n          if (\n            (state === 'mountPending' || state === 'unmountPending') &&\n            state === stateRef.current\n          ) {\n            onToggle?.({ value: state === 'mountPending' });\n          }\n        },\n        state === 'mountPending' ? showDelay : hideDelay\n      );\n    }\n    return () => {\n      toggleTimeoutClear();\n    };\n  }, [state, showDelay, hideDelay, onToggle, mouseDownHandler]);\n\n  const handleMouseMove = (event: MouseEvent) => {\n    // we only want track mouse move while the state is 'unmounted' or when moving a 'mounted' datatip\n    if (state !== 'unmounted' && !(variant === 'datatip' && state === 'mounted')) {\n      return;\n    }\n    const targetRect = targetRef?.current?.getBoundingClientRect();\n\n    // Tooltip maintains static offset from left side of window\n    const distanceX = document.body.scrollLeft + (targetRect?.left || 0) + (targetRect?.width || 0);\n\n    // Tooltip maintains static offset from top side of the window\n    const distanceY = document.body.scrollTop + (targetRect?.top || 0) + (targetRect?.height || 0);\n\n    // Display tooltip at the mouse position if both anchors are set to pointer\n    const x = anchor.x === 'pointer' ? event.clientX : distanceX;\n    const y = anchor.y === 'pointer' ? event.clientY : distanceY;\n\n    if (state === 'mounted') {\n      coordsRef.current = { x, y };\n      if (needsUpdate !== true) setNeedsUpdate(true);\n    } else if (state === 'unmounted') {\n      toggleTimeoutClear();\n      toggleTimeoutRef.current = setTimeout(() => {\n        if (state === 'unmounted') {\n          coordsRef.current = { x, y };\n          onToggle?.({ value: true });\n        }\n      }, hideDelay);\n    }\n  };\n\n  const onLogicalFocus = (target: HTMLElement) => {\n    setLogicalFocus(true);\n    targetRef.current = target;\n    usedRef.current = target;\n  };\n\n  const onLogicalBlur = () => {\n    setLogicalFocus(false);\n  };\n\n  const onFocusCallback = useCallback((event: FocusEvent) => {\n    targetRef.current = event.currentTarget as HTMLElement;\n  }, []);\n\n  const onBlurCallback = useCallback((event: FocusEvent) => {\n    if (event.eventPhase === Event.AT_TARGET) {\n      // reset focusActive flag\n      focusActive.current = false;\n    }\n  }, []);\n\n  const focusInitProps = isLogicalFocusStrategy\n    ? {}\n    : {\n        onFocus: onFocusCallback,\n        onBlur: onBlurCallback\n      };\n\n  const hoverInitProps = {\n    onMouseEnter: useCallback((event: MouseEvent) => {\n      targetRef.current = event.target as HTMLElement;\n    }, [])\n  };\n\n  const keyInitProps = {\n    onKeyDown: useCallback(\n      (event: KeyboardEvent) => {\n        if (event.code === 'Escape' && focusActive.current) {\n          event.preventDefault();\n          // focus no longer active after Escape\n          focusActive.current = false;\n          onToggle?.({ value: false });\n        }\n      },\n      [onToggle]\n    )\n  };\n\n  let actionableProps;\n\n  const __resetCoords = () => {\n    coordsRef.current = { x: -9999, y: -9999 };\n  };\n\n  if (disabled) {\n    actionableProps = mergeProps(hoverProps, focusProps, hoverInitProps, focusInitProps);\n  } else {\n    const anchorInitProps = {\n      'aria-describedby': uniqueIdRef.current,\n\n      ...(isPointer && {\n        onMouseLeave: () => {\n          if (state === 'mounting') {\n            return;\n          }\n          toggleTimeoutClear();\n        },\n        onMouseMove: (event: MouseEvent) => {\n          handleMouseMove(event);\n        }\n      })\n    };\n    actionableProps = mergeProps(\n      hoverProps,\n      focusProps,\n      touchProps,\n      hoverInitProps,\n      focusInitProps,\n      anchorInitProps,\n      keyInitProps,\n      isLogicalFocusStrategy ? { onLogicalFocus, onLogicalBlur } : {}\n    );\n  }\n\n  // No need to process tooltip if disabled or no text is provided\n  // Include actionableProps to detect mouseenter in components\n  // hovered state won't update unless actionableProps are already present in the component when mouse enters\n  if (disabled) {\n    toggleTimeoutClear();\n    __resetCoords();\n    return {\n      tooltipContent: null,\n      tooltipProps: actionableProps\n    };\n  }\n\n  const placement = position as Placement;\n\n  const handleTransitionEnd = () => {\n    if (state === 'mounting') {\n      setState('mounted');\n    }\n    if (state === 'unmounting') {\n      __resetCoords();\n      setState('unmounted');\n    }\n  };\n\n  const renderRawContent = (\n    <TooltipContent\n      id={uniqueIdRef.current}\n      testId={testId}\n      isOpen={['mounting', 'mounted', 'unmountPending'].includes(state)}\n      {...popoverHoverProps}\n      isDatatip={isDatatip}\n      onTransitionEnd={handleTransitionEnd}>\n      {text}\n    </TooltipContent>\n  );\n\n  const renderContent = getWrappedTooltipContent(\n    renderRawContent,\n    variant,\n    currentColorScheme,\n    usedRef,\n    placement,\n    offset\n  );\n\n  return {\n    tooltipContent: !['unmounted', 'mountPending'].includes(state) && renderContent,\n    tooltipProps: actionableProps\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useState, useCallback } from 'preact/hooks';\nimport { useTooltipControlled } from './useTooltipControlled';\nimport { TestIdProps } from '../UNSAFE_useTestId';\n\ntype tooltipParameters = Parameters<typeof useTooltipControlled>[0];\n\ntype Props = {\n  text?: string;\n  position?: tooltipParameters['position'];\n  isDisabled?: boolean;\n  anchor?: tooltipParameters['anchor'];\n  offset?: { mainAxis?: number; crossAxis?: number };\n  variant?: tooltipParameters['variant'];\n} & TestIdProps;\n\n/**\n * A hook with tooltip implementation.\n * Returns event handlers that can enhance the target element with a tooltip displayed\n * on hover and focus.\n *\n * @param text tooltip text\n * @param position tooltip placement relative to the target element\n * @param isDisabled determines if the tooltip is disabled\n * @param anchor determines if the target is an element or the pointer\n * @param offset offset from the placement\n * @param variant specifies if the rendered popup should have 'tooltip' or 'datatip' look and behavior\n * @returns an object with the 'tooltipContent' and 'tooltipProps' properties.\n */\nexport const useTooltip = ({\n  text,\n  position = 'bottom',\n  isDisabled = false,\n  anchor = { x: 'element', y: 'element' },\n  offset,\n  variant = 'tooltip',\n  testId\n}: Props): ReturnType<typeof useTooltipControlled> => {\n  const [isOpen, setIsOpen] = useState<boolean>(false);\n  const disabled = isDisabled || !text;\n  const onToggleHandler = useCallback((details: { value: boolean }) => {\n    setIsOpen(details.value);\n  }, []);\n\n  const { tooltipContent, tooltipProps } = useTooltipControlled({\n    text,\n    isOpen,\n    position,\n    isDisabled: disabled,\n    offset,\n    anchor,\n    variant,\n    onToggle: onToggleHandler,\n    testId\n  });\n\n  return {\n    tooltipContent,\n    tooltipProps\n  };\n};\n"],"names":["TooltipContent","children","id","isOpen","isDatatip","onTransitionEnd","testId","props","wrapperRef","useRef","popoverRef","testIdProps","useTestId","baseTheme","variantClasses","styles","useComponentTheme","TooltipContentRedwoodTheme","variant","schemeClass","useThemeInterpolations","nodeRef","useAnimation","animationStates","mounted","_node","childNode","firstChild","from","maxHeight","opacity","to","offsetHeight","options","duration","easing","unmounted","isAnimatedOnMount","onAnimationEnd","useEffect","current","style","height","_jsx","jsx","ref","role","class","classNames","wrapper","inner","content","useTooltipControlled","text","position","focusStrategy","isDisabled","anchor","x","y","offset","onToggle","globalTooltipManager","getGlobalTooltipManager","disabled","isInitialRenderState","state","_setState","useState","stateRef","setState","newState","needsUpdate","setNeedsUpdate","isLogicalFocus","setLogicalFocus","isLogicalFocusStrategy","isInitialRenderTrigger","hoverProps","isHover","useHover","touchProps","isTouch","useTouch","focusProps","isFocus","useFocus","popoverHoverProps","popoverIsHover","isPointer","uniqueIdRef","useId","targetRef","coordsRef","usedRef","showDelay","SHOW_TOOLTIP_DELAY","hideDelay","HIDE_TOOLTIP_DELAY","toggleTimeoutRef","currentColorScheme","useColorScheme","focusActive","hoverActive","toggleTimeoutClear","clearTimeout","isTabKeyActive","open","value","__resetCoords","updateState","destroyCallback","useCallback","mouseDownHandler","event","Element","contains","target","document","removeEventListener","register","unregister","addEventListener","setTimeout","onLogicalFocus","onLogicalBlur","onFocusCallback","currentTarget","onBlurCallback","eventPhase","Event","AT_TARGET","focusInitProps","onFocus","onBlur","hoverInitProps","onMouseEnter","keyInitProps","onKeyDown","code","preventDefault","actionableProps","mergeProps","anchorInitProps","onMouseLeave","onMouseMove","targetRect","getBoundingClientRect","distanceX","body","scrollLeft","left","width","distanceY","scrollTop","top","clientX","clientY","handleMouseMove","tooltipContent","tooltipProps","placement","renderRawContent","includes","renderContent","getWrappedTooltipContent","setIsOpen","onToggleHandler","details"],"mappings":"meAyBaA,EAAiB,EAC5BC,WACAC,KACAC,SACAC,YACAC,kBACAC,YACGC,MAEH,MAAMC,EAAaC,SAAuB,MACpCC,EAAaD,SAAuB,MAEpCE,EAAcC,YAAUN,IAExBO,UAAEA,EAASC,eAAEA,EAAcC,OAAEA,GAAWC,EAAAA,kBAG5CC,EAAAA,2BAA4B,CAC5BC,QAASd,EAAY,UAAY,YAG7Be,EAAcC,EAAAA,0BAEdC,QAAEA,GAAYC,EAAAA,aAAqCnB,EAAS,UAAY,YAAa,CACzFoB,gBAAiB,CACfC,QAAUC,IACR,MAAMC,EAAYD,EAAME,WACxB,MAAO,CACLC,KAAM,CACJC,UAAW,IACXC,QAAS,MAEXC,GAAI,CACFF,UAAW,GAAGH,GAAWM,iBACzBF,QAAS1B,EAAY,OAAS,OAEhC6B,QAAS,CACPC,SAAU9B,EAAY,EAAI,IAC1B+B,OAAQ,CAAC,EAAK,EAAK,GAAK,IAE3B,EAEHC,UAAYX,IACH,CACLG,KAAM,CACJE,QAAS1B,EAAY,OAAS,OAEhC2B,GAAI,CACFF,UAAW,IACXC,QAAS,MAEXG,QAAS,CACPC,SAAU9B,EAAY,EAAI,IAC1B+B,OAAQ,CAAC,EAAK,EAAK,GAAK,OAKhCE,mBAAmB,EACnBC,eAAgB,IAAMjC,QAUxB,OANAkC,EAAAA,WAAU,KACJ/B,EAAWgC,SAAW9B,EAAW8B,SAASR,eAC5CxB,EAAWgC,QAAQC,MAAMC,OAAS,GAAGhC,EAAW8B,SAASR,iBAC1D,GACA,IAGDW,EAAAC,IAAA,MAAA,CACEC,IAAKrC,EACLN,GAAIA,EACJ4C,KAAK,UACLC,MAAOC,EAAAA,WAAW,CAACjC,EAAOkC,QAAS9B,EAAaN,OAC5CF,WACJgC,MAAK,MAAA,CAAAE,IAAKxB,EAAS0B,MAAOhC,EAAOmC,SAAW3C,EAAKN,SAC/C0C,MAAK,MAAA,CAAAE,IAAKnC,EAAYqC,MAAOC,EAAAA,WAAW,CAAClC,EAAgBC,EAAOoC,UAASlD,SACtEA,OAIP,EC/CSmD,EAAuB,EAClCC,OACAlD,UAAS,EACTe,UAAU,UACVoC,WAAW,SACXC,gBAAgB,UAChBC,cAAa,EACbC,SAAS,CAAEC,EAAG,UAAWC,EAAG,WAC5BC,SACAC,WACAvD,aAMA,MAAMwD,EAAuBC,EAAAA,0BAEvBC,EAAWR,IAAeH,EAC1BY,EAAuBxD,UAAgB,IAEtCyD,EAAOC,GAAaC,EAAQA,UAAUJ,GAAY7D,EAAS,WAAa,aACzEkE,EAAW5D,SAAeyD,GAC1BI,EAAYC,IAChBF,EAAS7B,QAAU+B,EACnBJ,EAAUI,EAAS,GAKdC,EAAaC,GAAkBL,EAAQA,UAAU,GACxDK,GAAe,GAEf,MAAMrE,EAAwB,YAAZc,GAEXwD,EAAgBC,GAAmBP,EAAQA,UAAU,GACtDQ,EAA2C,YAAlBrB,EACzBsB,EAAyBpE,UAAgB,IACzCqE,WAAEA,EAAUC,QAAEA,GAAYC,EAAQA,SAAC,CAAE,IACrCC,WAAEA,EAAUC,QAAEA,GAAYC,EAAAA,SAAS,CAAE3B,gBAErC4B,WAAEA,EAAUC,QAAEA,GAAYC,WAAS,CACvC9B,WAAYoB,KAGNE,WAAYS,EAAmBR,QAASS,GAAmBR,EAAAA,SAAS,CAC1ExB,WAAYA,IAAerD,IAGvBsF,EAAyB,YAAbhC,EAAOC,GAAgC,YAAbD,EAAOE,EAE7C+B,EAAcjF,EAAAA,OAAekF,EAAKA,SAClCC,EAAYnF,SAA2B,MACvCoF,EAAYpF,EAAMA,OAAS,CAAEiD,GAAI,KAAMC,GAAI,OAE3CmC,EAAUL,IAAcJ,EAAUQ,EAAYD,EAC9CG,EAAY3F,EAAY,EAAI4F,qBAC5BC,EAAY7F,EAAY,EAAI8F,qBAC5BC,EAAmB1F,SAA6C,MAEhE2F,EAAqBC,EAAAA,iBAErBC,EAAc7F,UAAgB,GAC9B8F,EAAc9F,UAAgB,GAE9B+F,EAAqB,KACrBL,EAAiB3D,UACnBiE,aAAaN,EAAiB3D,SAC9B2D,EAAiB3D,QAAU,KAC5B,EAQHD,EAAAA,WAAU,KAEN+D,EAAY9D,QADVoC,EACoBF,EAEAW,GAAWvB,EAAqB4C,iBAEpDJ,EAAY9D,UACd+D,EAAY/D,SAAU,EACvB,GACA,CAAC6C,EAASX,EAAgBE,EAAwBd,IAMrDvB,EAAAA,WAAU,KACRgE,EAAY/D,QAAUuC,CAAO,GAC5B,CAACA,IAEJxC,EAAAA,WAAU,KAkCJsC,EAAuBrC,QAEzBqC,EAAuBrC,SAAU,EAK/BiD,GAAaV,GAAqB,cAAVb,GAvCR,CAACyC,IACnB,GAAIA,EAEF,OAAQzC,GACN,IAAK,YACHI,EAAS,gBACT,MACF,IAAK,aACHA,EAAS,YACTT,IAAW,CAAE+C,OAAO,IACpB,MACF,IAAK,iBACHJ,IACAlC,EAAS,gBAKb,OAAQJ,GACN,IAAK,WACL,IAAK,UACHI,EAAS,kBACT,MACF,IAAK,eACHkC,IACAK,KACAvC,EAAS,aAGd,EAaHwC,CACG/B,GAAWwB,EAAY/D,UACpB6C,GAAWX,IAAmB4B,EAAY9D,SAC5CgD,GACAN,EACH,GACA,CAACH,EAASM,EAASX,EAAgBc,EAAgBN,EAASO,EAAWvB,EAAOL,IAEjF,MAAMkD,GAAkBC,EAAAA,aAAY,KAClCV,EAAY9D,SAAU,EACtB+D,EAAY/D,SAAU,EACtBqB,IAAW,CAAE+C,OAAO,GAAQ,GAE3B,IAMGK,GAAmBD,eACtBE,IACKpB,EAAQtD,mBAAmB2E,SAAWrB,EAAQtD,QAAQ4E,SAASF,EAAMG,UACvEb,IACAc,SAASC,oBAAoB,YAAaN,IAAkB,GAC5DF,KACD,GAEH,CAACjB,EAASiB,KAGZxE,EAAAA,WAAU,KACJ0B,EAAqBzB,QAEvByB,EAAqBzB,SAAU,EAGjC8B,EAASnE,EAAS,WAAa,aAAa,GAC3C,CAACA,IAEJoC,EAAAA,WAAU,IACD,KAELiE,IAEAF,EAAY9D,SAAU,EACtB+D,EAAY/D,SAAU,CAAK,GAE5B,IAOHD,EAAAA,WAAU,KACM,YAAV2B,EACFJ,EAAqB0D,SAAST,IACX,cAAV7C,IACTJ,EAAqB2D,WAAWV,IAEhCO,SAASC,oBAAoB,YAAaN,IAAkB,GAC7D,GACA,CAAC/C,EAAO6C,GAAiBjD,EAAsBmD,KAKlD1E,EAAAA,WAAU,KACH4D,EAAiB3D,SAAsB,iBAAV0B,GAAsC,mBAAVA,IAC9C,iBAAVA,GACFoD,SAASI,iBAAiB,YAAaT,IAAkB,GAE3Dd,EAAiB3D,QAAUmF,YACzB,KACEnB,IAGa,iBAAVtC,GAAsC,mBAAVA,GAC7BA,IAAUG,EAAS7B,SAEnBqB,IAAW,CAAE+C,MAAiB,iBAAV1C,GACrB,GAEO,iBAAVA,EAA2B6B,EAAYE,IAGpC,KACLO,GAAoB,IAErB,CAACtC,EAAO6B,EAAWE,EAAWpC,EAAUoD,KAE3C,MA+BMW,GAAkBP,IACtB1C,GAAgB,GAChBiB,EAAUpD,QAAU6E,EACpBvB,EAAQtD,QAAU6E,CAAM,EAGpBQ,GAAgB,KACpBlD,GAAgB,EAAM,EAGlBmD,GAAkBd,eAAaE,IACnCtB,EAAUpD,QAAU0E,EAAMa,aAA4B,GACrD,IAEGC,GAAiBhB,eAAaE,IAC9BA,EAAMe,aAAeC,MAAMC,YAE7B7B,EAAY9D,SAAU,EACvB,GACA,IAEG4F,GAAiBxD,EACnB,CAAE,EACF,CACEyD,QAASP,GACTQ,OAAQN,IAGRO,GAAiB,CACrBC,aAAcxB,EAAAA,aAAaE,IACzBtB,EAAUpD,QAAU0E,EAAMG,MAAqB,GAC9C,KAGCoB,GAAe,CACnBC,UAAW1B,EAAAA,aACRE,IACoB,WAAfA,EAAMyB,MAAqBrC,EAAY9D,UACzC0E,EAAM0B,iBAENtC,EAAY9D,SAAU,EACtBqB,IAAW,CAAE+C,OAAO,IACrB,GAEH,CAAC/C,KAIL,IAAIgF,GAEJ,MAAMhC,GAAgB,KACpBhB,EAAUrD,QAAU,CAAEkB,GAAI,KAAMC,GAAI,KAAM,EAG5C,GAAIK,EACF6E,GAAkBC,EAAUA,WAAChE,EAAYM,EAAYmD,GAAgBH,QAChE,CACL,MAAMW,EAAkB,CACtB,mBAAoBrD,EAAYlD,WAE5BiD,GAAa,CACfuD,aAAc,KACE,aAAV9E,GAGJsC,GAAoB,EAEtByC,YAAc/B,IAlGI,CAACA,IAEvB,GAAc,cAAVhD,IAAuC,YAAZhD,GAAmC,YAAVgD,GACtD,OAEF,MAAMgF,EAAatD,GAAWpD,SAAS2G,wBAGjCC,EAAY9B,SAAS+B,KAAKC,YAAcJ,GAAYK,MAAQ,IAAML,GAAYM,OAAS,GAGvFC,EAAYnC,SAAS+B,KAAKK,WAAaR,GAAYS,KAAO,IAAMT,GAAYxG,QAAU,GAGtFgB,EAAiB,YAAbD,EAAOC,EAAkBwD,EAAM0C,QAAUR,EAC7CzF,EAAiB,YAAbF,EAAOE,EAAkBuD,EAAM2C,QAAUJ,EAErC,YAAVvF,GACF2B,EAAUrD,QAAU,CAAEkB,IAAGC,MACL,IAAhBa,GAAsBC,GAAe,IACtB,cAAVP,IACTsC,IACAL,EAAiB3D,QAAUmF,YAAW,KACtB,cAAVzD,IACF2B,EAAUrD,QAAU,CAAEkB,IAAGC,KACzBE,IAAW,CAAE+C,OAAO,IACrB,GACAX,GACJ,EAuEK6D,CAAgB5C,EAAM,IAI5B2B,GAAkBC,EAAUA,WAC1BhE,EACAM,EACAH,EACAsD,GACAH,GACAW,EACAN,GACA7D,EAAyB,CAAEgD,kBAAgBC,kBAAkB,CAAE,EAElE,CAKD,GAAI7D,EAGF,OAFAwC,IACAK,KACO,CACLkD,eAAgB,KAChBC,aAAcnB,IAIlB,MAAMoB,GAAY3G,EAYZ4G,GACJvH,EAAAA,IAAC3C,EACC,CAAAE,GAAIwF,EAAYlD,QAChBlC,OAAQA,EACRH,OAAQ,CAAC,WAAY,UAAW,kBAAkBgK,SAASjG,MACvDqB,EACJnF,UAAWA,EACXC,gBAjBwB,KACZ,aAAV6D,GACFI,EAAS,WAEG,eAAVJ,IACF2C,KACAvC,EAAS,aACV,WAWEjB,IAIC+G,GAAgBC,EAAwBA,yBAC5CH,GACAhJ,EACAkF,EACAN,EACAmE,GACArG,GAGF,MAAO,CACLmG,gBAAiB,CAAC,YAAa,gBAAgBI,SAASjG,IAAUkG,GAClEJ,aAAcnB,GACf,kCClauB,EACxBxF,OACAC,WAAW,SACXE,cAAa,EACbC,SAAS,CAAEC,EAAG,UAAWC,EAAG,WAC5BC,SACA1C,UAAU,UACVZ,aAEA,MAAOH,EAAQmK,GAAalG,EAAQA,UAAU,GACxCJ,EAAWR,IAAeH,EAC1BkH,EAAkBvD,eAAawD,IACnCF,EAAUE,EAAQ5D,MAAM,GACvB,KAEGmD,eAAEA,EAAcC,aAAEA,GAAiB5G,EAAqB,CAC5DC,OACAlD,SACAmD,WACAE,WAAYQ,EACZJ,SACAH,SACAvC,UACA2C,SAAU0G,EACVjK,WAGF,MAAO,CACLyJ,iBACAC,eACD"}