{"version":3,"file":"dataStyleUtils-cf4a0d17.js","sources":["../../src/utils/PRIVATE_chartUtils/navUtils.ts","../../src/utils/PRIVATE_chartUtils/utils.ts","../../src/utils/PRIVATE_visSVGUtils/AreaUtils.ts","../../src/utils/PRIVATE_chartUtils/accUtils.ts","../../src/utils/PRIVATE_chartUtils/dataStyleUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ChartItem, ItemInfo, Info } from '../../UNSAFE_Chart';\ntype isItemNavigableType = (seriesIndex: number, groupIndex: number) => boolean;\n\n/**\n * Returns the next navigable item in the same series.\n * @param seriesIndex\n * @param groupIndex\n * @param numOfGroups\n * @returns\n */\nexport function getNextItemInSeries(\n  info: ItemInfo,\n  viewportEndIndex: number,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const nextGroupIndex = groupIndex + 1;\n\n  if (nextGroupIndex > viewportEndIndex) {\n    return;\n  }\n\n  if (isNavigable(seriesIndex, nextGroupIndex)) {\n    return { seriesIndex, groupIndex: nextGroupIndex };\n  }\n\n  return getNextItemInSeries(\n    {\n      seriesIndex,\n      groupIndex: nextGroupIndex\n    },\n    viewportEndIndex,\n    isNavigable\n  );\n}\n\n/**\n * Returns the previous navigable item in the same series.\n * @param seriesIndex\n * @param itemIndex\n * @returns\n */\nexport function getPrevItemInSeries(\n  info: ItemInfo,\n  viewportStartIndex: number,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const prevGroupIndex = groupIndex - 1;\n\n  if (prevGroupIndex < viewportStartIndex) {\n    return;\n  }\n\n  if (isNavigable(seriesIndex, prevGroupIndex)) {\n    return { seriesIndex, groupIndex: prevGroupIndex };\n  }\n  if (prevGroupIndex === 0) {\n    return undefined;\n  }\n  return getPrevItemInSeries(\n    { seriesIndex, groupIndex: prevGroupIndex },\n    viewportStartIndex,\n    isNavigable\n  );\n}\n\n/**\n * Returns the previous navigable item in the same group.\n * @param seriesIndex\n * @param groupIndex\n * @param isNavigable\n */\nexport function getPrevItemInGroup(\n  info: ItemInfo,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const prevSeriesIndex = seriesIndex - 1;\n  if (prevSeriesIndex < 0) {\n    return;\n  }\n\n  if (isNavigable(prevSeriesIndex, groupIndex)) {\n    return { seriesIndex: prevSeriesIndex, groupIndex };\n  }\n\n  return getPrevItemInGroup(\n    {\n      seriesIndex: prevSeriesIndex,\n      groupIndex\n    },\n    isNavigable\n  );\n}\n\n/**\n * Returns the next navigable item in the same group.\n * @param seriesIndex\n * @param groupIndex\n * @param numOfSeries\n * @param numOfGroups\n */\nexport function getNextItemInGroup(\n  info: ItemInfo,\n  numOfSeries: number,\n  isNavigable: isItemNavigableType\n): ItemInfo | undefined {\n  const { seriesIndex, groupIndex } = info;\n  const nextSeriesIndex = seriesIndex + 1;\n\n  if (nextSeriesIndex >= numOfSeries) {\n    return;\n  }\n\n  if (isNavigable(nextSeriesIndex, groupIndex)) {\n    return { seriesIndex: nextSeriesIndex, groupIndex };\n  }\n\n  return getNextItemInGroup(\n    {\n      seriesIndex: nextSeriesIndex,\n      groupIndex\n    },\n    numOfSeries,\n    isNavigable\n  );\n}\n\n/**\n * Returns the next item in the group with higher value than the current item.\n * @param info The ItemInfo of current item.\n * @param numSeries The number of series in the group.\n * @param getDataItem The function that returns the chart data item.\n * @returns\n */\nexport function getNextHigherItemInGroup<K extends string | number, D extends ChartItem<K>>(\n  info: ItemInfo,\n  numSeries: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isItemNavigable: isItemNavigableType\n) {\n  const { groupIndex, seriesIndex } = info;\n  const item = getDataItem(seriesIndex, groupIndex);\n  if (!item) {\n    return info;\n  }\n\n  let minValue = Number.MAX_VALUE;\n  let minIndex = seriesIndex;\n\n  for (let i = 0; i < numSeries; i++) {\n    const itemValue = getDataItem(i, groupIndex)?.value;\n    if (\n      !itemValue ||\n      itemValue < item.value ||\n      !isItemNavigable(i, groupIndex) ||\n      seriesIndex === i\n    ) {\n      continue;\n    }\n    if (itemValue < minValue) {\n      minValue = itemValue;\n      minIndex = i;\n    }\n  }\n  return { seriesIndex: minIndex, groupIndex };\n}\n\n/**\n * Returns the item info of the item in the group with lower value than the current item.\n * @param info The ItemInfo of the current item.\n * @param numSeries The number of series in the group.\n * @param getDataItem The function that returns the chart data item.\n * @returns\n */\nexport function getNextLowerItemInGroup<K extends string | number, D extends ChartItem<K>>(\n  info: ItemInfo,\n  numSeries: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isItemNavigable: isItemNavigableType\n) {\n  const { groupIndex, seriesIndex } = info;\n  const item = getDataItem(seriesIndex, groupIndex);\n  if (!item) {\n    return info;\n  }\n\n  let maxValue = Number.MIN_VALUE;\n  let maxIndex = seriesIndex;\n\n  for (let i = 0; i < numSeries; i++) {\n    const itemValue = getDataItem(i, groupIndex)?.value;\n    if (\n      !itemValue ||\n      itemValue > item.value ||\n      !isItemNavigable(i, groupIndex) ||\n      seriesIndex === i\n    ) {\n      continue;\n    }\n\n    if (itemValue > maxValue) {\n      maxValue = itemValue;\n      maxIndex = i;\n    }\n  }\n  return { seriesIndex: maxIndex, groupIndex };\n}\n\nexport function getLineAreaChartNavUtil<K extends string | number, D extends ChartItem<K>>(\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  numSeries: number,\n  viewportStartIndex: number,\n  viewportEndIndex: number,\n  isStacked: boolean,\n  isRtl: boolean,\n  isHoriz: boolean\n) {\n  const isItemNavigable = (seriesIndex: number, groupIndex: number) => {\n    const barItem = getDataItem(seriesIndex, groupIndex);\n    return Boolean(barItem);\n  };\n\n  const getNextChartItem = (\n    itemInfo: Info,\n    arrow: 'ArrowLeft' | 'ArrowRight' | 'ArrowDown' | 'ArrowUp'\n  ): Info => {\n    let newInfo: Info | undefined;\n\n    const info = {\n      groupIndex: itemInfo.groupIndex!,\n      seriesIndex: itemInfo.seriesIndex!\n    };\n\n    if (info.groupIndex < viewportStartIndex) {\n      info.groupIndex = viewportStartIndex;\n      return info;\n    } else if (info.groupIndex > viewportEndIndex) {\n      info.groupIndex = viewportEndIndex;\n      return info;\n    }\n\n    if (arrow === 'ArrowLeft') {\n      if (!isHoriz) {\n        newInfo = isRtl\n          ? getNextItemInSeries(info, viewportEndIndex, isItemNavigable)\n          : getPrevItemInSeries(info, viewportStartIndex, isItemNavigable);\n      } else {\n        newInfo = isRtl\n          ? getNextHigherItemInGroup(info, numSeries, getDataItem, isItemNavigable)\n          : getNextLowerItemInGroup(info, numSeries, getDataItem, isItemNavigable);\n      }\n    } else if (arrow === 'ArrowRight') {\n      if (!isHoriz) {\n        newInfo = isRtl\n          ? getPrevItemInSeries(info, viewportStartIndex, isItemNavigable)\n          : getNextItemInSeries(info, viewportEndIndex, isItemNavigable);\n      } else {\n        newInfo = !isRtl\n          ? getNextHigherItemInGroup(info, numSeries, getDataItem, isItemNavigable)\n          : getNextLowerItemInGroup(info, numSeries, getDataItem, isItemNavigable);\n      }\n    } else if (arrow === 'ArrowDown') {\n      if (isHoriz) {\n        newInfo = getNextItemInSeries(info, viewportEndIndex, isItemNavigable);\n      } else {\n        if (isStacked) {\n          newInfo = getPrevItemInGroup(info, isItemNavigable);\n        } else {\n          newInfo = getNextLowerItemInGroup(info, numSeries, getDataItem, isItemNavigable);\n        }\n      }\n    } else {\n      if (isHoriz) {\n        newInfo = getPrevItemInSeries(info, viewportStartIndex, isItemNavigable);\n      } else {\n        if (isStacked) {\n          newInfo = getNextItemInGroup(info, numSeries, isItemNavigable);\n        } else {\n          newInfo = getNextHigherItemInGroup(info, numSeries, getDataItem, isItemNavigable);\n        }\n      }\n    }\n    return newInfo || info;\n  };\n\n  return getNextChartItem;\n}\n","/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { MarkerShapes } from '../../UNSAFE_SvgShapes';\nimport { Point } from '../PRIVATE_visSVGUtils';\nimport { curveThroughPoints } from '../PRIVATE_visSVGUtils/PathUtils';\nimport { ChartItem } from '../../UNSAFE_Chart/chart.types';\nimport { Scale } from '../../UNSAFE_Chart';\nimport { ColorProps } from '../UNSAFE_interpolations/colors';\nimport { colorSchemeVars } from '../../Common/themes/themeContract.css';\nimport { rgb, rgba } from '../../UNSAFE_Theme';\nimport { getStraightAreaPath, getCurveAreaPath } from '../PRIVATE_visSVGUtils/AreaUtils';\nimport { getGroupCenterCoord } from '../../utils/PRIVATE_chartUtils/layoutUtils';\nimport { LineAreaItem } from '../../UNSAFE_LineAreaChart/lineAreaChart.types';\nimport { Group } from '../../UNSAFE_Axis/axis.types';\n\nexport function getCmdsForArea(\n  lineSegmentCoords: Point[],\n  bottomCoords: Point[],\n  areaType: 'straight' | 'curved',\n  isHoriz: boolean,\n  isBottomSegmentCurved: boolean\n) {\n  if (areaType === 'straight') {\n    return getStraightAreaPath(lineSegmentCoords, bottomCoords);\n  }\n  return getCurveAreaPath(\n    lineSegmentCoords,\n    bottomCoords,\n    false,\n    isHoriz ? 'mh' : 'mv',\n    isBottomSegmentCurved\n  );\n}\n\nexport function getCmdsForLine(\n  lineSegmentCoords: Point[],\n  lineType: 'straight' | 'curved',\n  isHoriz: boolean\n) {\n  if (lineType === 'straight') {\n    return lineSegmentCoords.join(' ');\n  }\n  return curveThroughPoints(lineSegmentCoords, false, isHoriz ? 'mh' : 'mv');\n}\n/**\n * Returns the cumulative series for stacked chart.\n */\nexport function getCumulativeSeries<K extends string | number, D extends ChartItem<K>>(\n  numSeries: number,\n  numGroups: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  hiddenIds: Set<number | string>,\n  isLog: boolean\n) {\n  const series: number[][] = [];\n  for (let seriesIndex = 0; seriesIndex < numSeries; seriesIndex += 1) {\n    const currentSeries: number[] = [];\n    const prevSeries = series[seriesIndex - 1];\n    for (let groupIndex = 0; groupIndex < numGroups; groupIndex += 1) {\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (!item || hiddenIds?.has(item.id) || (isLog && item.value <= 0)) {\n        continue;\n      }\n      if (seriesIndex) {\n        currentSeries[groupIndex] = item.value + prevSeries[groupIndex];\n      } else {\n        currentSeries[groupIndex] = item.value;\n      }\n    }\n    series.push(currentSeries);\n  }\n  return series;\n}\n\n/**\n * Returns the series data.\n */\nexport function getSeriesData<K extends string | number, D extends ChartItem<K>>(\n  numSeries: number,\n  numGroups: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  hiddenIds: Set<number | string>,\n  isLog: boolean\n) {\n  const series: number[][] = [];\n  for (let seriesIndex = 0; seriesIndex < numSeries; seriesIndex += 1) {\n    const currentSeries: number[] = [];\n    for (let groupIndex = 0; groupIndex < numGroups; groupIndex += 1) {\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (!item || hiddenIds?.has(item.id) || (isLog && item.value <= 0)) {\n        continue;\n      }\n      currentSeries[groupIndex] = item.value;\n    }\n    series.push(currentSeries);\n  }\n  return series;\n}\n\n/**\n * Returns the markertype order.\n */\nexport function getMarkers(): MarkerShapes[] {\n  return ['square', 'circle', 'diamond', 'plus', 'triangleDown', 'triangleUp'];\n}\n\n/**\n * Returns the marker fill and stroke depending on the state.\n */\nexport function getMarkerFillAndStroke( // TODO : JET-62244 - Replace getMarkerFillAndStroke function with classes.\n  isMarkerDisplayed: boolean,\n  isSelectionEnabled: boolean,\n  isHovered: boolean,\n  isFocused: boolean,\n  isSelected: boolean,\n  seriesColor: ColorProps['color'],\n  itemColor?: ColorProps['color']\n) {\n  let fill;\n  let stroke;\n  let outerStroke;\n\n  if (isSelectionEnabled) {\n    if (isSelected) {\n      if (isMarkerDisplayed) {\n        // TODO: settle on one visual for selected markers: \n        // Selected effect when markers are turned on\n        fill = itemColor || seriesColor;\n        outerStroke = rgb(colorSchemeVars.palette.neutral[130]);\n        stroke = rgb(colorSchemeVars.palette.neutral[0]);\n      } else {\n        // Selected effect when markers are not turned on\n        fill = rgb(colorSchemeVars.palette.neutral[0]);\n        if (isHovered || isFocused) {\n          stroke = itemColor || seriesColor;\n        } else {\n          stroke = rgb(colorSchemeVars.palette.neutral[130]);\n        }\n      }\n    } else if (isHovered || isFocused) {\n      stroke = itemColor || seriesColor;\n      fill = rgb(colorSchemeVars.palette.neutral[0]);\n    } else {\n      if (isMarkerDisplayed) {\n        fill = itemColor || seriesColor;\n        stroke = rgb(colorSchemeVars.palette.neutral[0]);\n      } else {\n        fill = rgba(colorSchemeVars.palette.neutral[0], 0);\n        stroke = rgba(colorSchemeVars.palette.neutral[0], 0);\n      }\n    }\n  } else if (isMarkerDisplayed) {\n    fill = itemColor || seriesColor;\n    stroke = rgb(colorSchemeVars.palette.neutral[0]);\n  } else {\n    stroke = isFocused ? itemColor || seriesColor : rgba(colorSchemeVars.palette.neutral[0], 0);\n    fill = rgba(colorSchemeVars.palette.neutral[0], 0);\n  }\n  return { fill, stroke, outerStroke };\n}\n\n/**\n * Returns the coordinates of line or area based on orientation and size of the chart.\n */\nexport function getLineAreaSegments<K extends string | number, D extends LineAreaItem<K>>(\n  yScale: Scale,\n  xScale: Scale,\n  data: number[],\n  startIndex: number,\n  endIndex: number,\n  isHorizontal: boolean,\n  isLog: boolean,\n  groups: Group[],\n  seriesIndex: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency'\n): Point[][] {\n  const segments: Point[][] = [];\n  let currentPath: Point[] = [];\n\n  for (let groupIndex = startIndex; groupIndex < endIndex + 1; groupIndex += 1) {\n    const item = data[groupIndex];\n\n    if (item == null || (isLog && item <= 0)) {\n      segments.push(currentPath);\n      currentPath = [];\n      continue;\n    }\n    const x = isHorizontal\n      ? yScale.transform(item)\n      : getGroupCenterCoord(\n          groups[groupIndex],\n          groupIndex,\n          xScale,\n          getDataItem(seriesIndex, groupIndex)!,\n          timeAxisType\n        );\n    const y = isHorizontal\n      ? getGroupCenterCoord(\n          groups[groupIndex],\n          groupIndex,\n          xScale,\n          getDataItem(seriesIndex, groupIndex)!,\n          timeAxisType\n        )\n      : yScale.transform(item);\n    currentPath.push([x, y]);\n    if (groupIndex === endIndex) {\n      segments.push(currentPath);\n    }\n  }\n  return segments;\n}\n","/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Point } from './LineUtils';\nimport { curveThroughPoints } from './PathUtils';\n\n/**\n * Returns a straight area path command.\n * @param {array} lineSegmentCoords Polyline top points array.\n * @param {array} bottomCoords Polyline bottom points array.\n * @return {string} Straight area path commands.\n */\nexport function getStraightAreaPath(lineSegmentCoords: Point[], bottomCoords: Point[]) {\n  // Create the path data string\n  let pathData;\n  if (lineSegmentCoords.length > 0) {\n    pathData =\n      lineSegmentCoords\n        .map((lineSegmentCoord, index) => {\n          return `${index === 0 ? 'M' : 'L'} ${lineSegmentCoord[0]} ${lineSegmentCoord[1]}`;\n        })\n        .join(' ') +\n      [...bottomCoords]\n        .reverse()\n        .map((bottomCoord) => {\n          return `L ${bottomCoord[0]} ${bottomCoord[1]}`;\n        })\n        .join(' ') +\n      'Z';\n  }\n  return pathData;\n}\n\n/**\n * Returns a curved area path command, based on cubic hermite splines, that goes through the points in the points array.\n * @param {array} lineSegmentCoords Polyline top points array.\n * @param {array} bottomCoords Polyline bottom points array.\n * @param {boolean} connectWithLine Whether the first point is reached using lineTo. Otherwise, moveTo is used.\n * @param {string} splineType The spline type.\n * @return {string} Curved area path commands.\n */\nexport function getCurveAreaPath(\n  lineSegmentCoords: Point[],\n  bottomCoords: Point[],\n  connectWithLine: boolean,\n  splineType: string,\n  isBottomSegmentCurved?: boolean\n) {\n  let pathData;\n  if (lineSegmentCoords.length > 0) {\n    if (!isBottomSegmentCurved) {\n      pathData =\n        curveThroughPoints(lineSegmentCoords, connectWithLine, splineType) +\n        [...bottomCoords]\n          .reverse()\n          .map((bottomCoord) => {\n            return `L ${bottomCoord[0]} ${bottomCoord[1]}`;\n          })\n          .join(' ') +\n        'Z';\n    } else {\n      pathData =\n        curveThroughPoints(lineSegmentCoords, false, splineType) +\n        ' ' +\n        curveThroughPoints([...bottomCoords].reverse(), true, splineType) +\n        ' Z';\n    }\n  }\n  return pathData;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { BundleType } from \"../../resources/nls/bundle\";\n\n/**\n * Returns the aria label for the chart item\n * @param translations The translations bundle.\n * @param series The series of the item.\n * @param group The group of the item.\n * @param value The value of the item.\n * @param isSelected Whether the item is selected.\n * @param isDrillable Whether the item is drillable.\n * @param accessibleLabel The accessible label of the item.\n * @returns \n */\nexport function getItemAriaLabel(\n    translations: BundleType,\n    series: string,\n    group: string,\n    value: number,\n    isSelectionEnabled: boolean,\n    isSelected: boolean,\n    isDrillable: boolean,\n    accessibleLabel?: string,\n) {\n    const seriesLabel = translations.chart_labelSeries();\n    const groupLabel = translations.chart_labelGroup();\n    const valueLabel = translations.chart_labelValue();\n\n    const label = accessibleLabel ||  `${seriesLabel}: ${series}; ${groupLabel}: ${group}; ${valueLabel}: ${value};`\n    const selectedLabel = translations.dataVisualization_stateSelected();\n    const unselectedLabel = translations.dataVisualization_stateUnselected();\n    const drillableLabel = translations.viz_drillable();\n\n    return [\n        label,\n        isSelectionEnabled ? (isSelected ? selectedLabel: unselectedLabel) : '',\n        isDrillable ? drillableLabel: ''\n    ].filter(Boolean).join(' ');\n}","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { getColorRamp } from '../../utils/UNSAFE_visUtils';\nimport { BarItem, BarSeries } from '../../UNSAFE_BarChart/barChart.types';\nimport { LineAreaItem, LineAreaSeries } from '../../UNSAFE_LineAreaChart/lineAreaChart.types';\nimport { getMarkers } from './utils';\n\nexport function getItemColor<K, D>(\n  seriesIndex: number,\n  groupIndex: number,\n  series: (LineAreaSeries<K, D> | BarSeries<K, D>)[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => LineAreaItem<K> | BarItem<K> | undefined\n) {\n  const item = getDataItem(seriesIndex, groupIndex);\n  if (item?.color) {\n    return item.color;\n  }\n\n  if ((item as LineAreaItem<K>).markerColor) {\n    return (item as LineAreaItem<K>).markerColor;\n  }\n  const itemSeries = series[seriesIndex] as LineAreaSeries<K, D>;\n\n  const colors = getColorRamp();\n  return (\n    itemSeries.color ||\n    itemSeries.lineColor ||\n    itemSeries.areaColor ||\n    colors[seriesIndex % colors.length]\n  );\n}\n\nexport function getMarkerType<K>(\n  seriesIndex: number,\n  groupIndex: number,\n  chartType: 'bar' | 'lineWithArea',\n  getDataItem: (seriesIndex: number, groupIndex: number) => LineAreaItem<K> | BarItem<K> | undefined\n) {\n  if (chartType === 'bar') {\n    return 'circle';\n  }\n  const item = getDataItem(seriesIndex, groupIndex);\n  if ((item as LineAreaItem<K>).markerType) {\n    return (item as LineAreaItem<K>).markerType;\n  }\n  const shapes = getMarkers();\n  return shapes[seriesIndex % shapes.length];\n}\n"],"names":["getNextItemInSeries","info","viewportEndIndex","isNavigable","seriesIndex","groupIndex","nextGroupIndex","getPrevItemInSeries","viewportStartIndex","prevGroupIndex","getPrevItemInGroup","prevSeriesIndex","getNextItemInGroup","numOfSeries","nextSeriesIndex","getNextHigherItemInGroup","numSeries","getDataItem","isItemNavigable","item","minValue","Number","MAX_VALUE","minIndex","i","itemValue","value","getNextLowerItemInGroup","maxValue","MIN_VALUE","maxIndex","getMarkers","lineSegmentCoords","bottomCoords","areaType","isHoriz","isBottomSegmentCurved","pathData","length","map","lineSegmentCoord","index","join","reverse","bottomCoord","getStraightAreaPath","connectWithLine","splineType","curveThroughPoints","getCurveAreaPath","lineType","numGroups","hiddenIds","isLog","series","currentSeries","prevSeries","has","id","push","translations","group","isSelectionEnabled","isSelected","isDrillable","accessibleLabel","seriesLabel","chart_labelSeries","groupLabel","chart_labelGroup","valueLabel","chart_labelValue","label","selectedLabel","dataVisualization_stateSelected","unselectedLabel","dataVisualization_stateUnselected","drillableLabel","viz_drillable","filter","Boolean","color","markerColor","itemSeries","colors","getColorRamp","lineColor","areaColor","isStacked","isRtl","barItem","itemInfo","arrow","newInfo","yScale","xScale","data","startIndex","endIndex","isHorizontal","groups","timeAxisType","segments","currentPath","x","transform","getGroupCenterCoord","y","isMarkerDisplayed","isHovered","isFocused","seriesColor","itemColor","fill","stroke","outerStroke","rgb","colorSchemeVars","palette","neutral","rgba","chartType","markerType","shapes"],"mappings":"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"}