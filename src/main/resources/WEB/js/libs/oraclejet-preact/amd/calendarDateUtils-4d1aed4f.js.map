{"version":3,"file":"calendarDateUtils-4d1aed4f.js","sources":["../../src/utils/UNSAFE_calendarDateUtils/calendarDateUtils.ts"],"sourcesContent":["import { CalendarDate, CalendarMonth, CalendarMonthRequired, DateGranularity, DatePlaceholders, MonthYearPlaceholders, IsoDay, IsoMonth } from './types';\n\nimport {\n  BCP47Locale,\n  DateISOStr,\n  DateTimeUtils,\n  NativeDateTimeOptions,\n  getFormatParse\n} from '#UNSAFE_IntlDateTime';\n\nconst MAX_ISO_YEAR = 9999;\nconst MIN_ISO_YEAR = 0;\nconst MIN_ISO_DAY = 1;\nconst MIN_ISO_MONTH = 1;\n\nconst checkNoCalendarExtension = (locale: BCP47Locale) => {\n  if (locale.indexOf('-u-ca-') !== -1) {\n    throw new Error('Calendar not allowed in locale');\n  }\n};\n\nconst toJSDate = (year: number, month: IsoMonth, day: IsoDay) => {\n  // Date uses 0-based index for month.\n  return new Date(year, month - 1, day);\n};\n\n/**\n * This function formats a test date using Intl.DateTimeFormat for the given locale.\n * It then uses Intl.DateTimeFormat.formatToParts to get the parts of the date in a\n * locale specific order, substitutes translated placeholders, and filters out\n * unwanted parts of the date. If granularity = month, then the placeholder for day\n * is removed. The shape of the return value matches what is returned by formatToParts.\n *\n * @param locale The BCP47Locale\n * @param granularity Specifies whether you want placeholders for month, year OR day, month, year\n * @param monthPlaceholder The translated month placeholder\n * @param dayPlaceholder The translated day placeholder\n * @param yearPlaceholder The translated year placeholder\n */\nconst getDatePlaceholderMasks = (\n  locale: BCP47Locale,\n  granularity: 'month' | 'day',\n  monthPlaceholder: string,\n  dayPlaceholder: string,\n  yearPlaceholder: string\n): DatePlaceholders => {\n  checkNoCalendarExtension(locale);\n  const testDate = new Date('2022-11-30');\n  const formatter = new Intl.DateTimeFormat(locale, { dateStyle: 'short' });\n\n  // Filter out anything that is not month, day, year, or literal (e.g. a separator).\n  const filterByType = (p: Intl.DateTimeFormatPart) => {\n    return (\n      (granularity === 'day' && p.type === 'day') ||\n      p.type === 'month' ||\n      p.type === 'year' ||\n      p.type === 'literal'\n    );\n  };\n\n  // Substitute translated placeholders. Trim literals for visual consistency (they can include whitespace)\n  // so the date looks more like a string when the placeholders are rendered next to each other.\n  const mapTranslatedPlaceholders = (p: Intl.DateTimeFormatPart) => {\n    switch (p.type) {\n      case 'month':\n        return { ...p, value: monthPlaceholder };\n      case 'day':\n        return { ...p, value: dayPlaceholder };\n      case 'year':\n        return { ...p, value: yearPlaceholder };\n      default:\n        return { ...p, value: p.value.trim() };\n    }\n  };\n\n  const parts = formatter.formatToParts(testDate).filter(filterByType);\n  let placeholders = parts.map(mapTranslatedPlaceholders);\n\n  // Remove any repeated literals, which can occur after filtering (such as mm//yyyy).\n  placeholders = removeExcessiveLiteralsFromPlaceholders(placeholders);\n\n  return placeholders as DatePlaceholders;\n};\n\n/**\n * Return the number of days in a given month and year. Pass '*' if you don't know a value.\n * If neither month or year are known, then return the maximum number of days in any month in any year.\n * If only month is known, return the maximum number of days for that month in any year.\n * For Gregorian calendar:\n *   getDaysInMonth(2, *) => returns 29\n *   getDaysInMonth(*, *) => returns 31\n *   getDaysInMonth(*, 2023) => returns 31\n */\nconst getDaysInMonth = (month: IsoMonth | '*', year: number | '*') => {\n  if (month === '*') {\n    return 31;\n  } else if (year === '*') {\n    return getDaysInMonthGregorian(month);\n  } else {\n    checkIsValidIsoYear(year);\n    // DateTimeUtils.getDaysInMonth uses a 0-based index.\n    return DateTimeUtils.getDaysInMonth(year, month - 1);\n  }\n};\n\n/**\n * Return the number of months in a given year. Pass '*' if you don't know the year.\n * In a Gregorian calendar the number of months is always 12. We'll have to revisit this\n * when multiple calendars are supported; in some cases the number of months can vary by year.\n */\nconst getMonthsInYear = (year: number | '*') => {\n  if (year !== '*') {\n    checkIsValidIsoYear(year);\n  }\n  return 12;\n};\n\n/**\n * Return the number of days in a month in the Gregorian calendar, without knowing the year.\n */\nconst getDaysInMonthGregorian = (month: IsoMonth) => {\n  switch (month) {\n    case 1:\n    case 3:\n    case 5:\n    case 7:\n    case 8:\n    case 10:\n    case 12:\n      return 31;\n    case 2:\n      return 29; // Since we don't know the year, return the maximum possible number of days.\n    default:\n      return 30;\n  }\n};\n\n/**\n * Throw an error if year is not a valid ISO year (0-9999).\n * The allowed range is too large to express using Typescript.\n */\nconst checkIsValidIsoYear = (year: number) => {\n  if (year < MIN_ISO_YEAR || year > MAX_ISO_YEAR) {\n    throw new Error('Invalid year value');\n  }\n};\n\n/**\n * This utility method uses Intl.DateTimeFormat directly to format with month: long and\n * year: numeric. It returns something like 'May 2025'.\n */\nconst getLongFormattedYearMonth = (locale: BCP47Locale, year: number, month: IsoMonth) => {\n  const formatter = new Intl.DateTimeFormat(locale, { month: 'long', year: 'numeric' });\n  return formatter.format(toJSDate(year, month, 1));\n};\n\n/**\n * Construct and return an IS0 date string from year, month, and day.\n */\nconst getIsoDateStr = (year: number, month: IsoMonth, day: IsoDay) => {\n  checkIsValidIsoYear(year);\n\n  // Month and day must be 2 digits and year must be 4 digits to be a valid ISO 8601 string.\n  const parts = [\n    year.toString().padStart(4, '0'),\n    month.toString().padStart(2, '0'),\n    day.toString().padStart(2, '0')\n  ];\n  return parts.join('-');\n};\n\n/**\n * Parse a DateIsoStr and return an equivalent CalendarDate.\n */\nconst getCalendarDateFromIso = (str: DateISOStr) => {\n  if (!DateTimeUtils.isDateOnlyIsoString(str)) {\n    return undefined;\n  }\n\n  const parts = str.split('-');\n  return { year: +parts[0], month: +parts[1], day: +parts[2] } as unknown as CalendarDate;\n};\n\n/**\n * Return the calendar date for year, month, and day formatted using the specified date style\n * in the given locale.\n */\nconst getFormattedYearMonthDay = (\n  locale: BCP47Locale,\n  year: number,\n  month: IsoMonth,\n  day: IsoDay,\n  style: NonNullable<Intl.DateTimeFormatOptions['dateStyle']>\n) => {\n  checkNoCalendarExtension(locale);\n  const dateIsoStr = getIsoDateStr(year, month, day);\n\n  const dateFormatOptions: NativeDateTimeOptions = {\n    locale,\n    dateStyle: style,\n    dateStyleShortYear: style === 'short' ? 'numeric' : undefined\n  };\n  const { format } = getFormatParse(dateFormatOptions);\n  return format(dateIsoStr);\n};\n\n/**\n * Format and return the calendar date as a string. If the date is not a complete\n * date, i.e. any of its segments are missing, return an empty string.\n */\nconst formatCalendarDateAsString = (\n  locale: BCP47Locale,\n  calendarDate: CalendarDate,\n  style: NonNullable<Intl.DateTimeFormatOptions['dateStyle']>\n) => {\n  if (!calendarDate.year || !calendarDate.month || !calendarDate.day) {\n    return '';\n  }\n  return getFormattedYearMonthDay(\n    locale,\n    calendarDate.year,\n    calendarDate.month,\n    calendarDate.day,\n    style\n  );\n};\n\n/**\n * Format an example DateISOStr in short format.\n */\nconst formatIsoDateStrAsExample = (\n  locale: BCP47Locale,\n  str: DateISOStr,\n  masks?: DatePlaceholders,\n  granularity?: DateGranularity\n) => {\n  const calDate = getCalendarDateFromIso(str);\n  // The placeholders aren't used for formatting, so use dummy values.\n  const dateMasks =\n    masks ?? getDatePlaceholderMasks(locale, granularity ?? 'day', 'mm', 'dd', 'yyyy');\n  return calDate === undefined\n    ? ''\n    : formatShortCalendarDate(calDate, granularity ?? 'day', dateMasks);\n};\n\n/**\n * Format an example CalendarMonthRequired in short format.\n */\nconst formatCalendarMonthRequiredAsExample = (\n  locale: BCP47Locale,\n  calMonth: CalendarMonthRequired,\n  masks?: DatePlaceholders\n) => {\n  // The placeholders aren't used for formatting, so use dummy values.\n  const dateMasks = masks ?? getDatePlaceholderMasks(locale, 'month', 'mm', 'dd', 'yyyy');\n  return calMonth === undefined ? '' : formatShortCalendarDate(calMonth, 'month', dateMasks);\n};\n\n/**\n * Format a CalendarDate in short format.\n */\nconst formatShortCalendarDate = (\n  cd: CalendarDate,\n  granularity: DateGranularity,\n  masks: DatePlaceholders\n) => {\n  if (!cd.year || !cd.month || (granularity === 'day' && !cd.day)) {\n    return '';\n  }\n  const dateValues = masks.map(({ type, value }) =>\n    type === 'year' ? cd.year : type === 'month' ? cd.month : type === 'day' ? cd.day : value.trim()\n  );\n  return dateValues.join('');\n};\n\n/**\n * Format a CalendarDate in full format.\n */\nconst formatFullCalendarDate = (\n  locale: BCP47Locale,\n  cd: CalendarDate,\n  granularity: DateGranularity\n) => {\n  if (!cd.year || !cd.month || (granularity === 'day' && !cd.day)) {\n    return '';\n  }\n  checkNoCalendarExtension(locale);\n\n  return granularity === 'day'\n    ? getFormattedYearMonthDay(locale, cd.year, cd.month, cd.day!, 'full')\n    : getLongFormattedYearMonth(locale, cd.year, cd.month);\n};\n\n// returns true if undefined or null, or if the value has a year and month property that are valid.\n// This is used to check if the value, min and max properties are valid in input-month-mask.\n// This is equivalent to DateTimeUtils.isDateOnlyIsoString that is used for input-date-mask.\nconst isValidCalendarMonthRequired = (value?: CalendarMonthRequired | null) => {\n  if (value === undefined || value === null) return true;\n  const { year, month } = value;\n\n  const isValidNumber = (num: number | undefined, max: number | undefined): boolean => {\n    return (\n      typeof num === 'number' &&\n      Number.isInteger(num) &&\n      num > 0 &&\n      (max === undefined || num <= max)\n    );\n  };\n\n  // Check if the value is a complete object and its month is valid\n  if (isValidNumber(year, MAX_ISO_YEAR) && isValidNumber(month, getMonthsInYear(year))) {\n    return true;\n  }\n  return false;\n};\n\nconst isCompleteCalendarDate = (value: CalendarDate) => {\n  const { year, month, day } = value;\n\n  // Check if the value is a complete object\n  return year !== undefined && month !== undefined && day !== undefined;\n};\n\nconst isCompleteCalendarMonth = (value: CalendarMonth) => {\n  const { year, month } = value;\n\n  // Check if the value is a complete object\n  return year !== undefined && month !== undefined;\n};\n\n// Given a pattern, return a DatePlaceholder array.\nconst getDatePlaceholdersFromPattern = (pattern: string) => {\n  const arr = getMaskArrayFromPattern(pattern);\n  const datePlaceholders = convertMaskArrayToDatePlaceholders(arr);\n  return datePlaceholders;\n};\n\n// Given a pattern, like 'd-m-yyyy', return an array like ['d', '-', 'm', '-', 'yyyy']\nconst getMaskArrayFromPattern = (pattern: string) => {\n  const result: Array<string> = [];\n  let currentSegmentStr = '';\n  let currentLiteral = '';\n\n  const addSegment = () => {\n    if (currentSegmentStr !== '') {\n      result.push(currentSegmentStr);\n      currentSegmentStr = '';\n    }\n  };\n\n  const addLiteral = () => {\n    if (currentLiteral !== '') {\n      // InputDateMask does not want spaces in its literals. Even if InputDateMask\n      // trims its literals for the masks property, we do so here as well\n      // since we could end up using this for things that are\n      // outside of InputDateMasks masks property.\n      result.push(currentLiteral.trim());\n      currentLiteral = '';\n    }\n  };\n\n  for (let i = 0; i < pattern.length; i++) {\n    const char = pattern[i];\n\n    if (char.toLowerCase() === 'm' || char.toLowerCase() === 'd' || char.toLowerCase() === 'y') {\n      addLiteral();\n      currentSegmentStr += char;\n    } else {\n      addSegment();\n      currentLiteral += char;\n    }\n  }\n\n  // Add the last components\n  addSegment();\n  addLiteral();\n\n  return result;\n};\n\nconst getMonthYearPlaceholdersFromDatePlaceholders = (\n  datePlaceholders: DatePlaceholders\n): MonthYearPlaceholders => {\n  // filter out day\n  const noDay = datePlaceholders.filter((part) => part.type !== 'day');\n  // now filter out the extra literal\n  const monthYearPlaceholders = removeExcessiveLiteralsFromPlaceholders(noDay);\n  return monthYearPlaceholders as MonthYearPlaceholders;\n};\n\n// converts an array into the object that is needed to set on the InputDateMask's masks property, DatePlaceholder[];\nconst convertMaskArrayToDatePlaceholders = (array: Array<string>) => {\n  return array.map((item) => {\n    if (item.toLowerCase()[0] === 'd') {\n      return { type: 'day', value: item };\n    } else if (item.toLowerCase()[0] === 'm') {\n      return { type: 'month', value: item };\n    } else if (item.toLowerCase()[0] === 'y') {\n      return { type: 'year', value: item };\n    } else {\n      // Default to literal for anything else\n      return { type: 'literal', value: item };\n    }\n  }) as DatePlaceholders;\n};\n\nconst removeExcessiveLiteralsFromPlaceholders = (\n  placeholders: { value: string; type: keyof Intl.DateTimeFormatPartTypesRegistry }[]\n) => {\n  const index = placeholders.findIndex((element, index, array) => {\n    return element.type === 'literal' && index > 0 && array[index - 1].type === 'literal';\n  });\n  if (index !== -1) {\n    placeholders = placeholders.slice(0, index).concat(placeholders.slice(index + 1));\n  }\n\n  // Remove any leading or trailing literals. Leading literals can occur after filtering,\n  // and certain locales include trailing literals such as mm.dd.yyyy. which we don't want.\n  if (placeholders[placeholders.length - 1].type === 'literal') {\n    placeholders = placeholders.slice(0, -1);\n  }\n  if (placeholders[0].type === 'literal') {\n    placeholders = placeholders.slice(1);\n  }\n  return placeholders;\n};\n\nexport {\n  MIN_ISO_DAY,\n  MIN_ISO_MONTH,\n  MIN_ISO_YEAR,\n  MAX_ISO_YEAR,\n  checkIsValidIsoYear,\n  checkNoCalendarExtension,\n  formatCalendarDateAsString,\n  formatShortCalendarDate,\n  formatFullCalendarDate,\n  formatCalendarMonthRequiredAsExample,\n  formatIsoDateStrAsExample,\n  getCalendarDateFromIso,\n  getDatePlaceholderMasks,\n  getFormattedYearMonthDay,\n  getDaysInMonth,\n  getDatePlaceholdersFromPattern,\n  getMonthYearPlaceholdersFromDatePlaceholders,\n  getIsoDateStr,\n  getMonthsInYear,\n  isCompleteCalendarDate,\n  isCompleteCalendarMonth,\n  isValidCalendarMonthRequired\n};\n"],"names":["MAX_ISO_YEAR","checkNoCalendarExtension","locale","indexOf","Error","getDatePlaceholderMasks","granularity","monthPlaceholder","dayPlaceholder","yearPlaceholder","testDate","Date","placeholders","Intl","DateTimeFormat","dateStyle","formatToParts","filter","p","type","map","value","trim","removeExcessiveLiteralsFromPlaceholders","getMonthsInYear","year","checkIsValidIsoYear","getDaysInMonthGregorian","month","getLongFormattedYearMonth","format","day","toJSDate","getIsoDateStr","toString","padStart","join","getCalendarDateFromIso","str","DateTimeUtils.isDateOnlyIsoString","parts","split","getFormattedYearMonthDay","style","dateIsoStr","dateFormatOptions","dateStyleShortYear","undefined","getFormatParse","formatShortCalendarDate","cd","masks","getMaskArrayFromPattern","pattern","result","currentSegmentStr","currentLiteral","addSegment","push","addLiteral","i","length","char","toLowerCase","convertMaskArrayToDatePlaceholders","array","item","index","findIndex","element","slice","concat","calendarDate","calMonth","dateMasks","calDate","arr","DateTimeUtils.getDaysInMonth","datePlaceholders","noDay","part","isValidNumber","num","max","Number","isInteger"],"mappings":"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"}