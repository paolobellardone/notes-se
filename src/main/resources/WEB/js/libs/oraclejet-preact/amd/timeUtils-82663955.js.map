{"version":3,"file":"timeUtils-82663955.js","sources":["../../src/utils/UNSAFE_timeUtils/timeUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { EditableTimeSegmentType, OrderedTimeSegmentsArray } from '#UNSAFE_InputTimeMask/types';\nimport { BCP47Locale, DateTimeUtils } from '#UNSAFE_IntlDateTime';\nimport { TimeISOStr } from '#UNSAFE_IntlDateTime/types';\nimport { checkNoCalendarExtension } from '#utils/UNSAFE_calendarDateUtils';\nimport {\n  AmPmLocalizedValues,\n  FilteredDateTimeFormatPart,\n  Hour,\n  Millisecond,\n  MillisecondPlaceholder,\n  Minute,\n  Second,\n  Time,\n  TimeGranularity,\n  TimePlaceholders\n} from './types';\n\n// For locales that start with 'en', we use these placeholders.\nconst EN_LOCALE_PLACEHOLDER_HOUR = 'hh';\nconst EN_LOCALE_PLACEHOLDER_MINUTE = 'mm';\nconst EN_LOCALE_PLACEHOLDER_SECOND = 'ss';\nconst EN_LOCALE_PLACEHOLDER_MILLISECOND = 'sss';\n// For locales that do not start with 'en', we use these placeholders.\nconst NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER = '--';\nconst NON_EN_LOCALE_THREE_DIGIT_PLACEHOLDER = '---';\n\nconst AM_VALUE = 0;\nconst PM_VALUE = 12;\n\n/**\n * Parses an ISO 8601 time-only string e.g., 'T01:00:00.000' or 'T01:00', and returns a Time object\n * containing 'hour' and 'minute', with optional 'second' and 'millisecond'.\n *\n * If the input is invalid (empty, null, undefined, or incorrectly formatted), this function returns undefined.\n * @param {TimeISOStr} isoTime - The ISO 8601 time string that starts with 'T'. (e.g., \"T12:30:45.123\")\n * @returns  (Time | undefined)\n * Returns a Time object with hour and minute, and optionally second and millisecond if they are in the input ISO string.\n * If the input is invalid, return undefined.\n */\nconst getTimeObjFromTimeOnlyISOStr = (isoTime: TimeISOStr | undefined | null) => {\n  // Ensure the input is defined and properly formatted.\n  if (isoTime === undefined || isoTime === null || !DateTimeUtils.isTimeOnlyIsoString(isoTime)) {\n    return undefined;\n  }\n\n  // Remove 'T' prefix and split into time and optional millisecond parts.\n  // A valid time-only ISO string must have hour and minute, and may optionally have second and millisecond.\n  const timePart = isoTime.substring(1);\n  const [fullTime, milliPart] = timePart.split('.');\n  const [hour, minute, second] = fullTime.split(':').map((num) => parseInt(num, 10));\n\n  const result: Time = { hour: hour as Hour, minute: minute as Minute };\n\n  if (second !== undefined) {\n    result.second = second as Second;\n\n    if (milliPart !== undefined) {\n      const millisecond = parseInt(milliPart, 10);\n      result.millisecond = millisecond as Millisecond;\n    }\n  }\n  return result;\n};\n\n/**\n * Given a Time object with hour, minute, and optionally second and millisecond, return a time-only ISO string that starts with 'T'.\n * @param {Time | undefined} Time object or undefined. The hour and minute must be defined, otherwise this function returns undefined.\n * @returns {TimeISOStr} Time-only ISO string that starts with 'T'. If the time is undefined, or the hour or minute are undefined, returns undefined.\n */\nconst getTimeOnlyISOStrFromTimeObj = (time: Time | undefined) => {\n  if (time === undefined) {\n    return undefined;\n  }\n\n  const { hour, minute, second, millisecond } = time;\n\n  if (hour === undefined || minute === undefined) {\n    return undefined;\n  }\n\n  // Hour and minute must be 2 digits to be a valid ISO 8601 string.\n  const parts = [hour.toString().padStart(2, '0'), minute.toString().padStart(2, '0')];\n  let isoTime = parts.join(':');\n\n  if (second !== undefined) {\n    const secondPart = second.toString().padStart(2, '0');\n    isoTime += ':' + secondPart;\n\n    if (millisecond !== undefined) {\n      const msPart = millisecond.toString().padStart(3, '0');\n      if (msPart) {\n        isoTime += '.' + msPart;\n      }\n    }\n  }\n  return `T${isoTime}`;\n};\n\n/**\n * Returns a new array where the value in the masks array of type/value objects is replaced\n * with the string placeholders based on the locale.\n * For example, [{type='hour', value='hh'}, {type='minute', value='mm'} for 'en' locales,\n * or value='--' for non-'en' locales.\n * @param {BCP47Locale} locale - The locale.\n * @param {TimePlaceholders} masks - The TimePlaceholder masks\n * @returns A new array where the value in the masks array of type/value objects is replaced with\n * the string placeholders based on the locale.\n */\nconst replaceCustomMasksValuesWithPlaceholders = (\n  locale: BCP47Locale,\n  masks: TimePlaceholders\n): TimePlaceholders => {\n  const {\n    hourPlaceholder,\n    minutePlaceholder,\n    secondPlaceholder,\n    millisecondPlaceholder,\n    dayPeriodPlaceholder\n  } = getTimePlaceholderValuesFromLocale(locale);\n\n  return masks.map((p) => {\n    switch (p.type) {\n      case 'hour':\n        return { ...p, value: hourPlaceholder };\n      case 'minute':\n        return { ...p, value: minutePlaceholder };\n      case 'second':\n        return { ...p, value: secondPlaceholder };\n      case 'millisecond':\n        return { ...p, value: millisecondPlaceholder };\n      case 'dayPeriod':\n        return { ...p, value: dayPeriodPlaceholder };\n      default:\n        return { ...p };\n    }\n  }) as TimePlaceholders;\n};\n\n/**\n * Retrieves the TimePlaceholders masks where value has the placeholder (e.g., 'hh' or '--')\n * by using a new instance of Intl.DateTimeFormat with the locale, granularity, and hour12.\n *\n * @param {BCP47Locale} locale - The locale\n * @param {TimeGranularity} granularity - The granularity of the desired time mask.\n * @param hour12 - passes through to Intl.DateTimeFormat's hour12, which indicates\n * if the hour is a 12-hour (as opposed to 24-hour) clock.\n * E.g., new Intl.DateTimeFormat('en-GB', {timeStyle: 'short', hour12: true}).format(date)\n * @returns Returns the TimePlaceholder masks where value has the placeholders (e.g., 'hh' or '--').\n */\nconst getTimeMasksFromLocaleAndOptions = (\n  locale: BCP47Locale = 'en-US',\n  granularity: TimeGranularity,\n  hour12?: boolean\n) => {\n  checkNoCalendarExtension(locale);\n\n  // Filter out anything not related to a time mask.\n  // This does not filter out spaces, e.g., the literal space between the time and the dayPeriod.\n  const filterByTimeType = (parts: Intl.DateTimeFormatPart[]) => {\n    return parts.filter(\n      (p): p is FilteredDateTimeFormatPart =>\n        p.type === 'minute' ||\n        p.type === 'hour' ||\n        p.type === 'second' ||\n        p.type === 'dayPeriod' ||\n        p.type === 'literal'\n    );\n  };\n\n  const testDateWithTime = new Date('2022-11-30T00:00:00');\n  // If granularity is milliseconds, we use timeStyle: 'medium'. Later we stitch in the literal and millisecond part to medium since\n  // there is not a timeStyle for milliseconds, and you cannot use fractionalSecond: 3 with timeStyle in Intl.DateTimeFormat.\n  const timeStyle = granularity === 'minute' ? 'short' : 'medium';\n  const formatter = getTimeFormatterShortMedium(locale, timeStyle, hour12);\n\n  const parts = formatter.formatToParts(testDateWithTime);\n\n  const timeParts = filterByTimeType(parts);\n\n  // If granularity is millisecond, then add a separator and fractionalSecond to the array after seconds.\n  let allTimeParts;\n  if (granularity === 'millisecond') {\n    allTimeParts = insertFractionalSecond(locale, timeParts);\n  } else {\n    allTimeParts = timeParts;\n  }\n\n  // map it so that it has the same type as InputTimeMask's masks type of TimePlaceholders\n  const masks = allTimeParts.map((part) => {\n    switch (part.type) {\n      case 'fractionalSecond':\n        return { type: 'millisecond', value: part.value } as MillisecondPlaceholder;\n      case 'hour':\n      case 'minute':\n      case 'second':\n      case 'dayPeriod':\n      case 'literal':\n        return { ...part };\n    }\n  });\n\n  // replace part value with placeholder\n  return replaceCustomMasksValuesWithPlaceholders(locale, masks as TimePlaceholders);\n};\n\nconst cachedFractionalSecondsDigitFormatter = new Map<BCP47Locale, Intl.DateTimeFormat>();\n/**\n * Returns a new array with the fractionalSecond part\n * and its preceding separator part merged into the parts array after the seconds part.\n *\n * There is not an Intl.DateTimeFormat timeStyle option that displays milliseconds,\n * and you cannot use fractionalSecond: 3 with a timeStyle option at the same time in Intl.DateTimeFormat.\n * Therefore to get the parts for granularity: 'millisecond',\n * get parts from timeStyle: 'medium' and call this function with those parts. This function will stitch in\n * the separator and fractionalSecond parts after the 'second' part.\n *\n * @param {BCP47Locale} locale\n * @param {FilteredDateTimeFormatPart[]} parts - The parts from calling Intl.DateTimeFormat with timeStyle: 'medium'.\n * @returns a new parts array with the fractionalSecond and its preceding separator stitched into the parts array\n * after the 'second' part.\n */\nconst insertFractionalSecond = (locale: BCP47Locale, parts: FilteredDateTimeFormatPart[]) => {\n  const index = parts.findIndex((part) => part.type === 'second');\n  if (index === -1) {\n    // 'second' not found, return the array as is\n    return parts;\n  }\n\n  const cacheKey = `${locale}`;\n  let formatter = cachedFractionalSecondsDigitFormatter.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.DateTimeFormat(locale, {\n      hour: 'numeric',\n      minute: 'numeric',\n      second: '2-digit',\n      fractionalSecondDigits: 3,\n      numberingSystem: 'latn'\n    });\n    cachedFractionalSecondsDigitFormatter.set(cacheKey, formatter);\n  }\n\n  // get separatorValue that comes before the fractionalSecond part.\n  const partsWithFractionalSeconds = formatter.formatToParts(new Date());\n  const separatorPart = getLiteralBeforeFractionalSecond(partsWithFractionalSeconds);\n  if (separatorPart === null) {\n    return parts;\n  }\n  const newParts: FilteredDateTimeFormatPart[] = [\n    { type: 'literal', value: separatorPart.value },\n    { type: 'fractionalSecond', value: 'sss' }\n  ];\n\n  return [...parts.slice(0, index + 1), ...newParts, ...parts.slice(index + 1)];\n};\n\n/**\n * Finds and returns the 'literal' part immediately before the first 'fractionalSecond' part in an\n * array of Intl.DateTimeFormatPart objects. If not found, returns null.\n * @param {Intl.DateTimeFormatPart[]} parts\n * @returns {Intl.DateTimeFormatPart[]|null} - The literal part before the 'fractionalSecond' part.\n */\nconst getLiteralBeforeFractionalSecond = (parts: Intl.DateTimeFormatPart[]) => {\n  const index = parts.findIndex((part) => part.type === 'fractionalSecond');\n  if (index > 0 && parts[index - 1].type === 'literal') {\n    return parts[index - 1];\n  }\n  return null;\n};\n\n/**\n * Creates an object with the time segment placeholders based on the locale.\n * For locales that start with 'en', we use 'hh', 'mm', 'ss', 'sss', for\n * other locales we use '--' or '---' if millisecond.\n *\n * @param {BCP47Locale} locale\n * @returns An object with the time segment placeholders.\n */\nconst getTimePlaceholderValuesFromLocale = (locale: BCP47Locale) => {\n  const { am } = getAmPmStringsForLocale(locale);\n\n  if (locale.startsWith('en')) {\n    return {\n      hourPlaceholder: EN_LOCALE_PLACEHOLDER_HOUR,\n      minutePlaceholder: EN_LOCALE_PLACEHOLDER_MINUTE,\n      secondPlaceholder: EN_LOCALE_PLACEHOLDER_SECOND,\n      millisecondPlaceholder: EN_LOCALE_PLACEHOLDER_MILLISECOND,\n      dayPeriodPlaceholder: am\n    };\n  }\n\n  return {\n    hourPlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,\n    minutePlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,\n    secondPlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,\n    millisecondPlaceholder: NON_EN_LOCALE_THREE_DIGIT_PLACEHOLDER,\n    dayPeriodPlaceholder: am\n  };\n};\n\n/**\n * Creates a time formatter using new Intl.DateTimeFormat for the locale.\n * @param {BCP47Locale} locale - The locale to format the time.\n * @param {'short'|'medium'} timeStyle - The timeStyle formatting option.\n * @param {boolean} hour12 - Whether to use 12-hour time format.\n * @returns A new formatter instance for the specified locale and options.\n */\nconst getTimeFormatterShortMedium = (\n  locale: BCP47Locale,\n  timeStyle: 'short' | 'medium',\n  hour12?: boolean\n) => {\n  const options =\n    hour12 === undefined\n      ? { timeStyle, numberingSystem: 'latn' }\n      : { timeStyle, hour12, numberingSystem: 'latn' };\n\n  return new Intl.DateTimeFormat(locale, options);\n};\n\n/**\n * Gets the day period value strings for AM and PM.\n *\n * @param {BCP47Locale} locale - The locale to format the time.\n * @returns An object containing the AM and PM strings for the locale.\n */\nconst getAmPmStringsForLocale = (locale: BCP47Locale): AmPmLocalizedValues => {\n  const am = getDayPeriodValueStr(locale, 0); // 0 is 12 AM\n  const pm = getDayPeriodValueStr(locale, 13); // 13 is 1 PM\n  return { am, pm };\n};\n\nconst cachedDayPeriodString = new Map<string, string>();\n\n/**\n * Retrieves the day period string for a specific locale and hour.\n * This uses a cache so a new instance of Intl.DateTimeFormat with hour12: true so even if the locale\n * does not have a 1-12 hour time by default, the hour12: true parameter will force it.\n * For example, for 'en-US' if the hour is 0, this returns 'AM'. If the hour is 13, this returns 'PM'.\n * For 'ms', if the hour is 0, this returns 'PG'.\n *\n * @param {BCP47Locale} locale - The locale to format the time.\n * @param {Hour} hour - The hour for which to get the day period (0-23).\n * @returns {string} The locale's day period value for the hour. All locales have a dayPeriod string, but\n * just in case we default to 'AM' and 'PM'.\n */\nconst getDayPeriodValueStr = (locale: BCP47Locale = 'en-US', hour: Hour) => {\n  const morningIsoHourStr = '00';\n  const eveningIsoHourStr = '23';\n  const isoHourStr = hour < 12 ? morningIsoHourStr : eveningIsoHourStr;\n\n  // is locale + isoHourStr in the cache? If so, return it.\n  const dayPeriod = cachedDayPeriodString.get(`${locale}-${isoHourStr}`);\n  if (!dayPeriod) {\n    // This sets hour12 to true.\n    const formatter = getTimeFormatterShortMedium(locale, 'short', true);\n    // Cache both am and pm values at the same time in order to use the same formatter for performance sake.\n    [morningIsoHourStr, eveningIsoHourStr].forEach((hourToCache) => {\n      const isoStr = `2022-11-30T${hourToCache}:00:00`;\n      const date = new Date(isoStr);\n      const parts = formatter.formatToParts(date);\n      const dayPeriodPart = parts.find((p) => p.type === 'dayPeriod');\n      // All locales I tested have a dayPeriod string when hour12: true,\n      // but just in case there is a locale for Intl.DateTimeFormat with no dayPeriod string, we default to one.\n      const defaultDayPeriodToCache = hourToCache === morningIsoHourStr ? 'AM' : 'PM';\n      const dayPeriodToCache = dayPeriodPart ? dayPeriodPart.value : defaultDayPeriodToCache;\n      cachedDayPeriodString.set(`${locale}-${hourToCache}`, dayPeriodToCache);\n    });\n    // return the dayPeriod for the hour requested that we just cached.\n    return cachedDayPeriodString.get(`${locale}-${isoHourStr}`)!;\n  }\n  return dayPeriod;\n};\n\nconst getDayPeriodValueFromHour = (hour: Hour) => {\n  return hour > 11 ? PM_VALUE : AM_VALUE;\n};\n\n/**\n * Formats a Time object into a string based on the provided masks.\n * Handles hour conversion (12-hour/24-hour) since the Time object is in 24-hour format,\n * and the mask, if it has the dayPeriod, is in 12-hour format. Applies leading\n * zeros to hour if leadingZeroForHour is true. Pads zeros to minute, second, and millisecond so\n * that the digits equal two for minute/second and three for millisecond.\n * The timeMasks must have the correct segments to match the granularity before calling this function.\n * @param locale\n * @param time\n * @param granularity\n * @param timeMasks\n * @param leadingZeroForHour\n * @returns a formatted time string\n */\nconst formatTimeFromMasks = (\n  locale: BCP47Locale,\n  time: Time,\n  granularity: TimeGranularity,\n  timeMasks: TimePlaceholders,\n  leadingZeroForHour: boolean\n) => {\n  checkNoCalendarExtension(locale);\n  // First, the time must be complete.\n  if (\n    time.hour === undefined ||\n    time.minute === undefined ||\n    (granularity === 'second' && time.second === undefined) ||\n    (granularity === 'millisecond' && time.millisecond === undefined)\n  ) {\n    return '';\n  }\n\n  const hasDayPeriod = timeMasks.some((part) => part.type === 'dayPeriod');\n  const dayPeriodToDisplay = hasDayPeriod ? getDayPeriodValueStr(locale, time.hour) : ''; // e.g., 'AM' or 'PM' for 'en-US'\n\n  // Format hour with optional leading zero\n  const timeHour = hasDayPeriod ? to12Hour(time.hour) : time.hour;\n  const hourToDisplay = leadingZeroForHour ? padWithZero(timeHour, 2) : timeHour.toString();\n\n  // Format minute, second, and millisecond with necessary padding\n  const minuteToDisplay = padWithZero(time.minute, 2);\n  const secondToDisplay = padWithZero(time.second, 2);\n  const millisecondToDisplay = padWithZero(time.millisecond, 3);\n\n  // Map timeMasks to their corresponding values and join them into a formatted time string.\n  const timeValues = timeMasks.map(({ type, value }) =>\n    type === 'hour'\n      ? hourToDisplay\n      : type === 'minute'\n      ? minuteToDisplay\n      : type === 'second'\n      ? secondToDisplay\n      : type === 'millisecond'\n      ? millisecondToDisplay\n      : type === 'dayPeriod'\n      ? dayPeriodToDisplay\n      : value\n  );\n  return timeValues.join('');\n};\n\n/**\n * Retrieves the hour string. If the display has a day period, then the hour string\n * will be 1-12, otherwise it will be 0-23.\n * @param hour\n * @param hasDayPeriod true if the time to display has a day period segment (e.g., a segment that shows AM or PM).\n * This means the time field has a 1-12 hour time.\n * @param leadingZeroForHour If true, the hour string will have length of 2, with leading zeros if necessary to pad it out.\n * @returns\n */\nconst getHourValueStr = (hour: Hour, hasDayPeriod: boolean, leadingZeroForHour: boolean) => {\n  // If hasDayPeriod, the hour to display is in the range of 1-12. E.g., 1:00 AM.\n  // Since the hour parameter is 0-23, the hour to display needs to be converted to a 1-12 hour string.\n  // If hasDayPeriod is false, the hour to display is in the range of 0-23. E.g., 01:00.\n  const timeHour = hasDayPeriod ? to12Hour(hour) : hour;\n  return leadingZeroForHour ? padWithZero(timeHour, 2) : timeHour.toString();\n};\n\nconst cachedTimeStyleShortHasLeadingZero = new Map<BCP47Locale, boolean>();\n/**\n * Returns true if the locale's hour has a leading zero by default.\n *\n * This method uses a cached new Intl.DateTimeFormat(locale),\n * and uses formatToParts for hour\n * to figure out if the hour has a leading zero.\n *\n * @param {BCP47Locale} locale - the locale\n * @returns true if hour starts with 0 for the specific locale.\n */\nconst getLeadingZeroForHour = (locale: BCP47Locale) => {\n  // check timeStyle short for the locale\n  // and see if the hour starts with 0.\n  // if so, return true;\n  const value = new Date('1995-12-17T09:30:00');\n  const cacheKey = `${locale}`;\n  let isLeadingZero = cachedTimeStyleShortHasLeadingZero.get(cacheKey);\n  if (isLeadingZero === undefined) {\n    const formatter = new Intl.DateTimeFormat(locale, {\n      timeStyle: 'short',\n      numberingSystem: 'latn'\n    });\n    const parts = formatter.formatToParts(value);\n    const hourPart = parts.find((part) => part.type === 'hour');\n    const hourValue = hourPart?.value!;\n    isLeadingZero = hourValue.startsWith('0');\n    cachedTimeStyleShortHasLeadingZero.set(cacheKey, isLeadingZero);\n  }\n\n  return isLeadingZero;\n};\n\n/**\n * Converts the 24-hour hour to a 12-hour hour.\n * @param {Hour} hour24\n * @returns\n */\nconst to12Hour = (hour24: Hour) => {\n  const hour12 = hour24 % 12 === 0 ? 12 : hour24 % 12;\n  return hour12;\n};\n\nconst padWithZero = (num: number | undefined, length: number) => {\n  return num !== undefined ? num.toString().padStart(length, '0') : '';\n};\n\n/**\n * Returns true if the time params represent two different times.\n * @param t1\n * @param t2\n * @returns true if the time params represent two different times.\n */\nconst timesAreDifferent = (t1: Time | undefined, t2: Time | undefined) => {\n  const isEmpty = (time: Time | undefined) => {\n    return (\n      !time || // if time is undefined\n      (time.hour === undefined &&\n        time.minute === undefined &&\n        time.second === undefined &&\n        time.millisecond === undefined)\n    );\n  };\n\n  // Both are empty/undefined, return false (same)\n  if (isEmpty(t1) && isEmpty(t2)) return false;\n\n  // If one is empty/undefined and the other isn't, return true (different)\n  if (isEmpty(t1) !== isEmpty(t2)) return true;\n\n  // Return true if any of the segment values don't match.\n  if (\n    t1?.hour !== t2?.hour ||\n    t1?.minute !== t2?.minute ||\n    t1?.second !== t2?.second ||\n    t1?.millisecond !== t2?.millisecond\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Determines whether the input string matches the start of the 'am' and/or 'pm' strings in the given am/pm object.\n *\n * The match is case-insensitive and ignores leading and trailing whitespace.\n *\n * If the input matches with only the start of the 'am' string, 'am' is returned.\n * If the input matches with only the start of the 'pm' string, 'pm' is returned.\n * If the input matches the start of both the 'am' and 'pm strings (e.g., the 'am'/'pm' strings have the same starting letter(s) and the input is too short to disambiguate),\n * 'both is returned.\n * If the input does not match the start of either string, 'none' is returned.\n * @param {AmPmLocalizedValues} amPmObj - An object containing the am and pm strings for the current locale.\n * @param {string} input - The user provided string to match against the am an pm strings.\n * @returns {('am' | 'pm' | 'none' | 'both')}\n */\nconst getAmPmMatchType = (amPmObj: AmPmLocalizedValues, input: string) => {\n  const trimmedInput = input.trim().toLowerCase();\n\n  // If input is empty after trimming, return 'none'\n  if (trimmedInput === '') {\n    return 'none';\n  }\n\n  // Check if the input matches as a prefix in either property (am or pm)\n  const matchesAM = amPmObj.am.toLowerCase().startsWith(trimmedInput);\n  const matchesPM = amPmObj.pm.toLowerCase().startsWith(trimmedInput);\n\n  // If both match, return 'both'\n  if (matchesAM && matchesPM) {\n    return 'both';\n  }\n\n  // If only one matches, return that\n  if (matchesAM) {\n    return 'am';\n  }\n\n  if (matchesPM) {\n    return 'pm';\n  }\n\n  // If neither matches\n  return 'none';\n};\n\n/**\n * Check if the value has segments in it that are not displayed to the user.\n * E.g., originalValue: {hour: 1, minute: 30, second: 59, millisecond: 599}, and the segments are: ['hour', 'minute'], returns true.\n * originalValue: {millisecond: 599}, and the segments are: ['hour', 'minute'], returns true.\n * originalValue: {second: 599}, and the segments are: ['hour', 'minute'], returns true.\n * originalValue: {second: 599}, and the segments are: ['hour', 'minute'], returns true.\n * originalValue: {hour: 1, minute: 30, second: 599}, and the segments are: ['hour', 'minute', 'second'], returns false.\n * @param orderedSegments {OrderedTimeSegmentsArray} - The segments that are displayed to the user\n * @param originalValue {Time|undefined} - The original Time value.\n * @returns {boolean} returns true if the originalValue has segments that are not displayed to the user.\n */\nconst hasSegmentsNotDisplayed = (\n  orderedSegments: OrderedTimeSegmentsArray,\n  originalValue: Time | undefined\n) => {\n  if (originalValue === undefined) {\n    return false;\n  }\n  // orderedSegments are the segments that are displayed to the user.\n  // filter out the 'dayPeriod' since that is not part of the Time object.\n  const filteredSegments = orderedSegments.filter((item) => item !== 'dayPeriod');\n\n  // loop through each key in the original value and see if it exists in the filteredSegments\n  const hasExtraSegmentsCondition = (key: string) =>\n    (key === 'hour' || key === 'minute' || key === 'second' || key === 'millisecond') &&\n    !filteredSegments.includes(key);\n  return Object.keys(originalValue).some(hasExtraSegmentsCondition);\n};\n\n/**\n * Returns true if any one of the displayed time segments has a different value in initialTime vs updatedTime.\n * @param orderedSegments {OrderedTimeSegmentsArray} the time segments that are displayed to the user\n * @param initialTime {Time} The initial time.\n * @param updatedTime {Time} The updated time.\n * @returns true if the displayed time segments have different values\n */\nconst displayedTimeSegmentsAreDifferent = (\n  orderedSegments: OrderedTimeSegmentsArray,\n  initialTime: Time,\n  updatedTime: Time\n) => {\n  // orderedSegments are the segments that are displayed to the user.\n  // filter out the 'dayPeriod' since that is not part of the Time object.\n  const filteredSegments = orderedSegments.filter((item) => item !== 'dayPeriod') as Array<\n    Exclude<EditableTimeSegmentType, 'dayPeriod'>\n  >;\n  for (const key of filteredSegments) {\n    const value1 = initialTime[key]; // might be undefined. In which case, this will return true if value2 also has undefined for this key.\n    const value2 = updatedTime[key];\n    if (value1 !== value2) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport {\n  AM_VALUE,\n  PM_VALUE,\n  displayedTimeSegmentsAreDifferent,\n  formatTimeFromMasks,\n  getAmPmMatchType,\n  getAmPmStringsForLocale,\n  getDayPeriodValueFromHour,\n  getDayPeriodValueStr,\n  getHourValueStr,\n  getTimeOnlyISOStrFromTimeObj,\n  getLeadingZeroForHour,\n  getTimeObjFromTimeOnlyISOStr,\n  getTimeMasksFromLocaleAndOptions,\n  hasSegmentsNotDisplayed,\n  padWithZero,\n  replaceCustomMasksValuesWithPlaceholders,\n  timesAreDifferent\n};\n"],"names":["NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER","replaceCustomMasksValuesWithPlaceholders","locale","masks","hourPlaceholder","minutePlaceholder","secondPlaceholder","millisecondPlaceholder","dayPeriodPlaceholder","getTimePlaceholderValuesFromLocale","map","p","type","value","cachedFractionalSecondsDigitFormatter","Map","insertFractionalSecond","parts","index","findIndex","part","cacheKey","formatter","get","Intl","DateTimeFormat","hour","minute","second","fractionalSecondDigits","numberingSystem","set","partsWithFractionalSeconds","formatToParts","Date","separatorPart","getLiteralBeforeFractionalSecond","newParts","slice","am","getAmPmStringsForLocale","startsWith","getTimeFormatterShortMedium","timeStyle","hour12","options","undefined","getDayPeriodValueStr","pm","cachedDayPeriodString","morningIsoHourStr","eveningIsoHourStr","isoHourStr","dayPeriod","forEach","hourToCache","date","dayPeriodPart","find","defaultDayPeriodToCache","dayPeriodToCache","cachedTimeStyleShortHasLeadingZero","to12Hour","hour24","padWithZero","num","length","toString","padStart","orderedSegments","initialTime","updatedTime","filteredSegments","filter","item","key","time","granularity","timeMasks","leadingZeroForHour","checkNoCalendarExtension","millisecond","hasDayPeriod","some","dayPeriodToDisplay","timeHour","hourToDisplay","minuteToDisplay","secondToDisplay","millisecondToDisplay","join","amPmObj","input","trimmedInput","trim","toLowerCase","matchesAM","matchesPM","isLeadingZero","hourPart","hourValue","testDateWithTime","timeParts","filterByTimeType","allTimeParts","isoTime","DateTimeUtils.isTimeOnlyIsoString","timePart","substring","fullTime","milliPart","split","parseInt","result","msPart","originalValue","Object","keys","includes","t1","t2","isEmpty"],"mappings":"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"}