{"version":3,"file":"DrawerPopup-772c8c22.js","sources":["../../src/UNSAFE_DrawerPopup/DrawerPopup.tsx"],"sourcesContent":["import { JSX, RefObject } from 'preact';\nimport { useState, useRef, useEffect, useCallback, useMemo } from 'preact/hooks';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport { Layer } from '../UNSAFE_Layer';\nimport { Modal } from '../UNSAFE_Modal';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport {\n  getAutofocusFocusables,\n  focusOn,\n  focusWithin,\n  getActiveElement,\n  focusOnElementOrNearestAncestor\n} from '../utils/PRIVATE_tabbableUtils';\nimport { normalizePosition } from '../utils/PRIVATE_floatingUtils';\nimport { RtlSide } from '../UNSAFE_Floating';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\n\n// Hooks\nimport { useOutsideClick } from '../hooks/UNSAFE_useOutsideClick';\nimport { useAnimation } from '../hooks/UNSAFE_useAnimation';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useTestId, TestIdProps } from '../hooks/UNSAFE_useTestId';\nimport { useSwipe } from '../hooks/UNSAFE_useSwipe';\n\n// Style imports\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { DrawerPopupVariantOptions } from './themes/DrawerPopupStyles.css';\nimport { colorInterpolations, ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\nimport { DrawerPopupRedwoodTheme } from './themes/redwood/DrawerPopupTheme';\n\n// Types\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\ntype Placement = 'start' | 'end' | 'bottom';\ntype NormalizedPlacement = 'left' | 'right' | 'bottom';\ntype Status = 'unmounted' | 'initial' | 'opening' | 'closing';\ntype VisibilityStatus = 'hidden' | 'visible';\ntype DisplayModeHorizontal = 'overlay' | 'fullOverlay';\ntype OnCloseDetail = {\n  reason: 'outsideClick' | 'escapeKey' | 'swipe';\n};\n\ntype Props = IntrinsicProps &\n  Pick<ColorProps, 'backgroundColor'> & {\n    /**\n     * Specifies whether the Drawer is open.\n     */\n    isOpen: boolean;\n    /**\n     * Specifies at what edge the Drawer opens.\n     * Supported values are:\n     * <p><code>start</code>, <code>end</code>, <code>bottom</code></p>\n     * Default is <code>start</code>.\n     */\n    placement?: Placement;\n    /**\n     * Specifies modality of the Darwer.\n     * Supported values are:\n     * <p><code>modal</code>, <code>modeless</code></p>\n     * Default is <code>modal</code>.\n     */\n    modality?: 'modal' | 'modeless';\n    /**\n     * Specifies callback triggered when a user tries to close a Drawer through UI interaction.\n     * The parent should listen to this event and close the Drawer. If the parent fails to remove\n     * the Popup, then no change will be done in the UI by the component.\n     * Supported detail values are:\n     * <p><code>outsideClick</code>, <code>escapeKey</code></p>, <code>swipe</code>\n     */\n    onClose?: (detail: OnCloseDetail) => void;\n    /**\n     * Specifies callback triggered after the animation ends.\n     */\n    onTransitionEnd?: (value: boolean) => void;\n    /**\n     * Optional ref for an element to focus on when component mounts.\n     */\n    autoFocusRef?: RefObject<HTMLElement>;\n    /**\n     * Specifies guidance for screen readers.\n     */\n    'aria-label'?: string;\n    /**\n     * Specifies ID of an element used for guidance for screen readers.\n     */\n    'aria-labelledby'?: string;\n    /**\n     * Specifies ID of an element (or space separated IDs of multiple elements) that\n     * describes the Drawer.\n     */\n    'aria-describedby'?: string;\n  } & TestIdProps;\n\n// Constants\nconst displayModefullWidthThreshold = 600;\nconst zero = '0px';\nconst duration = 250;\n\nconst getElementHeight = (element: HTMLDivElement): number => {\n  return Math.round(element.offsetHeight);\n};\n\nconst getElementWidth = (element: HTMLDivElement): number => {\n  return Math.round(element.getBoundingClientRect().width);\n};\n\n/**\n * A drawer popup adds a single slide-in side content alongside some primary content to an application window.\n *\n * This drawer always overlays the page and can be placed at the 'start', 'end' or 'bottom' edge.\n */\nexport const DrawerPopup = forwardRef(\n  (\n    {\n      children,\n      isOpen = false,\n      autoFocusRef,\n      placement = 'start',\n      modality = 'modal',\n      onClose,\n      onTransitionEnd,\n      'aria-label': ariaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      testId,\n      ...props\n    }: Props,\n    ref: ForwardedRef<HTMLElement | null>\n  ) => {\n    // Initialize states\n    const [status, setStatus] = useState<Status>(isOpen ? 'initial' : 'unmounted');\n    const [visibility, setVisibility] = useState<VisibilityStatus>('hidden');\n    const [isOutsideClickDisabled, setIsOutsideClickDisabled] = useState<boolean>(!isOpen);\n    const [displayModeHorizontal, setDisplayModeHorizontal] =\n      useState<DisplayModeHorizontal>('overlay');\n\n    const prevStatusRef = useRef<Status>('unmounted');\n\n    const rootRef = useRef<HTMLDivElement>(null);\n    const launcherRef = useRef<HTMLElement | null>(null);\n\n    const mergedRef = useMemo(() => mergeRefs(rootRef, ref), [rootRef, ref]);\n\n    const isBottomPlacement = placement === 'bottom';\n    const shouldReturnFocus = useRef<boolean>(false);\n\n    // Animation config\n    const animationStates = {\n      opening: () => {\n        if (isBottomPlacement) {\n          return {\n            from: {\n              translateY: getTranslateY()\n            },\n            to: {\n              translateY: zero\n            },\n            options: {\n              duration: duration\n            }\n          };\n        } else {\n          return {\n            from: {\n              translateX: getTranslateX()\n            },\n            to: {\n              translateX: zero\n            },\n            options: {\n              duration: duration\n            }\n          };\n        }\n      },\n      closing: () => {\n        if (isBottomPlacement) {\n          return {\n            from: {\n              translateY: zero\n            },\n            to: {\n              translateY: getTranslateY()\n            },\n            options: {\n              duration: duration\n            }\n          };\n        } else {\n          return {\n            from: {\n              translateX: zero\n            },\n            to: {\n              translateX: getTranslateX()\n            },\n            options: {\n              duration: duration\n            }\n          };\n        }\n      }\n    };\n\n    // testId support\n    const testIdProps = useTestId(testId);\n\n    // Normalizing position\n    const { direction } = useUser();\n    const getNormalizedPlacement = (): RtlSide => {\n      return normalizePosition(placement, direction);\n    };\n\n    const getTranslateX = (): string => {\n      return `${getNormalizedPlacement() === 'right' ? '' : '-'}${getElementWidth(\n        rootRef.current as HTMLDivElement\n      )}px`;\n    };\n\n    const getTranslateY = (): string => {\n      return `${getElementHeight(rootRef.current as HTMLDivElement)}px`;\n    };\n\n    const setInitialFocus = () => {\n      // Set focus to the first match:\n      // 1. First element inside the drawer matching [autofocus]\n      const autofocusItems: HTMLElement[] = getAutofocusFocusables(rootRef.current as HTMLElement);\n      if (autofocusItems.length > 0) {\n        focusOn(autofocusItems[0]);\n        return;\n      }\n      // 2. Tabbable element inside the content element\n      // 3. The drawer itself\n      focusWithin(rootRef.current as HTMLElement);\n    };\n\n    const returnFocusToLauncher = (): void => {\n      if (shouldReturnFocus.current) {\n        focusOnElementOrNearestAncestor(launcherRef.current as HTMLElement);\n        shouldReturnFocus.current = false;\n      }\n    };\n\n    // Remove style attribute left on the element by the Animation util\n    const removeAnimationInlineStyles = useCallback(() => {\n      rootRef.current?.style?.removeProperty('transform');\n    }, []);\n\n    // Animation\n    const { nodeRef } = useAnimation<Status, HTMLDivElement>(status, {\n      animationStates,\n      isAnimatedOnMount: true,\n      onAnimationEnd: () => {\n        if (status === 'opening') {\n          removeAnimationInlineStyles();\n          setInitialFocus();\n          onTransitionEnd?.(true);\n        } else if (!isOpen) {\n          shouldReturnFocus.current =\n            rootRef.current?.contains(getActiveElement() as HTMLElement) || false;\n          nodeRef(null);\n          setVisibility('hidden');\n          setStatus('unmounted');\n          onTransitionEnd?.(false);\n        }\n      }\n    });\n\n    useEffect(() => {\n      // 1. Ignore status update on initial render\n      if (status === 'unmounted' && !isOpen && status !== prevStatusRef.current) {\n        returnFocusToLauncher();\n      }\n\n      // 2. Mount visually hidden component\n      // Component gets mounted, but will be visually hidden to avoid flickering\n      // Flickering happens because it gets rendered before animation hook repositions\n      // it in next render cycle\n      else if (status === 'unmounted' && isOpen) {\n        setStatus('initial');\n      }\n\n      // 3. Setup animation\n      // Component has been mounted.\n      // We will kick out animation as node is already present in DOM.\n      // To avoid flickering, we still keep it visually hidden until the next render cycle.\n      else if (status === 'initial' && isOpen) {\n        nodeRef(rootRef.current);\n        setIsOutsideClickDisabled(false);\n        setStatus('opening');\n      }\n\n      // 3. Unhide component. It becomes visible.\n      else if (status === 'opening' && isOpen) {\n        setVisibility('visible');\n      }\n\n      // 4. Closing\n      else if (!isOpen && status !== 'unmounted') {\n        setIsOutsideClickDisabled(true);\n        setStatus('closing');\n      }\n\n      return () => {\n        // remember the previous status\n        prevStatusRef.current = status;\n      };\n    }, [isOpen, status, nodeRef]);\n\n    // Destroy case handler\n    useEffect(() => {\n      return () => {\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        if (rootRef.current?.contains(getActiveElement() as HTMLElement) || false) {\n          // In destroy case ModalManager is blocking returning of the focus.\n          // We need to reschedule it to workaround that\n          setTimeout(() => {\n            focusOnElementOrNearestAncestor(launcherRef.current as HTMLElement);\n          }, 0);\n        }\n      };\n    }, []);\n\n    // Launcher handler\n    useEffect(() => {\n      if (status === 'opening') {\n        // Remember launcher\n        launcherRef.current = getActiveElement() as HTMLElement;\n\n        // Register F6 key handler. It is modeless only feature.\n        if (modality === 'modeless') {\n          launcherRef.current?.addEventListener('keydown', launcherKeyDownCallback);\n        }\n      }\n      if (status === 'closing' && modality === 'modeless') {\n        return () => {\n          // Deregister F6 key handler\n          launcherRef.current?.removeEventListener('keydown', launcherKeyDownCallback);\n        };\n      }\n      return;\n    }, [modality, status]);\n\n    const launcherKeyDownCallback = (event: KeyboardEvent): void => {\n      // Moves focus from launcher (must have focus) back to the Drawer\n      if (launcherRef.current === getActiveElement() && event.code === 'F6') {\n        // Prevent default F6 handlers.\n        // F6 is a standard Chrome address bar shortcut on Windows.\n        event.preventDefault();\n        event.stopPropagation();\n\n        // Focus on first tabbable in a container or container itself if there is none\n        focusWithin(rootRef.current as HTMLElement);\n      }\n    };\n\n    const handleKeyDown = useCallback(\n      (event: KeyboardEvent) => {\n        const launcherEl = launcherRef.current;\n        switch (event.code) {\n          case 'Escape': {\n            onClose?.({ reason: 'escapeKey' });\n            break;\n          }\n          case 'F6':\n            if (modality === 'modeless') {\n              // Prevent default F6 handlers.\n              // F6 is a standard Chrome address bar shortcut on Windows.\n              event.preventDefault();\n              event.stopPropagation();\n              // Focus launcher\n              if (launcherEl) {\n                focusOn(launcherEl);\n              }\n              break;\n            }\n        }\n      },\n      [onClose, modality]\n    );\n\n    // OutsideClick handler\n    const handleOutsideClick = useCallback(() => {\n      // Trigger onClose event with outside click detail\n      onClose?.({ reason: 'outsideClick' });\n    }, [onClose]);\n\n    const insideRefs: RefObject<HTMLElement>[] = [rootRef];\n    // launcher should be considered an \"inside\" element\n    if (launcherRef.current && launcherRef.current !== document.body) {\n      insideRefs.push(launcherRef);\n    }\n\n    useOutsideClick({\n      isDisabled: isOutsideClickDisabled,\n      ref: insideRefs,\n      handler: handleOutsideClick\n    });\n\n    // Drawer placement\n    const getDrawerPlacement = (): NormalizedPlacement => {\n      if (isBottomPlacement) {\n        return placement;\n      } else {\n        if (direction === 'rtl') {\n          return placement === 'start' ? 'right' : 'left';\n        } else {\n          return placement === 'start' ? 'left' : 'right';\n        }\n      }\n    };\n\n    const clientHints = getClientHints();\n\n    const getViewportWidth = useCallback((): number => {\n      if (clientHints.platform === 'ios') {\n        // On ios window.innerWidth is not recommended way of measuring the viewport\n        return document.documentElement.clientWidth;\n      }\n      return window.innerWidth;\n    }, [clientHints.platform]);\n\n    // Window resize handler\n    // Handles display mode: Overlay <> Full overlay (full width side drawers)\n    const handleResize = useCallback(() => {\n      const viewportWidth = getViewportWidth();\n      if (displayModeHorizontal === 'overlay' && viewportWidth < displayModefullWidthThreshold) {\n        setDisplayModeHorizontal('fullOverlay');\n      }\n      if (\n        displayModeHorizontal === 'fullOverlay' &&\n        viewportWidth > displayModefullWidthThreshold\n      ) {\n        setDisplayModeHorizontal('overlay');\n      }\n    }, [getViewportWidth, displayModeHorizontal]);\n\n    useEffect(() => {\n      const root = rootRef.current;\n      if (root && status === 'opening') {\n        const resizeObserver = new ResizeObserver(() => {\n          handleResize();\n        });\n        resizeObserver.observe(document.body);\n        return () => {\n          resizeObserver.unobserve(document.body);\n        };\n      }\n      return undefined;\n    }, [status, handleResize]);\n\n    const dispatchSwipeOnClose = useCallback(() => {\n      onClose?.({ reason: 'swipe' });\n    }, [onClose]);\n\n    // OutsideClick handler\n    const swipeHandler = useCallback(\n      (event: any): void => {\n        const swipeDir = event.direction;\n        // LTR\n        if (direction === 'ltr') {\n          if (\n            (placement === 'start' && swipeDir === 'left') ||\n            (placement === 'end' && swipeDir === 'right')\n          ) {\n            dispatchSwipeOnClose();\n          }\n        }\n        // RTL\n        if (direction === 'rtl') {\n          if (\n            (placement === 'start' && swipeDir === 'right') ||\n            (placement === 'end' && swipeDir === 'left')\n          ) {\n            dispatchSwipeOnClose();\n          }\n        }\n        // Bottom\n        if (placement === 'bottom' && swipeDir === 'down') {\n          dispatchSwipeOnClose();\n        }\n      },\n      [direction, placement, dispatchSwipeOnClose]\n    );\n\n    const swipeOptions = {\n      threshold: 50,\n      maximumTime: 750,\n      tolerance: 40\n    };\n    const { swipeProps } = useSwipe(swipeHandler, swipeOptions);\n\n    // Styles\n    const { classes } = useComponentTheme<DrawerPopupVariantOptions>(DrawerPopupRedwoodTheme, {\n      placement: getDrawerPlacement(),\n      visibility,\n      displayModeHorizontal:\n        ['start', 'end'].indexOf(placement) > -1 ? displayModeHorizontal : undefined\n    });\n\n    const interpolations = [...Object.values(colorInterpolations)];\n    const styleInterpolations = mergeInterpolations<ColorProps>(interpolations);\n    const { ...styles } = styleInterpolations(props);\n\n    const renderDrawer = () => {\n      return (\n        <FocusTrap autoFocusRef={autoFocusRef} restoreFocusRef={false}>\n          <div\n            ref={mergedRef}\n            className={classes}\n            style={styles}\n            tabIndex={-1}\n            role=\"dialog\"\n            onKeyDown={handleKeyDown}\n            aria-label={ariaLabel}\n            aria-labelledby={ariaLabelledBy}\n            aria-describedby={ariaDescribedBy}\n            {...swipeProps}\n            {...testIdProps}>\n            {children}\n          </div>\n        </FocusTrap>\n      );\n    };\n\n    const isMounted = status !== 'unmounted';\n    if (isMounted) {\n      // Modal vs. modelss upper wrapper\n      if (modality === 'modal') {\n        return <Modal isOpen={isMounted}>{renderDrawer()}</Modal>;\n      } else {\n        return <Layer>{renderDrawer()}</Layer>;\n      }\n    }\n\n    return null;\n  }\n);\n"],"names":["zero","duration","DrawerPopup","forwardRef","children","isOpen","autoFocusRef","placement","modality","onClose","onTransitionEnd","ariaLabel","ariaLabelledBy","ariaDescribedBy","testId","props","ref","status","setStatus","useState","visibility","setVisibility","isOutsideClickDisabled","setIsOutsideClickDisabled","displayModeHorizontal","setDisplayModeHorizontal","prevStatusRef","useRef","rootRef","launcherRef","mergedRef","useMemo","mergeRefs","isBottomPlacement","shouldReturnFocus","animationStates","opening","from","translateY","getTranslateY","to","options","translateX","getTranslateX","closing","testIdProps","useTestId","direction","useUser","normalizePosition","element","current","Math","round","getBoundingClientRect","width","offsetHeight","removeAnimationInlineStyles","useCallback","style","removeProperty","nodeRef","useAnimation","isAnimatedOnMount","onAnimationEnd","autofocusItems","getAutofocusFocusables","length","focusOn","focusWithin","setInitialFocus","contains","getActiveElement","useEffect","focusOnElementOrNearestAncestor","setTimeout","addEventListener","launcherKeyDownCallback","removeEventListener","event","code","preventDefault","stopPropagation","handleKeyDown","launcherEl","reason","handleOutsideClick","insideRefs","document","body","push","useOutsideClick","isDisabled","handler","clientHints","getClientHints","getViewportWidth","platform","documentElement","clientWidth","window","innerWidth","handleResize","viewportWidth","resizeObserver","ResizeObserver","observe","unobserve","dispatchSwipeOnClose","swipeHandler","swipeDir","swipeProps","useSwipe","threshold","maximumTime","tolerance","classes","useComponentTheme","DrawerPopupRedwoodTheme","indexOf","undefined","interpolations","Object","values","colorInterpolations","styleInterpolations","mergeInterpolations","styles","renderDrawer","_jsx","FocusTrap","restoreFocusRef","className","tabIndex","role","onKeyDown","isMounted","jsx","Modal","Layer"],"mappings":"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"}