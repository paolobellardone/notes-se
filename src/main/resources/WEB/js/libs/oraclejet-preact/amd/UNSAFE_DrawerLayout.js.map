{"version":3,"file":"UNSAFE_DrawerLayout.js","sources":["../../src/UNSAFE_DrawerLayout/DrawerLayout.tsx"],"sourcesContent":["import { JSX, ComponentChildren, type RefObject } from 'preact';\nimport { useState, useRef, useEffect, useCallback } from 'preact/hooks';\nimport { normalizePosition } from '../utils/PRIVATE_floatingUtils';\nimport { Floating, ShiftOptions, RtlSide } from '../UNSAFE_Floating';\nimport { Layer } from '../UNSAFE_Layer';\nimport {\n  getAutofocusFocusables,\n  focusOn,\n  focusWithin,\n  focusOnElementOrNearestAncestor\n} from '../utils/PRIVATE_tabbableUtils';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { allTabbableElements, getActiveElement } from '../utils/PRIVATE_tabbableUtils';\n\n// Hooks\nimport { useAnimation } from '../hooks/UNSAFE_useAnimation';\nimport { DURATION_LARGE } from '../utils/PRIVATE_animationUtils';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useTestId, TestIdProps } from '../hooks/UNSAFE_useTestId';\nimport { useBreakpointValues } from '../hooks/UNSAFE_useBreakpointValues';\nimport { useResizeObserver } from '../hooks/UNSAFE_useResizeObserver';\n\n// Style imports\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { DrawerLayoutStyles } from './themes/DrawerLayoutStyles.css';\nimport { DrawerLayoutRedwoodTheme } from './themes/redwood/DrawerLayoutTheme';\n\n// Types\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\ntype Placement = 'start' | 'end' | 'bottom';\ntype Status = 'unmounted' | 'initial' | 'opening' | 'open' | 'closing';\n\ntype OnCloseDetail = {\n  placement: Placement;\n  reason: 'escapeKey';\n};\ntype OnTransitionEndDetail = {\n  placement: Placement;\n  value: boolean;\n};\ntype DisplayMode = 'overlay' | 'reflow';\ntype ResolvedDisplayMode = 'full-overlay' | 'overlay' | 'reflow';\ntype Visibility = 'hidden' | 'visible';\n\ntype AnimationEffect =\n  | 'expandVertically'\n  | 'collapseVertically'\n  | 'expandHorizontally'\n  | 'collapseHorizontally'\n  | 'slideUp'\n  | 'slideDown'\n  | 'slideOpenLeft'\n  | 'slideCloseLeft'\n  | 'slideOpenRight'\n  | 'slideCloseRight'\n  | '';\n\ntype Props = IntrinsicProps & {\n  /**\n   * The content node to be shown within the Start Drawer\n   */\n  startDrawer?: ComponentChildren;\n  /**\n   * The content node to be shown within the End Drawer\n   */\n  endDrawer?: ComponentChildren;\n  /**\n   * The content node to be shown within the Bottom Drawer\n   */\n  bottomDrawer?: ComponentChildren;\n  /**\n   * Specifies whether Start drawer is open.\n   */\n  isStartOpen?: boolean;\n  /**\n   * Specifies the display mode of the Start drawer.\n   *\n   * Supported values are:\n   * <p><code>overlay</code>, <code>reflow</code></p>\n   * Default is <code>undefined</code>.\n   */\n  startDisplay?: DisplayMode;\n  /**\n   * Specifies whether End drawer is open.\n   */\n  isEndOpen?: boolean;\n  /**\n   * Specifies the display mode of the End drawer.\n   *\n   * Supported values are:\n   * <p><code>overlay</code>, <code>reflow</code></p>\n   * Default is <code>undefined</code>.\n   */\n  endDisplay?: DisplayMode;\n  /**\n   * Specifies whether Bottom drawer is open.\n   */\n  isBottomOpen?: boolean;\n  /**\n   * Specifies the display mode of the Bottom drawer.\n   *\n   * Supported values are:\n   * <p><code>overlay</code>, <code>reflow</code></p>\n   * Default is <code>undefined</code>.\n   */\n  bottomDisplay?: DisplayMode;\n  /**\n   * Specifies callback triggered when a user tries to close a Drawer through UI interaction.\n   * The parent should listen to this event and close the Drawer. If the parent fails to remove\n   * the Popup, then no change will be done in the UI by the component.\n   *\n   * Supported detail values are:\n   * <p><code>placement: start | end | bottom</code></p>\n   * <p><code>reason: escapeKey</code></p>\n   */\n  onClose?: (detail: OnCloseDetail) => void;\n  /**\n   * Specifies callback triggered after the animation ends.\n   *\n   * Supported detail values are:\n   * <p><code>placement: start | end | bottom</code></p>\n   * <p><code>value: boolean</code></p>\n   */\n  onTransitionEnd?: (detail: OnTransitionEndDetail) => void;\n} & TestIdProps;\n\n/**\n * A drawer layout adds expandable side contents (drawers) alongside some primary content.\n *\n * These drawers automatically swap 'reflow' and 'overlay' display mode based on width of the page and can be placed at the 'start', 'end' or 'bottom' edge.\n */\nexport const DrawerLayout = ({\n  children,\n  startDrawer,\n  endDrawer,\n  bottomDrawer,\n  isStartOpen = false,\n  isEndOpen = false,\n  isBottomOpen = false,\n  startDisplay,\n  endDisplay,\n  bottomDisplay,\n  onClose,\n  onTransitionEnd,\n  testId // ...props\n}: Props) => {\n  // Constants\n  const zeroPx = '0px';\n  const verticalBreakpoint = 600;\n  const stringStart = 'start';\n  const stringEnd = 'end';\n  const stringBottom = 'bottom';\n  const stringInitial = 'initial';\n  const stringOpening = 'opening';\n  const stringOpen = 'open';\n  const stringClosing = 'closing';\n  const stringUnmounted = 'unmounted';\n  const stringFullOverlay = 'full-overlay';\n  const stringOverlay = 'overlay';\n  const stringReflow = 'reflow';\n  const stringHidden = 'hidden';\n  const stringVisible = 'visible';\n\n  // Initialize states\n  const [startDrawerStatus, setStartDrawerStatus] = useState<Status>(\n    isStartOpen ? stringInitial : stringUnmounted\n  );\n  const [endDrawerStatus, setEndDrawerStatus] = useState<Status>(\n    isEndOpen ? stringInitial : stringUnmounted\n  );\n  const [bottomDrawerStatus, setBottomDrawerStatus] = useState<Status>(\n    isBottomOpen ? stringInitial : stringUnmounted\n  );\n  const [startVisibility, setStartVisibility] = useState<Visibility>(stringHidden);\n  const [endVisibility, setEndVisibility] = useState<Visibility>(stringHidden);\n  const [bottomVisibility, setBottomVisibility] = useState<Visibility>(stringHidden);\n\n  const [startOffset, setStartOffset] = useState<number>();\n  const [endOffset, setEndOffset] = useState<number>();\n  const [bottomOffset, setBottomOffset] = useState<number>();\n\n  // Breakpoints:\n  // sm: 0-600px (full-overlay)\n  // md: 600-1024px (overlay)\n  // lg: >1024px (reflow)\n  const displayMode: ResolvedDisplayMode = useBreakpointValues({\n    sm: stringFullOverlay,\n    md: stringOverlay,\n    lg: stringReflow\n  });\n  const [viewportDisplayModeHorizontal, setViewportDisplayModeHorizontal] =\n    useState<ResolvedDisplayMode>(displayMode);\n  const [viewportDisplayModeVertical, setViewportDisplayModeVertical] =\n    useState<ResolvedDisplayMode>(displayMode);\n\n  // Refs\n  const rootRef = useRef<HTMLDivElement>(null);\n  const centerRef = useRef<HTMLDivElement>(null);\n  const startDrawerRef = useRef<HTMLDivElement>(null);\n  const endDrawerRef = useRef<HTMLDivElement>(null);\n  const bottomDrawerRef = useRef<HTMLDivElement>(null);\n  const placementOfLastlyFocusedRef = useRef<Placement | null>(null);\n  const indexOfLastlyFocusedRef = useRef<number | null>(null);\n\n  const startLauncherRef = useRef<HTMLElement | null>(null);\n  const endLauncherRef = useRef<HTMLElement | null>(null);\n  const bottomLauncherRef = useRef<HTMLElement | null>(null);\n  const elementWithFocusBeforeDrawerClosesRef = useRef<HTMLElement | null>(null);\n\n  const [startResolvedDisplayMode, setStartResolvedDisplayMode] =\n    useState<ResolvedDisplayMode | null>(null);\n  const [endResolvedDisplayMode, setEndResolvedDisplayMode] = useState<ResolvedDisplayMode | null>(\n    null\n  );\n  const [bottomResolvedDisplayMode, setBottomResolvedDisplayMode] =\n    useState<ResolvedDisplayMode | null>(null);\n\n  const getDrawerEl = useCallback((placement: Placement) => {\n    return getDrawerRef(placement).current;\n  }, []);\n\n  const getPlacementOfDrawerWithFocus = useCallback(() => {\n    const startDrawerEl = getDrawerEl(stringStart);\n    const endDrawerEl = getDrawerEl(stringEnd);\n    const bottomDrawerEl = getDrawerEl(stringBottom);\n    const activeElement = getActiveElement();\n    if (startDrawerEl && startDrawerEl.contains(activeElement)) {\n      return stringStart;\n    } else if (endDrawerEl && endDrawerEl.contains(activeElement)) {\n      return stringEnd;\n    } else if (bottomDrawerEl && bottomDrawerEl.contains(activeElement)) {\n      return stringBottom;\n    } else return null;\n  }, [getDrawerEl]);\n\n  const triggerFocusTransferStrategy = useCallback((): void => {\n    // Focus strategy - find focused element.\n    // Save what drawer and what element had focus before it was eventually conditionally re-rendered\n\n    // In 'auto' display mode we swap 'reflow' and 'overlay' automatically\n    // When this change happens, conditional rendering mechanism destroys\n    // reflow drawer DOM and creates overlay drawer DOM. This, of course,\n    // applies vice versa. In such cases focus gets lost.\n    // In DOM destroy cases focus is usually moved to <body>.\n\n    // In standard open cases we trigger focus strategy from animationEnd callback.\n    // However, in 'reflow' <> 'overlay' cases animation hook is not used/wanted at all.\n    // In addition, we should keep focus on the lastly/customly focused elemenet,\n    // e.g. the lastly focused element of a form\n\n    // 1. useBreakpoint hook is triggered even there's no drawer present.\n    // Handle focus only if there's at least one drawer open\n    if (isStartOpen || isEndOpen || isBottomOpen) {\n      // 2. Focus might not be in drawers.\n      // In modeless cases user can bring the focus out of open drawers by clicking outside them.\n\n      // Check whether focused element lives in a drawer (one of drawers).\n      // Do not handle focus at all if it is not within a drawer.\n      // Note: returns null if focus is not within a drawer\n      const activeElementPlacement = getPlacementOfDrawerWithFocus();\n      if (activeElementPlacement) {\n        // Save in which drawer focus lives (save its placement).\n        placementOfLastlyFocusedRef.current = activeElementPlacement;\n\n        // 3. Focus was detected in a particular drawer\n        // Save index of this element\n        const allTabbables = allTabbableElements(\n          getDrawerRef(placementOfLastlyFocusedRef.current).current as HTMLDivElement,\n          true\n        );\n        // Save index of lastly focused element\n        indexOfLastlyFocusedRef.current = allTabbables.indexOf(getActiveElement() as HTMLElement);\n      }\n    }\n  }, [getPlacementOfDrawerWithFocus, isStartOpen, isBottomOpen, isEndOpen]);\n\n  const isDrawerOpen = useCallback(\n    (placement: Placement): boolean => {\n      let isOpen = false;\n      switch (placement) {\n        case stringStart:\n          isOpen = isStartOpen;\n          break;\n        case stringEnd:\n          isOpen = isEndOpen;\n          break;\n        case stringBottom:\n          isOpen = isBottomOpen;\n          break;\n      }\n      return isOpen;\n    },\n    [isStartOpen, isEndOpen, isBottomOpen]\n  );\n\n  useEffect((): void => {\n    // Focus strategy - apply focus back\n    // Return focus to a drawer if applicable\n    // 1a. useBreakpoint hook, which monitors viewport resolution, is triggered even drawer(s) are not open.\n    // This hook causes changes to 'viewportDisplayModeHorizontal', a dependency of this effect.\n    // 1b. This effect can be also triggered by a change to\n    // start-display/end-display/bottom-display properties of the DrawerLayout.\n    // Make sure that drawer, in which we previously found focus, is still open.\n    const placementOflastlyFocusedDrawer = placementOfLastlyFocusedRef.current;\n    if (placementOflastlyFocusedDrawer) {\n      const drawerRefReceivingFocus: RefObject<any> = getDrawerRef(placementOflastlyFocusedDrawer);\n\n      if (drawerRefReceivingFocus.current && isDrawerOpen(placementOflastlyFocusedDrawer)) {\n        // 2. Find all tabbables in newly rendered focus receiving focus\n        const allTabbables = allTabbableElements(drawerRefReceivingFocus.current, true);\n\n        // 3. Try to focus the same element that had focus in previous display mode\n        // In theory drawer's content could be modified.\n        // Check whether there are more tababble elements than the index value we saved\n        if (\n          indexOfLastlyFocusedRef.current != null &&\n          allTabbables.length > indexOfLastlyFocusedRef.current\n        ) {\n          // Focus element using the saved index\n          focusOn(allTabbables[indexOfLastlyFocusedRef.current]);\n        } else {\n          // Focus first tabbable\n          focusWithin(drawerRefReceivingFocus.current);\n        }\n\n        // Reset saved values to avoid possible side effects\n        placementOfLastlyFocusedRef.current = null;\n        indexOfLastlyFocusedRef.current = null;\n      }\n    }\n  }, [startResolvedDisplayMode, endResolvedDisplayMode, bottomResolvedDisplayMode, isDrawerOpen]);\n\n  useEffect(() => {\n    // Size breakpoint crossed\n    triggerFocusTransferStrategy();\n    // Reschedules the effect to occur after the ResizeObserver’s loop has completed.\n    setTimeout((): void => {\n      setViewportDisplayModeHorizontal(displayMode);\n    }, 0);\n  }, [displayMode, triggerFocusTransferStrategy]);\n\n  const getElementHeight = (element: HTMLDivElement): number => {\n    return element ? Math.round(element.offsetHeight) : 0;\n  };\n\n  const getElementHeightPx = useCallback((element: HTMLDivElement): string => {\n    return `${getElementHeight(element)}px`;\n  }, []);\n\n  const getElementWidth = useCallback((element: HTMLDivElement): number => {\n    return element ? Math.round(element.getBoundingClientRect().width) : 0;\n  }, []);\n\n  const getElementWidthPx = useCallback(\n    (element: HTMLDivElement): string => {\n      return `${getElementWidth(element)}px`;\n    },\n    [getElementWidth]\n  );\n\n  // Normalizing position\n  const { direction } = useUser();\n  const isLtr = direction === 'ltr';\n\n  const getNormalizedPlacement = useCallback(\n    (placement: Placement): RtlSide => {\n      return normalizePosition(placement, direction);\n    },\n    [direction]\n  );\n\n  const isSidePlacement = (placement: Placement): boolean => {\n    return [stringStart, stringEnd].indexOf(placement) > -1;\n  };\n\n  const isBottomPlacement = (placement: Placement): boolean => {\n    return placement === stringBottom;\n  };\n\n  const isAnimationPending = (status: Status): boolean => {\n    return [stringOpening, stringClosing].indexOf(status) > -1;\n  };\n\n  const isDrawerAnimationPending = (placement: Placement): boolean => {\n    switch (placement) {\n      case stringStart:\n        return isAnimationPending(startDrawerStatus);\n      case stringEnd:\n        return isAnimationPending(endDrawerStatus);\n      case stringBottom:\n        return isAnimationPending(bottomDrawerStatus);\n    }\n  };\n\n  const getDrawerVisibility = (placement: Placement): Visibility => {\n    switch (placement) {\n      case stringStart:\n        return startVisibility;\n      case stringEnd:\n        return endVisibility;\n      case stringBottom:\n        return bottomVisibility;\n    }\n  };\n\n  const setDrawerVisibility = (placement: Placement, visibility: Visibility): void => {\n    switch (placement) {\n      case stringStart:\n        return setStartVisibility(visibility);\n      case stringEnd:\n        return setEndVisibility(visibility);\n      case stringBottom:\n        return setBottomVisibility(visibility);\n    }\n  };\n\n  const getDrawerRef = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startDrawerRef;\n      case stringEnd:\n        return endDrawerRef;\n      case stringBottom:\n        return bottomDrawerRef;\n    }\n  };\n\n  const getAnimatedNodeRef = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startAnimatedNodeRef;\n      case stringEnd:\n        return endAnimatedNodeRef;\n      case stringBottom:\n        return bottomAnimatedNodeRef;\n    }\n  };\n\n  const getDrawerStatus = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startDrawerStatus;\n      case stringEnd:\n        return endDrawerStatus;\n      case stringBottom:\n        return bottomDrawerStatus;\n    }\n  };\n\n  const setDrawerStatus = (placement: Placement, status: Status): void => {\n    switch (placement) {\n      case stringStart:\n        setStartDrawerStatus(status);\n        break;\n      case stringEnd:\n        setEndDrawerStatus(status);\n        break;\n      case stringBottom:\n        setBottomDrawerStatus(status);\n        break;\n    }\n  };\n\n  const resetAnimatedNodeRef = (placement: Placement): void => {\n    switch (placement) {\n      case stringStart:\n        startAnimatedNodeRef(null);\n        break;\n      case stringEnd:\n        endAnimatedNodeRef(null);\n        break;\n      case stringBottom:\n        bottomAnimatedNodeRef(null);\n        break;\n    }\n  };\n\n  const getDrawerDisplayProp = useCallback(\n    (placement: Placement) => {\n      switch (placement) {\n        case stringStart:\n          return startDisplay;\n        case stringEnd:\n          return endDisplay;\n        case stringBottom:\n          return bottomDisplay;\n      }\n    },\n    [startDisplay, endDisplay, bottomDisplay]\n  );\n\n  const getDrawerResolvedDisplayMode = useCallback(\n    (placement: Placement) => {\n      const displayProp = getDrawerDisplayProp(placement);\n      if (displayProp) {\n        return displayProp;\n      } else {\n        if (isSidePlacement(placement)) {\n          return viewportDisplayModeHorizontal;\n        }\n        return viewportDisplayModeVertical;\n      }\n    },\n    [getDrawerDisplayProp, viewportDisplayModeHorizontal, viewportDisplayModeVertical]\n  );\n\n  // Animation effects config\n  const getAnimationStates = (ref: RefObject<HTMLElement>) => {\n    return {\n      expandVertically: {\n        from: {\n          maxHeight: zeroPx\n        },\n        to: {\n          maxHeight: '100%'\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      collapseVertically: {\n        from: {\n          maxHeight: '100%'\n        },\n        to: {\n          maxHeight: zeroPx\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      expandHorizontally: () => {\n        return {\n          from: {\n            maxWidth: zeroPx\n          },\n          to: {\n            // We need a function here as the width is dynamic\n            // and percentage can't be used in reflow mode\n            maxWidth: getElementWidthPx(ref.current as HTMLDivElement)\n          },\n          options: {\n            duration: DURATION_LARGE\n          }\n        };\n      },\n      collapseHorizontally: () => {\n        return {\n          from: {\n            // We need a function here as the width is dynamic\n            // and percentage can't be used in reflow mode\n            maxWidth: getElementWidthPx(ref.current as HTMLDivElement)\n          },\n          to: {\n            maxWidth: zeroPx\n          },\n          options: {\n            duration: DURATION_LARGE\n          }\n        };\n      },\n      slideUp: {\n        from: {\n          // We need a function here as the height is dynamic\n          // and percentage can't be used in reflow mode\n          translateY: '100%'\n        },\n        to: {\n          translateY: zeroPx\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      slideDown: {\n        from: {\n          translateY: zeroPx\n        },\n        to: {\n          translateY: '100%'\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      slideOpenLeft: {\n        from: {\n          translateX: '-100%'\n        },\n        to: {\n          translateX: zeroPx\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      slideCloseLeft: {\n        from: {\n          translateX: '0'\n        },\n        to: {\n          translateX: '-100%'\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      slideOpenRight: {\n        from: {\n          translateX: '100%'\n        },\n        to: {\n          translateX: zeroPx\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      slideCloseRight: {\n        from: {\n          translateX: '0'\n        },\n        to: {\n          translateX: '100%'\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      }\n    };\n  };\n\n  const removeAnimationInlineStyles = (placement: Placement): void => {\n    // Remove style attribute left on the element by the Animation util\n    const drawerRef: RefObject<any> = getDrawerRef(placement);\n    drawerRef.current.removeAttribute('style');\n  };\n\n  const setInitialFocus = (placement: Placement): void => {\n    // Set focus to the first match:\n    const drawerRef: RefObject<any> = getDrawerRef(placement);\n\n    // 1. First element inside the drawer matching [autofocus]\n    const autofocusItems: HTMLElement[] = getAutofocusFocusables(drawerRef.current);\n    if (autofocusItems.length > 0) {\n      focusOn(autofocusItems[0]);\n      return;\n    }\n    // 2. Tabbable element inside the content element\n    // 3. The drawer itself\n    focusWithin(drawerRef.current);\n  };\n\n  const getLauncherRef = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startLauncherRef;\n      case stringEnd:\n        return endLauncherRef;\n      case stringBottom:\n        return bottomLauncherRef;\n    }\n  };\n\n  const returnFocusToLauncher = (placement: Placement): void => {\n    // Return the focus to the drawer's launcher only if the focus\n    // is currently living within a drawer.\n    // As we do not apply focus-trap in modeless mode, user is able to\n    // get the focus out of the drawer. In this case we do not want to handle it.\n    if (getDrawerRef(placement).current?.contains(elementWithFocusBeforeDrawerClosesRef.current)) {\n      focusOnElementOrNearestAncestor(getLauncherRef(placement).current as HTMLElement);\n    }\n  };\n\n  // Animation effect\n  const getAnimationEffect = (placement: Placement) => {\n    const bottomPlacement = isBottomPlacement(placement);\n    const status = getDrawerStatus(placement);\n    if (getDrawerResolvedDisplayMode(placement) === stringReflow) {\n      // Reflow display mode\n      // Effect: Expand/Collapse\n      if (bottomPlacement) {\n        // useAnimation hook ignores to apply effect if it matches the previous one.\n        // if (currentAnimationState.current === animationState) return;\n        // That's why we need to pair particular with particualar status and\n        // send empty stirng in all other cases\n        if (status === 'opening') {\n          return 'expandVertically';\n        }\n        if (status === 'closing') {\n          return 'collapseVertically';\n        }\n        return '';\n      } else {\n        if (status === 'opening') {\n          return 'expandHorizontally';\n        }\n        if (status === 'closing') {\n          return 'collapseHorizontally';\n        }\n        return '';\n      }\n    } else {\n      // Overlay display mode\n      // Effect: SlideIn/SlideOut\n      if (bottomPlacement) {\n        if (status === 'opening') {\n          return 'slideUp';\n        }\n        if (status === 'closing') {\n          return 'slideDown';\n        }\n        return '';\n      } else {\n        if (status === 'opening') {\n          return getNormalizedPlacement(placement) === 'left' ? 'slideOpenLeft' : 'slideOpenRight';\n        }\n        if (status === 'closing') {\n          return getNormalizedPlacement(placement) === 'left'\n            ? 'slideCloseLeft'\n            : 'slideCloseRight';\n        }\n        return '';\n      }\n    }\n  };\n\n  // Custom hook to be shared for each side\n  // It can't be a function as a hook can only be called within a custom hook\n  function useNodeRef(placement: Placement, ref: RefObject<HTMLElement>) {\n    const isOpen: boolean = isDrawerOpen(placement);\n    const status = getDrawerStatus(placement);\n    return useAnimation<AnimationEffect, HTMLDivElement>(getAnimationEffect(placement), {\n      animationStates: getAnimationStates(ref),\n      isAnimatedOnMount: true,\n      onAnimationEnd: () => {\n        if (status === stringOpening) {\n          if (isOverlay(placement)) {\n            setInitialFocus(placement);\n          }\n          // Remove animation's inline style\n          removeAnimationInlineStyles(placement);\n\n          // In case drawer display mode changed at runtime (reflow <> overlay)\n          // we need to reset animation node ref otherwise animation state is not refelected.\n          // Case:\n          // <oj-c-drawer-layout> opens on wide screen by default in reflow mode (flex layout).\n          // useAnimation effect was 'expand'\n          // Viewport is shrinked under 1024px, display mode changes to overlay.\n          // This means DOM is reparented.\n          // For overlay mode, closing animation effect should be 'slideout'\n          // If animation nodeRef is not reset, closing effect is neither 'collapse' nor 'slideout'.\n          resetAnimatedNodeRef(placement);\n\n          setDrawerStatus(placement, stringOpen);\n          onTransitionEnd?.({\n            placement: placement,\n            value: true\n          });\n        } else if (!isOpen) {\n          if (isOverlay(placement)) {\n            returnFocusToLauncher(placement);\n          }\n          resetAnimatedNodeRef(placement);\n          setDrawerVisibility(placement, stringHidden);\n          setDrawerStatus(placement, stringUnmounted);\n          onTransitionEnd?.({\n            placement: placement,\n            value: false\n          });\n        }\n      }\n    }).nodeRef;\n  }\n\n  // Drawer refs\n  const startAnimatedNodeRef = useNodeRef(stringStart, startDrawerRef);\n  const endAnimatedNodeRef = useNodeRef(stringEnd, endDrawerRef);\n  const bottomAnimatedNodeRef = useNodeRef(stringBottom, bottomDrawerRef);\n\n  //testId support\n  const testIdProps = useTestId(testId);\n\n  const setLauncherRef = (placement: Placement) => {\n    const activeElement = getActiveElement() as HTMLElement;\n    switch (placement) {\n      case stringStart:\n        startLauncherRef.current = activeElement;\n        break;\n      case stringEnd:\n        endLauncherRef.current = activeElement;\n        break;\n      case stringBottom:\n        bottomLauncherRef.current = activeElement;\n        break;\n    }\n  };\n\n  // Custom hook to be shared for each side\n  // It can't be a function as a hook can only be called within a custom hook\n  function useDrawerStatus(placement: Placement): void {\n    const isOpen = isDrawerOpen(placement);\n    const drawerStatus = getDrawerStatus(placement);\n    useEffect(() => {\n      // Ignore initial render\n      // 1. Ignore status update on initial render\n      if (drawerStatus === stringUnmounted && !isOpen) {\n        return;\n      }\n\n      // 2. Unmounted\n      // Mount visually hidden component.\n      // Component gets mounted, but will be visually hidden to avoid flickering.\n      // Flickering happens because it gets rendered before animation hook repositions\n      // it in next render cycle\n      if (drawerStatus === stringUnmounted && isOpen) {\n        setDrawerStatus(placement, stringInitial);\n        return;\n      }\n\n      // 3. Initial\n      // Setup animation\n      // Component has been mounted.\n      // We will kick out animation as node is already present in DOM.\n      // To avoid flickering, we still keep it visually hidden until the next render cycle.\n      if (drawerStatus === stringInitial && isOpen) {\n        const drawerRef = getDrawerRef(placement);\n        const animatedNodeRef = getAnimatedNodeRef(placement);\n        animatedNodeRef(drawerRef.current);\n        setDrawerStatus(placement, stringOpening);\n        return;\n      }\n\n      // 4. Opening\n      // Unhide component. It becomes visible.\n      if (drawerStatus === stringOpening && isOpen) {\n        setDrawerVisibility(placement, stringVisible);\n        // Remember launcher\n        setLauncherRef(placement);\n        return;\n      }\n\n      // 5. Open\n      // Status 'open' is set in 'onAnimationEnd' handler\n\n      // 6. Closing\n      if (!isOpen) {\n        // As animatedNodeRef was reset in onAnimationEnd we need to set it again\n        // see useAnimation transition end for details\n        const drawerRef = getDrawerRef(placement);\n        const animatedNodeRef = getAnimatedNodeRef(placement);\n        animatedNodeRef(drawerRef.current);\n\n        elementWithFocusBeforeDrawerClosesRef.current = getActiveElement() as HTMLElement;\n        setDrawerStatus(placement, stringClosing);\n      }\n    }, [isOpen, drawerStatus, placement]);\n  }\n\n  // Drawers' status handler±\n  useDrawerStatus(stringStart);\n  useDrawerStatus(stringEnd);\n  useDrawerStatus(stringBottom);\n\n  // Keydown handlers\n  const handleKeyDownStart = (event: Event): void => {\n    handleKeyDown(stringStart, event);\n  };\n  const handleKeyDownEnd = (event: Event): void => {\n    handleKeyDown(stringEnd, event);\n  };\n  const handleKeyDownBottom = (event: Event): void => {\n    handleKeyDown(stringBottom, event);\n  };\n\n  const handleKeyDown = (placement: Placement, event: any): void => {\n    if (event.code === 'Escape') {\n      // Handle only in overlay mode\n      if (isOverlay(placement)) {\n        onClose?.({\n          placement,\n          reason: 'escapeKey'\n        });\n      }\n    }\n  };\n\n  // Styles\n  const { classes, styles } = useComponentTheme<never, DrawerLayoutStyles>(\n    DrawerLayoutRedwoodTheme\n  );\n\n  const getVisibilityClass = (visibility: Visibility) => {\n    return visibility === stringHidden ? styles.visibilityHidden : styles.visibilityVisible;\n  };\n\n  const isOverlay = useCallback(\n    (placement: Placement): boolean => {\n      return (\n        [stringFullOverlay, stringOverlay].indexOf(getDrawerResolvedDisplayMode(placement)) > -1\n      );\n    },\n    [getDrawerResolvedDisplayMode]\n  );\n\n  const isFullOverlay = (placement: Placement): boolean => {\n    return getDrawerResolvedDisplayMode(placement) === stringFullOverlay;\n  };\n\n  const getDrawerClassNames = (placement: Placement): string => {\n    // Visibility style is always added\n    const visibility: Visibility = getDrawerVisibility(placement);\n    const classNamesArr: string[] = [getVisibilityClass(visibility)];\n\n    // Styles for overlay vs. full-overlay vs. reflow\n    if (isOverlay(placement)) {\n      classNamesArr.push(styles.overlayDrawer);\n      if (isSidePlacement(placement) && !isFullOverlay(placement)) {\n        classNamesArr.push(styles.overlaySideDrawerNonFullWidth);\n      }\n    } else {\n      classNamesArr.push(styles.reflowDrawer);\n    }\n\n    // Styles for animation\n    if (isDrawerAnimationPending(placement)) {\n      classNamesArr.push(styles.animatedDrawer);\n    }\n\n    const getPlacementSpecificStyles = (placement: Placement): string => {\n      switch (placement) {\n        case stringStart:\n          if (isOverlay(stringStart)) {\n            return isLtr ? styles.overlayDrawerLeft : styles.overlayDrawerRight;\n          } else {\n            return isLtr ? styles.reflowDrawerLeft : styles.reflowDrawerRight;\n          }\n        case stringEnd:\n          if (isOverlay(stringEnd)) {\n            return isLtr ? styles.overlayDrawerRight : styles.overlayDrawerLeft;\n          } else {\n            return isLtr ? styles.reflowDrawerRight : styles.reflowDrawerLeft;\n          }\n        case stringBottom:\n          return isOverlay(stringBottom) ? styles.overlayDrawerBottom : styles.reflowDrawerBottom;\n      }\n    };\n    // Placement specific styles\n    classNamesArr.push(getPlacementSpecificStyles(placement));\n\n    return classNames(classNamesArr);\n  };\n\n  const getDrawerProp = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startDrawer;\n      case stringEnd:\n        return endDrawer;\n      case stringBottom:\n        return bottomDrawer;\n    }\n  };\n\n  const getKeyDownHandler = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return handleKeyDownStart;\n      case stringEnd:\n        return handleKeyDownEnd;\n      case stringBottom:\n        return handleKeyDownBottom;\n    }\n  };\n\n  // Single drawer template\n  const renderDrawer = (placement: Placement) => {\n    return (\n      <div\n        ref={getDrawerRef(placement)}\n        className={getDrawerClassNames(placement)}\n        tabIndex={isOverlay(placement) ? -1 : undefined}\n        onKeyDown={getKeyDownHandler(placement)}>\n        {getDrawerProp(placement)}\n      </div>\n    );\n  };\n\n  const clientHints = getClientHints();\n\n  const getViewportHeight = useCallback((): number => {\n    if (clientHints.platform === 'ios') {\n      // On ios window.innerHeight is not recommended way of measuring the viewport\n      return document.documentElement.clientHeight;\n    }\n    return window.innerHeight;\n  }, [clientHints.platform]);\n\n  // We faced error in KM test environment\n  // Error: ResizeObserver loop completed with undelivered notifications.\n  // This happens when an observed element is resized again during a notification.\n  // Another cause can be rounding values and then setting the rounded value back.\n  // If this is in the same loop as the resize notification, it will cause another resize on the element.\n  // Wrapping ResizeObserver’s callback in a setTimeout with a delay of 0 milliseconds\n  // reschedules the effect to occur after the ResizeObserver’s loop has completed.\n  const rescheduleObserverHandler = (callback: any) => {\n    setTimeout(() => {\n      callback();\n    }, 0);\n  };\n\n  const handleRescheduledVerticalResize = useCallback(() => {\n    const viewportHeight = getViewportHeight();\n    if (viewportHeight >= verticalBreakpoint) {\n      if (viewportDisplayModeVertical != stringReflow) {\n        triggerFocusTransferStrategy();\n        setViewportDisplayModeVertical(stringReflow);\n      }\n    } else {\n      if (viewportDisplayModeVertical != stringOverlay) {\n        triggerFocusTransferStrategy();\n        setViewportDisplayModeVertical(stringOverlay);\n      }\n    }\n  }, [viewportDisplayModeVertical, getViewportHeight, triggerFocusTransferStrategy]);\n\n  const handleVerticalResize = useCallback(() => {\n    rescheduleObserverHandler(handleRescheduledVerticalResize);\n  }, [handleRescheduledVerticalResize]);\n\n  // Window resize listener\n  // useBreakpoint hook is designed for horizontal breakpoints only\n  // This listener is used for 600px (overlay vs. reflow) breakpoint\n  // used for bottom drawer\n  useEffect(() => {\n    const resizeObserver = new ResizeObserver(() => {\n      handleVerticalResize();\n    });\n    resizeObserver.observe(document.body);\n    // Deregister resize observer when Drawer layout unmounts\n    return () => {\n      resizeObserver.unobserve(document.body);\n    };\n  }, [handleVerticalResize]);\n\n  const getOffset = (placement: Placement): number => {\n    const drawerEl = getDrawerEl(placement);\n    if (drawerEl) {\n      return isSidePlacement(placement) ? -getElementWidth(drawerEl) : -getElementHeight(drawerEl);\n    }\n    return 0;\n  };\n\n  const getOffsetState = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startOffset;\n      case stringEnd:\n        return endOffset;\n      case stringBottom:\n        return bottomOffset;\n    }\n  };\n\n  const setSideOverlayDrawerFullHeight = useCallback(\n    (placement: Placement) => {\n      // By default PopupElements have no predefined height.\n      // In 'overlay' mode drawers should be\n      // of the same height as their parent <oj-drawer-layout>\n      const centerSectionHeight = getElementHeightPx(centerRef.current as HTMLDivElement);\n\n      const drawerEl = getDrawerRef(placement).current;\n      if (drawerEl && isDrawerOpen(placement) && isOverlay(placement)) {\n        drawerEl.style.height = centerSectionHeight;\n      }\n    },\n    [getElementHeightPx, isDrawerOpen, isOverlay]\n  );\n\n  const handleSideDrawerFullWidth = (placement: Placement) => {\n    const drawerEl = getDrawerRef(placement).current;\n    if (drawerEl) {\n      if (isDrawerOpen(placement)) {\n        const drawerInlineStyle = drawerEl.style;\n        if (isFullOverlay(placement)) {\n          drawerInlineStyle.width = getElementWidthPx(rootRef.current as HTMLDivElement);\n        } else {\n          drawerInlineStyle.removeProperty('width');\n        }\n      }\n    }\n  };\n\n  const setBottomOverlayDrawerWidth = useCallback(() => {\n    const bottomDrawerElement = bottomDrawerRef.current;\n    if (bottomDrawerElement && isDrawerOpen(stringBottom) && isOverlay(stringBottom)) {\n      const centerSectionWidth = getElementWidthPx(centerRef.current as HTMLDivElement);\n      bottomDrawerElement.style.width = centerSectionWidth;\n    }\n  }, [getElementWidthPx, isDrawerOpen, isOverlay]);\n\n  const setDrawerSize = (placement: Placement) => {\n    if (isSidePlacement(placement)) {\n      setSideOverlayDrawerFullHeight(placement);\n      handleSideDrawerFullWidth(placement);\n    }\n    if (isBottomPlacement(placement)) {\n      setBottomOverlayDrawerWidth();\n    }\n  };\n\n  // DrawerLayout resize observer\n  const handleDrawerLayoutResize = () => {\n    rescheduleObserverHandler(handleRescheduledDrawerLayoutResize);\n  };\n  const handleRescheduledDrawerLayoutResize = useCallback(() => {\n    // If the DrawerLayout (page content) changes size,\n    // adjust OVERLAY side drawers (start/end) height to fit the drawer\n    // Note that these two functions checks that 'overlay' condition is fulfilled\n    setSideOverlayDrawerFullHeight(stringStart);\n    setSideOverlayDrawerFullHeight(stringEnd);\n    setBottomOverlayDrawerWidth();\n  }, [setSideOverlayDrawerFullHeight, setBottomOverlayDrawerWidth]);\n  useResizeObserver(rootRef, handleDrawerLayoutResize);\n\n  const setOffsetState = (placement: Placement) => {\n    // This method sets offset used only in overlay mode\n    if (isOverlay(placement)) {\n      const offset = getOffset(placement);\n      switch (placement) {\n        case stringStart:\n          setStartOffset(offset);\n          break;\n        case stringEnd:\n          setEndOffset(offset);\n          break;\n        case stringBottom:\n          setBottomOffset(offset);\n          break;\n      }\n    }\n  };\n\n  // Start drawer resize observer\n  const handleStartDrawerResize = () => {\n    rescheduleObserverHandler(handleRescheduledStartDrawerResize);\n  };\n  const handleRescheduledStartDrawerResize = () => {\n    setOffsetState(stringStart);\n    setBottomOverlayDrawerWidth();\n  };\n  useResizeObserver(startDrawerRef, handleStartDrawerResize);\n\n  // End drawer resize observer\n  const handleEndDrawerResize = () => {\n    rescheduleObserverHandler(handleRescheduledEndDrawerResize);\n  };\n  const handleRescheduledEndDrawerResize = () => {\n    setOffsetState(stringEnd);\n    setBottomOverlayDrawerWidth();\n  };\n  useResizeObserver(endDrawerRef, handleEndDrawerResize);\n\n  // Bottom drawer resize observer\n  const handleBottomDrawerResize = () => {\n    rescheduleObserverHandler(handleRescheduledBottomDrawerResize);\n  };\n  const handleRescheduledBottomDrawerResize = () => {\n    setOffsetState(stringBottom);\n  };\n  useResizeObserver(bottomDrawerRef, handleBottomDrawerResize);\n\n  const getDrawerPreviousResolvedDisplayMode = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startResolvedDisplayMode;\n      case stringEnd:\n        return endResolvedDisplayMode;\n      case stringBottom:\n        return bottomResolvedDisplayMode;\n    }\n  };\n\n  const saveResolvedDisplayMode = (placement: Placement) => {\n    const currentResolvedDisplayMode = getDrawerResolvedDisplayMode(placement);\n    if (getDrawerPreviousResolvedDisplayMode(placement) != currentResolvedDisplayMode) {\n      switch (placement) {\n        case stringStart:\n          setStartResolvedDisplayMode(currentResolvedDisplayMode);\n        case stringEnd:\n          setEndResolvedDisplayMode(currentResolvedDisplayMode);\n        case stringBottom:\n          setBottomResolvedDisplayMode(currentResolvedDisplayMode);\n      }\n\n      // In case of 'reflow <> overlay' change conditional rendering of a drawer happens.\n      // The old DOM is destoryed and a new DOM is created. In this case focus gets lost.\n      // Browser moves the focus to body.\n      // We try to prevent it by eventually applying focus in the newly created DOM.\n      // If at least one drawer is open, we will check whether focus lives whithin.\n      // See the following method for more details.\n      triggerFocusTransferStrategy();\n    }\n  };\n\n  const getReflowOrOverlayDrawer = (placement: Placement) => {\n    const shiftOptions: ShiftOptions = {\n      mainAxis: false,\n      crossAxis: false\n    };\n\n    const flipOptions = {\n      mainAxis: false,\n      crossAxis: false\n    };\n\n    // Save resolved display mode of a drawer so that we can compare it with 'next' value\n    saveResolvedDisplayMode(placement);\n\n    // Reflow vs. overlay drawer\n    if (isOverlay(placement)) {\n      setDrawerSize(placement);\n\n      // Initial offset\n      if (!getOffsetState(placement)) {\n        setOffsetState(placement);\n      }\n\n      return (\n        // Reconciliation issue. Reparented node must\n        // be a single child of a <div>\n        <div>\n          <Layer>\n            <Floating\n              anchorRef={placement === stringBottom ? centerRef : rootRef}\n              placement={placement}\n              class={isDrawerAnimationPending(placement) ? styles.floating : ''}\n              offsetValue={getOffsetState(placement)}\n              flipOptions={flipOptions}\n              shiftOptions={shiftOptions}>\n              {renderDrawer(placement)}\n            </Floating>\n          </Layer>\n        </div>\n      );\n    } else {\n      return renderDrawer(placement);\n    }\n  };\n\n  // Render drawer conditionally\n  const getDrawer = (placement: Placement): any => {\n    const isMounted = getDrawerStatus(placement) !== stringUnmounted;\n    return isMounted ? getReflowOrOverlayDrawer(placement) : null;\n  };\n\n  return (\n    <div ref={rootRef} className={classes} {...testIdProps}>\n      {/*Start drawer*/}\n      {getDrawer(stringStart)}\n      {/*Center section*/}\n      <div ref={centerRef} className={styles.centerSection}>\n        <div className={styles.mainContent}>\n          {/*<main content*/}\n          {children}\n        </div>\n        {/*Bottom drawer*/}\n        {getDrawer(stringBottom)}\n      </div>\n      {/*End drawer*/}\n      {getDrawer(stringEnd)}\n    </div>\n  );\n};\n"],"names":["children","startDrawer","endDrawer","bottomDrawer","isStartOpen","isEndOpen","isBottomOpen","startDisplay","endDisplay","bottomDisplay","onClose","onTransitionEnd","testId","zeroPx","stringStart","stringEnd","stringBottom","stringInitial","stringOpening","stringClosing","stringUnmounted","stringFullOverlay","stringOverlay","stringReflow","stringHidden","startDrawerStatus","setStartDrawerStatus","useState","endDrawerStatus","setEndDrawerStatus","bottomDrawerStatus","setBottomDrawerStatus","startVisibility","setStartVisibility","endVisibility","setEndVisibility","bottomVisibility","setBottomVisibility","startOffset","setStartOffset","endOffset","setEndOffset","bottomOffset","setBottomOffset","displayMode","useBreakpointValues","sm","md","lg","viewportDisplayModeHorizontal","setViewportDisplayModeHorizontal","viewportDisplayModeVertical","setViewportDisplayModeVertical","rootRef","useRef","centerRef","startDrawerRef","endDrawerRef","bottomDrawerRef","placementOfLastlyFocusedRef","indexOfLastlyFocusedRef","startLauncherRef","endLauncherRef","bottomLauncherRef","elementWithFocusBeforeDrawerClosesRef","startResolvedDisplayMode","setStartResolvedDisplayMode","endResolvedDisplayMode","setEndResolvedDisplayMode","bottomResolvedDisplayMode","setBottomResolvedDisplayMode","getDrawerEl","useCallback","placement","getDrawerRef","current","getPlacementOfDrawerWithFocus","startDrawerEl","endDrawerEl","bottomDrawerEl","activeElement","getActiveElement","contains","triggerFocusTransferStrategy","activeElementPlacement","allTabbables","allTabbableElements","indexOf","isDrawerOpen","isOpen","useEffect","placementOflastlyFocusedDrawer","drawerRefReceivingFocus","length","focusOn","focusWithin","setTimeout","getElementHeight","element","Math","round","offsetHeight","getElementHeightPx","getElementWidth","getBoundingClientRect","width","getElementWidthPx","direction","useUser","isLtr","getNormalizedPlacement","normalizePosition","isSidePlacement","isBottomPlacement","isAnimationPending","status","isDrawerAnimationPending","setDrawerVisibility","visibility","getAnimatedNodeRef","startAnimatedNodeRef","endAnimatedNodeRef","bottomAnimatedNodeRef","getDrawerStatus","setDrawerStatus","resetAnimatedNodeRef","getDrawerDisplayProp","getDrawerResolvedDisplayMode","displayProp","getAnimationStates","ref","expandVertically","from","maxHeight","to","options","duration","DURATION_LARGE","collapseVertically","expandHorizontally","maxWidth","collapseHorizontally","slideUp","translateY","slideDown","slideOpenLeft","translateX","slideCloseLeft","slideOpenRight","slideCloseRight","returnFocusToLauncher","focusOnElementOrNearestAncestor","getLauncherRef","useNodeRef","useAnimation","bottomPlacement","getAnimationEffect","animationStates","isAnimatedOnMount","onAnimationEnd","isOverlay","drawerRef","autofocusItems","getAutofocusFocusables","setInitialFocus","removeAttribute","removeAnimationInlineStyles","value","nodeRef","testIdProps","useTestId","useDrawerStatus","drawerStatus","animatedNodeRef","setLauncherRef","handleKeyDownStart","event","handleKeyDown","handleKeyDownEnd","handleKeyDownBottom","code","reason","classes","styles","useComponentTheme","DrawerLayoutRedwoodTheme","getVisibilityClass","visibilityHidden","visibilityVisible","isFullOverlay","getDrawerClassNames","getDrawerVisibility","classNamesArr","push","overlayDrawer","overlaySideDrawerNonFullWidth","reflowDrawer","animatedDrawer","overlayDrawerLeft","overlayDrawerRight","reflowDrawerLeft","reflowDrawerRight","overlayDrawerBottom","reflowDrawerBottom","getPlacementSpecificStyles","classNames","getDrawerProp","getKeyDownHandler","renderDrawer","_jsx","className","tabIndex","undefined","onKeyDown","clientHints","getClientHints","getViewportHeight","platform","document","documentElement","clientHeight","window","innerHeight","rescheduleObserverHandler","callback","handleRescheduledVerticalResize","handleVerticalResize","resizeObserver","ResizeObserver","observe","body","unobserve","getOffsetState","setSideOverlayDrawerFullHeight","centerSectionHeight","drawerEl","style","height","setBottomOverlayDrawerWidth","bottomDrawerElement","centerSectionWidth","setDrawerSize","drawerInlineStyle","removeProperty","handleSideDrawerFullWidth","handleRescheduledDrawerLayoutResize","useResizeObserver","setOffsetState","offset","getOffset","handleRescheduledStartDrawerResize","handleRescheduledEndDrawerResize","handleRescheduledBottomDrawerResize","saveResolvedDisplayMode","currentResolvedDisplayMode","getDrawerPreviousResolvedDisplayMode","getDrawer","shiftOptions","mainAxis","crossAxis","flipOptions","jsx","Layer","Floating","anchorRef","class","floating","offsetValue","getReflowOrOverlayDrawer","_jsxs","jsxs","centerSection","mainContent"],"mappings":"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"}