{"version":3,"file":"Table-d8edded4.js","sources":["../../src/PRIVATE_Table/TableColGroup.tsx","../../src/PRIVATE_Table/TableSkeleton.tsx","../../src/PRIVATE_Table/TableSkeletonRow.tsx","../../src/PRIVATE_Table/utils/TableThemeUtils.ts","../../src/PRIVATE_Table/utils/TableDomUtils.ts","../../src/PRIVATE_Table/utils/TableTooltipUtils.ts","../../src/PRIVATE_Table/TableCell.tsx","../../src/PRIVATE_Table/TableRow.tsx","../../src/PRIVATE_Table/TableNoData.tsx","../../src/PRIVATE_Table/TableBody.tsx","../../src/PRIVATE_Table/TableHeaderCell.tsx","../../src/PRIVATE_Table/TableHeader.tsx","../../src/PRIVATE_Table/TableFooterCell.tsx","../../src/PRIVATE_Table/TableFooter.tsx","../../src/PRIVATE_Table/TableDragIndicator.tsx","../../src/PRIVATE_Table/TableContextMenu.tsx","../../src/PRIVATE_Table/utils/TableScrollUtils.ts","../../src/PRIVATE_Table/utils/TableFocusUtils.ts","../../src/PRIVATE_Table/hooks/useContextMenu.ts","../../src/PRIVATE_Table/hooks/useTruncationTooltip.tsx","../../src/PRIVATE_Table/hooks/useFocusHandling.ts","../../src/PRIVATE_Table/utils/TableActionUtils.ts","../../src/PRIVATE_Table/utils/TableNavigationUtils.ts","../../src/PRIVATE_Table/utils/TableSelectionUtils.ts","../../src/PRIVATE_Table/utils/TableSizingUtils.ts","../../src/PRIVATE_Table/hooks/usePointerHandling.ts","../../src/PRIVATE_Table/utils/TableSortUtils.ts","../../src/PRIVATE_Table/hooks/useScrollHandling.ts","../../src/PRIVATE_Table/hooks/useInteractionManager.ts","../../src/PRIVATE_Table/hooks/useKeyboardHandling.ts","../../src/PRIVATE_Table/utils/TableLayoutUtils.ts","../../src/PRIVATE_Table/hooks/useSizingManager.ts","../../src/PRIVATE_Table/Table.tsx","../../src/PRIVATE_Table/hooks/useDataManager.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\n/**\n * Props for the TableColGroup Component\n */\nexport type TableColGroupProps = {\n  tableId: string;\n  isRendered: boolean;\n  columnWidthsArray: (number | undefined)[];\n};\n\n/**\n * The internal component used to render a single colgroup in Table.\n */\nexport function TableColGroup({ tableId, isRendered, columnWidthsArray }: TableColGroupProps) {\n  const getColStyle = (columnWidth?: number) => {\n    return columnWidth == null ? '' : `width:${columnWidth}px;`;\n  };\n\n  return isRendered ? (\n    <colgroup>\n      {columnWidthsArray.map((columnWidth?: number) => {\n        return <col style={getColStyle(columnWidth)} data-oj-table-col={tableId} />;\n      })}\n    </colgroup>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Size } from '../utils/UNSAFE_size';\nimport { dimensionInterpolations } from '../utils/UNSAFE_interpolations/dimensions';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\nimport { tableSkeletonStyles, tableSkeletonStylesHC } from './themes/TableSkeletonStyles.css';\n\nconst dimensions = ['height', 'width'] as const;\n//This type has StyleInterpolationProps with the height prop made required.\ntype TableSkeletonProps = {\n  isHighContrast: boolean;\n  height?: Size;\n  width?: Size;\n};\n\n// Create an array [dimensionInterpolations['height'], dimensionInterpolations['width']]\nconst skeletonDimensionInterpolation = Array.from(dimensions, (x) => dimensionInterpolations[x]);\nconst interpolations = [...Object.values(skeletonDimensionInterpolation)];\nconst SkeletonInterpolations = mergeInterpolations<TableSkeletonProps>(interpolations);\n\n/**\n * TableSkeleton component allows the appropriate skeleton to be rendered based on the\n * property values\n **/\nexport function TableSkeleton({ ...props }: TableSkeletonProps) {\n  const skeletonStyles = props.isHighContrast ? tableSkeletonStylesHC : tableSkeletonStyles;\n  const classes = classNames([skeletonStyles.bar]);\n\n  const skeletonDimensions = SkeletonInterpolations({ width: '100%', ...props });\n  return <div style={skeletonDimensions} class={classes} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { BundleType } from '../resources/nls/bundle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport { LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\nimport { tableSkeletonStyles, tableSkeletonStylesHC } from './themes/TableSkeletonStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { TableSkeleton } from './TableSkeleton';\n\ntype SkeletonRowProps = {\n  tableId: string;\n  colspan: number;\n  hasTabIndex: boolean;\n  isShowFocusRing: boolean;\n  isPendingLayout?: boolean;\n  isLoadMore?: boolean;\n  isHighContrast: boolean;\n};\n\n/**\n * TableSkeletonRow renders a set of 'loading' skeletons.\n **/\nexport function TableSkeletonRow({\n  tableId,\n  colspan,\n  hasTabIndex,\n  isShowFocusRing,\n  isPendingLayout = false,\n  isLoadMore = false,\n  isHighContrast\n}: SkeletonRowProps) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const skeletonStyles = isHighContrast ? tableSkeletonStylesHC : tableSkeletonStyles;\n  const cellClassArray = [skeletonStyles.cell];\n  if (isShowFocusRing) {\n    cellClassArray.push(skeletonStyles.focus);\n  }\n  const cellClasses = classNames(cellClassArray);\n  const innerCellClasses = classNames([skeletonStyles.innerCell]);\n  const rowClasses = classNames([skeletonStyles.row, skeletonStyles.rowHeight]);\n  const firstRowClasses = isPendingLayout\n    ? classNames([skeletonStyles.row, skeletonStyles.headerHeight])\n    : rowClasses;\n\n  const accCellContent = (\n    <div style={'width:1px;height:0px;overflow:hidden;'}>{translations.collection_loading()}</div>\n  );\n\n  return (\n    <tr class={LOADMORE_STYLE_CLASS} role={'row'}>\n      <td\n        class={cellClasses}\n        colSpan={colspan}\n        role={'gridcell'}\n        tabIndex={hasTabIndex ? 0 : -1}\n        data-oj-cell-type={isPendingLayout ? 'pending' : isLoadMore ? 'loadMore' : 'loading'}\n        {...(isPendingLayout\n          ? { 'data-oj-table-pending-cell': tableId }\n          : isLoadMore\n          ? { 'data-oj-table-load-more-cell': tableId }\n          : { 'data-oj-table-loading-cell': tableId })}\n        data-oj-table-focusable={tableId}>\n        <div class={innerCellClasses}>\n          {accCellContent}\n          {[...Array(isLoadMore ? 3 : 25)].map((_element, index) => (\n            <div class={index === 0 ? firstRowClasses : rowClasses}>\n              <TableSkeleton height=\"4x\" isHighContrast={isHighContrast} />\n            </div>\n          ))}\n        </div>\n      </td>\n    </tr>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { textAlignStyles, verticalAlignStyles } from '../themes/Table.css';\nimport { CellStyles, tableCellStyles, tableCellStylesHC } from '../themes/TableCellStyles.css';\nimport {\n  FooterCellStyles,\n  tableFooterCellStyles,\n  tableFooterCellStylesHC,\n  footerPreviousInteractiveBorderStart,\n  footerPreviousInteractiveBorderStartHC,\n  footerPreviousInteractiveBorderStartNoPadding,\n  footerPreviousInteractiveBorderStartNoPaddingHC,\n  footerPreviousPseudoHoverBorderStart,\n  footerPreviousPseudoHoverBorderStartHC,\n  footerPreviousPseudoHoverBorderStartNoPadding,\n  footerPreviousPseudoHoverBorderStartNoPaddingHC\n} from '../themes/TableFooterCellStyles.css';\nimport {\n  HeaderCellStyles,\n  tableHeaderCellStyles,\n  tableHeaderCellStylesHC,\n  headerPreviousInteractiveBorderStart,\n  headerPreviousInteractiveBorderStartHC,\n  headerPreviousInteractiveBorderStartNoPadding,\n  headerPreviousInteractiveBorderStartNoPaddingHC,\n  headerPreviousPseudoHoverBorderStart,\n  headerPreviousPseudoHoverBorderStartHC,\n  headerPreviousPseudoHoverBorderStartNoPadding,\n  headerPreviousPseudoHoverBorderStartNoPaddingHC\n} from '../themes/TableHeaderCellStyles.css';\nimport { CellPadding, CurrentRowVariant } from '../../UNSAFE_TableView';\n\ntype DataCellThemingProps = {\n  isFirstColumnIndex: boolean;\n  isFinalColumnIndex: boolean;\n  isFirstRowIndex: boolean;\n  isFinalRowIndex: boolean;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  hasLastHorizontalGridline: boolean;\n  isRowSelected: boolean;\n  isPreviousRowSelected: boolean;\n  isColumnSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isShowFocusRing: boolean;\n  isSticky: boolean;\n  isRowSelectionEnabled: boolean;\n  isRowSingleSelection: boolean;\n  isActive: boolean;\n  isHover: boolean;\n  isPseudoHover: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  horizontalAlignment: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment: 'top' | 'center' | 'bottom';\n  variant?: CurrentRowVariant;\n  padding?: CellPadding;\n};\n\n/**\n * Helper function to generate the class array for a data cell.\n */\nexport const getDataCellClassArray = ({\n  isFirstColumnIndex,\n  isFinalColumnIndex,\n  isFirstRowIndex,\n  isFinalRowIndex,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  hasLastHorizontalGridline,\n  isRowSelected,\n  isPreviousRowSelected,\n  isColumnSelected,\n  isPreviousColumnSelected,\n  isShowFocusRing,\n  isSticky,\n  isRowSelectionEnabled,\n  isRowSingleSelection,\n  isActive,\n  isHover,\n  isPseudoHover,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl,\n  isHighContrast,\n  horizontalAlignment,\n  verticalAlignment,\n  variant,\n  padding\n}: DataCellThemingProps) => {\n  const cellStyles = isHighContrast ? tableCellStylesHC : tableCellStyles;\n  const classArray = [cellStyles.base];\n\n  // Padding styling logic\n  const { isTopPadding, isBottomPadding, isStartPadding, isEndPadding } = _getPaddingInfo(padding);\n\n  // Horizontal and vertical alignment styling logic\n  _applyAlignmentStyling(classArray, horizontalAlignment, verticalAlignment);\n\n  // Sticky styling logic\n  _applyStickyStyling(classArray, cellStyles, isSticky, isStickyStartEdge, isStickyEndEdge, isRtl);\n\n  // Interaction styling logic\n  if (isRowSelectionEnabled) {\n    if (isActive) {\n      classArray.push(cellStyles.active);\n    } else if (isHover) {\n      classArray.push(cellStyles.hover);\n    } else if (isPseudoHover) {\n      classArray.push(cellStyles.pseudoHover);\n    }\n  }\n  if (variant === 'highlight') {\n    classArray.push(cellStyles.rowHighlight);\n  }\n  _applyFocusStyling(classArray, cellStyles, isShowFocusRing);\n\n  // Selected Rows and Horizontal Gridline styling logic\n  let hasBackground = false;\n  if (isRowSelected) {\n    hasBackground = true;\n    classArray.push(cellStyles.selectedBackground);\n  }\n  if (isRowSingleSelection && (isRowSelected || isPreviousRowSelected)) {\n    classArray.push(cellStyles.horizontalSelectedGridTop);\n    classArray.push(\n      isTopPadding ? cellStyles.selectedBorderTopPadding : cellStyles.selectedBorderTopNoPadding\n    );\n  } else if (!isFirstRowIndex && hasHorizontalGridlines) {\n    classArray.push(cellStyles.horizontalGridTop);\n    classArray.push(isTopPadding ? cellStyles.borderTopPadding : cellStyles.borderTopNoPadding);\n  } else {\n    classArray.push(isTopPadding ? cellStyles.topSpacerPadding : cellStyles.topSpacerNoPadding);\n  }\n  if (isFinalRowIndex) {\n    classArray.push(cellStyles.lastRow);\n    if (isRowSingleSelection && isRowSelected) {\n      classArray.push(cellStyles.horizontalSelectedGridBottom);\n      classArray.push(\n        isBottomPadding\n          ? cellStyles.selectedBorderBottomPadding\n          : cellStyles.selectedBorderBottomNoPadding\n      );\n    } else if (hasLastHorizontalGridline) {\n      classArray.push(cellStyles.horizontalGridBottom);\n      classArray.push(\n        isBottomPadding ? cellStyles.borderBottomPadding : cellStyles.borderBottomNoPadding\n      );\n    } else {\n      classArray.push(\n        isBottomPadding ? cellStyles.bottomSpacerPadding : cellStyles.bottomSpacerNoPadding\n      );\n    }\n  } else {\n    classArray.push(cellStyles.notLastRow);\n    classArray.push(isBottomPadding ? cellStyles.bottomPadding : cellStyles.bottomNoPadding);\n  }\n\n  // Selected Columns and Vertical Gridline styling logic\n  if (isColumnSelected) {\n    if (!hasBackground) {\n      classArray.push(cellStyles.selectedBackground);\n      hasBackground = true;\n    }\n    _applySelectedColumnStyling(\n      classArray,\n      cellStyles,\n      isStartPadding,\n      isEndPadding,\n      isFinalColumnIndex\n    );\n  } else {\n    if (!hasBackground) {\n      classArray.push(cellStyles.background);\n    }\n    _applyColumnStyling(\n      classArray,\n      cellStyles,\n      isPreviousColumnSelected,\n      isStartPadding,\n      isEndPadding,\n      isFirstColumnIndex,\n      isFinalColumnIndex,\n      hasVerticalGridlines\n    );\n  }\n  return classArray;\n};\n\ntype HeaderFooterCellThemingProps = {\n  isHeader: boolean;\n  isActive: boolean;\n  isHover: boolean;\n  isPseudoHover: boolean;\n  isFirstColumnIndex: boolean;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isColumnSelectionEnabled: boolean;\n  isSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isColumnSelectable: boolean;\n  isShowFocusRing: boolean;\n  isSticky: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  horizontalAlignment: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment: 'top' | 'center' | 'bottom';\n  isHighContrast: boolean;\n  padding?: CellPadding;\n};\n\n/**\n * Helper function to generate the class array for a header or footer cell.\n */\nexport const getHeaderFooterCellClassArray = ({\n  isHeader,\n  isActive,\n  isHover,\n  isPseudoHover,\n  isFirstColumnIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  isColumnSelectionEnabled,\n  isSelected,\n  isPreviousColumnSelected,\n  isColumnSelectable,\n  isShowFocusRing,\n  isSticky,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl,\n  horizontalAlignment,\n  verticalAlignment,\n  isHighContrast,\n  padding\n}: HeaderFooterCellThemingProps) => {\n  let cellStyles;\n  let previousInteractiveBorderStart;\n  let previousInteractiveBorderStartNoPadding;\n  let previousPseudoHoverBorderStart;\n  let previousPseudoHoverBorderStartNoPadding;\n\n  if (isHeader) {\n    if (isHighContrast) {\n      cellStyles = tableHeaderCellStylesHC;\n      previousInteractiveBorderStart = headerPreviousInteractiveBorderStartHC;\n      previousPseudoHoverBorderStart = headerPreviousPseudoHoverBorderStartHC;\n      previousInteractiveBorderStartNoPadding = headerPreviousInteractiveBorderStartNoPaddingHC;\n      previousPseudoHoverBorderStartNoPadding = headerPreviousPseudoHoverBorderStartNoPaddingHC;\n    } else {\n      cellStyles = tableHeaderCellStyles;\n      previousInteractiveBorderStart = headerPreviousInteractiveBorderStart;\n      previousPseudoHoverBorderStart = headerPreviousPseudoHoverBorderStart;\n      previousInteractiveBorderStartNoPadding = headerPreviousInteractiveBorderStartNoPadding;\n      previousPseudoHoverBorderStartNoPadding = headerPreviousPseudoHoverBorderStartNoPadding;\n    }\n  } else if (isHighContrast) {\n    cellStyles = tableFooterCellStylesHC;\n    previousInteractiveBorderStart = footerPreviousInteractiveBorderStartHC;\n    previousInteractiveBorderStartNoPadding = footerPreviousInteractiveBorderStartNoPaddingHC;\n    previousPseudoHoverBorderStart = footerPreviousPseudoHoverBorderStartHC;\n    previousPseudoHoverBorderStartNoPadding = footerPreviousPseudoHoverBorderStartNoPaddingHC;\n  } else {\n    cellStyles = tableFooterCellStyles;\n    previousInteractiveBorderStart = footerPreviousInteractiveBorderStart;\n    previousInteractiveBorderStartNoPadding = footerPreviousInteractiveBorderStartNoPadding;\n    previousPseudoHoverBorderStart = footerPreviousPseudoHoverBorderStart;\n    previousPseudoHoverBorderStartNoPadding = footerPreviousPseudoHoverBorderStartNoPadding;\n  }\n  const classArray = [cellStyles.base];\n\n  // Padding styling logic\n  const { isTopPadding, isBottomPadding, isStartPadding, isEndPadding } = _getPaddingInfo(padding);\n  classArray.push(isBottomPadding ? cellStyles.bottomPadding : cellStyles.bottomNoPadding);\n  classArray.push(isTopPadding ? cellStyles.topPadding : cellStyles.topNoPadding);\n\n  // Horizontal and vertical alignment styling logic\n  _applyAlignmentStyling(classArray, horizontalAlignment, verticalAlignment);\n\n  // Sticky styling logic\n  _applyStickyStyling(classArray, cellStyles, isSticky, isStickyStartEdge, isStickyEndEdge, isRtl);\n\n  // Selected and Vertical Gridline styling logic\n  if (isSelected) {\n    classArray.push(cellStyles.selectedBackground);\n    _applySelectedColumnStyling(\n      classArray,\n      cellStyles,\n      isStartPadding,\n      isEndPadding,\n      isFinalColumnIndex\n    );\n  } else {\n    classArray.push(cellStyles.background);\n    let additionalStyles;\n    if (isColumnSelectionEnabled) {\n      // dynamic start borders for when previous cell has hover / active states\n      additionalStyles = {\n        startInteractivePaddingStyles: [\n          previousInteractiveBorderStart,\n          previousPseudoHoverBorderStart\n        ],\n        startInteractiveNoPaddingStyles: [\n          previousInteractiveBorderStartNoPadding,\n          previousPseudoHoverBorderStartNoPadding\n        ]\n      };\n    }\n    _applyColumnStyling(\n      classArray,\n      cellStyles,\n      isPreviousColumnSelected,\n      isStartPadding,\n      isEndPadding,\n      isFirstColumnIndex,\n      isFinalColumnIndex,\n      hasVerticalGridlines,\n      additionalStyles\n    );\n  }\n\n  // Interaction styling logic\n  _applyFocusStyling(classArray, cellStyles, isShowFocusRing);\n  if (isColumnSelectable) {\n    let interactiveStyles;\n    if (isActive) {\n      interactiveStyles = {\n        selectedStyle: cellStyles.activeSelected,\n        notSelectedStyle: cellStyles.active,\n        borderStartStyle: cellStyles.activeBorderStart,\n        borderStartNoPaddingStyle: cellStyles.activeBorderStartNoPadding,\n        borderEndStyle: cellStyles.activeBorderEnd,\n        borderEndNoPaddingStyle: cellStyles.activeBorderEndNoPadding\n      };\n    } else if (isHover) {\n      interactiveStyles = {\n        selectedStyle: cellStyles.hoverSelected,\n        notSelectedStyle: cellStyles.hover,\n        borderStartStyle: cellStyles.hoverBorderStart,\n        borderStartNoPaddingStyle: cellStyles.hoverBorderStartNoPadding,\n        borderEndStyle: cellStyles.hoverBorderEnd,\n        borderEndNoPaddingStyle: cellStyles.hoverBorderEndNoPadding\n      };\n    } else if (isPseudoHover) {\n      interactiveStyles = {\n        selectedStyle: cellStyles.pseudoHoverSelected,\n        notSelectedStyle: cellStyles.pseudoHover,\n        borderStartStyle: cellStyles.pseudoHoverBorderStart,\n        borderStartNoPaddingStyle: cellStyles.pseudoHoverBorderStartNoPadding,\n        borderEndStyle: cellStyles.pseudoHoverBorderEnd,\n        borderEndNoPaddingStyle: cellStyles.pseudoHoverBorderEndNoPadding\n      };\n    }\n    if (interactiveStyles != null) {\n      if (isSelected) {\n        classArray.push(interactiveStyles.selectedStyle);\n      } else {\n        classArray.push(interactiveStyles.notSelectedStyle);\n        if (!isPreviousColumnSelected && (!hasVerticalGridlines || isFirstColumnIndex)) {\n          classArray.push(\n            isStartPadding\n              ? interactiveStyles.borderStartStyle\n              : interactiveStyles.borderStartNoPaddingStyle\n          );\n        }\n        if (isFinalColumnIndex) {\n          classArray.push(\n            isEndPadding\n              ? interactiveStyles.borderEndStyle\n              : interactiveStyles.borderEndNoPaddingStyle\n          );\n        }\n      }\n    }\n  }\n  return classArray;\n};\n\nconst _getPaddingInfo = (padding?: CellPadding) => {\n  const isPaddingDisabled = padding === 'disabled';\n  const isComplexPadding = padding instanceof Object;\n  const isBottomPadding = !(\n    isPaddingDisabled ||\n    (isComplexPadding && padding?.bottom === 'disabled')\n  );\n  const isEndPadding = !(isPaddingDisabled || (isComplexPadding && padding?.end === 'disabled'));\n  const isStartPadding = !(\n    isPaddingDisabled ||\n    (isComplexPadding && padding?.start === 'disabled')\n  );\n  const isTopPadding = !(isPaddingDisabled || (isComplexPadding && padding?.top === 'disabled'));\n  return { isTopPadding, isBottomPadding, isStartPadding, isEndPadding };\n};\n\nconst _applyAlignmentStyling = (\n  classArray: string[],\n  horizontalAlignment: 'start' | 'end' | 'left' | 'right' | 'center',\n  verticalAlignment: 'top' | 'center' | 'bottom'\n) => {\n  classArray.push(textAlignStyles[horizontalAlignment]);\n  classArray.push(verticalAlignStyles[verticalAlignment]);\n};\n\nconst _applyFocusStyling = (\n  classArray: string[],\n  cellStyles: CellStyles | HeaderCellStyles | FooterCellStyles,\n  isShowFocusRing: boolean\n) => {\n  if (isShowFocusRing) {\n    classArray.push(cellStyles.focused);\n  }\n};\n\nconst _applyStickyStyling = (\n  classArray: string[],\n  cellStyles: CellStyles | HeaderCellStyles | FooterCellStyles,\n  isSticky: boolean,\n  isStickyStartEdge: boolean,\n  isStickyEndEdge: boolean,\n  isRtl: boolean\n) => {\n  if (isSticky) {\n    classArray.push(cellStyles.stickyColumn);\n  }\n  if (isStickyStartEdge) {\n    classArray.push(cellStyles.stickyEdge);\n    classArray.push(isRtl ? cellStyles.stickyEdgeLeft : cellStyles.stickyEdgeRight);\n  } else if (isStickyEndEdge) {\n    classArray.push(cellStyles.stickyEdge);\n    classArray.push(isRtl ? cellStyles.stickyEdgeRight : cellStyles.stickyEdgeLeft);\n  }\n};\n\nconst _applyColumnStyling = (\n  classArray: string[],\n  cellStyles: CellStyles | HeaderCellStyles | FooterCellStyles,\n  isPreviousColumnSelected: boolean,\n  isStartPadding: boolean,\n  isEndPadding: boolean,\n  isFirstColumnIndex: boolean,\n  isFinalColumnIndex: boolean,\n  hasVerticalGridlines: boolean,\n  additionalStyles?: {\n    startInteractivePaddingStyles: string[];\n    startInteractiveNoPaddingStyles: string[];\n  }\n) => {\n  if (isPreviousColumnSelected) {\n    classArray.push(cellStyles.verticalSelectedGridStart);\n    classArray.push(\n      isStartPadding\n        ? cellStyles.selectedBorderStartPadding\n        : cellStyles.selectedBorderStartNoPadding\n    );\n  } else if (!isFirstColumnIndex && hasVerticalGridlines) {\n    classArray.push(cellStyles.verticalGridStart);\n    classArray.push(\n      isStartPadding ? cellStyles.borderStartPadding : cellStyles.borderStartNoPadding\n    );\n  } else if (isStartPadding) {\n    classArray.push(cellStyles.startSpacerPadding);\n    if (additionalStyles != null) {\n      classArray.push(...additionalStyles.startInteractivePaddingStyles);\n    }\n  } else {\n    classArray.push(cellStyles.startSpacerNoPadding);\n    if (additionalStyles != null) {\n      classArray.push(...additionalStyles.startInteractiveNoPaddingStyles);\n    }\n  }\n  if (isFinalColumnIndex) {\n    classArray.push(isEndPadding ? cellStyles.endSpacerPadding : cellStyles.endSpacerNoPadding);\n  } else {\n    classArray.push(isEndPadding ? cellStyles.endPadding : cellStyles.endNoPadding);\n  }\n};\n\nconst _applySelectedColumnStyling = (\n  classArray: string[],\n  cellStyles: CellStyles | HeaderCellStyles | FooterCellStyles,\n  isStartPadding: boolean,\n  isEndPadding: boolean,\n  isFinalColumnIndex: boolean\n) => {\n  classArray.push(cellStyles.verticalSelectedGridStart);\n  classArray.push(\n    isStartPadding ? cellStyles.selectedBorderStartPadding : cellStyles.selectedBorderStartNoPadding\n  );\n  if (isFinalColumnIndex) {\n    classArray.push(cellStyles.verticalSelectedGridEnd);\n    classArray.push(\n      isEndPadding ? cellStyles.selectedBorderEndPadding : cellStyles.selectedBorderEndNoPadding\n    );\n  } else {\n    classArray.push(isEndPadding ? cellStyles.endPadding : cellStyles.endNoPadding);\n  }\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { FocusableElement } from '../../utils/PRIVATE_tabbableUtils';\nimport { ActiveCell, TableColumn } from '../Table';\nimport { Cell } from '../../UNSAFE_TableView';\n\n/**\n * Returns the cell type for the given cell element\n */\nexport const getCellType = (element: FocusableElement) => {\n  return element.dataset['ojCellType'];\n};\n\n/**\n * Returns the row key for the given row element\n */\nexport const getRowKey = <K>(element: HTMLElement) => {\n  return (\n    element.dataset['ojKeyType'] === 'number'\n      ? Number(element.dataset['ojKey'])\n      : element.dataset['ojKey']\n  ) as K;\n};\n\n/**\n * Returns the key for the row at the given index\n */\nexport const getRowKeyForRowIndex = <K>(\n  rootElement: HTMLElement,\n  tableId: string,\n  index: number\n) => {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  if (rowElements.length > index) {\n    return getRowKey<K>(rowElements[index] as HTMLElement);\n  }\n  return undefined;\n};\n\n/**\n * Returns the index of the given row element\n */\nexport const getRowIndexForRowElement = (\n  rootElement: HTMLElement,\n  tableId: string,\n  rowElement: HTMLElement\n) => {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  const index = Array.prototype.indexOf.call(rowElements, rowElement);\n  if (index > -1) {\n    return index;\n  }\n  return undefined;\n};\n\n/**\n * Returns the index of the row for the given key.\n */\nexport function getRowIndexForRowKey<K>(rootElement: HTMLElement, tableId: string, rowKey: K) {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  for (let i = 0; i < rowElements.length; i++) {\n    if (rowKey === getRowKey(rowElements[i] as HTMLElement)) {\n      return i;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Returns the column key for the given cell element\n */\nexport const getColumnKey = <C>(element: HTMLElement) => {\n  return element.dataset['ojColumnKey'] as C;\n};\n\n/**\n * Returns the key for the column at the given index\n */\nexport const getColumnKeyForColumnIndex = (\n  rootElement: HTMLElement,\n  tableId: string,\n  index: number\n) => {\n  const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n  if (headerElements.length > index) {\n    return getColumnKey(headerElements[index] as HTMLElement);\n  }\n  return undefined;\n};\n\n/**\n * Returns the index of the given column header element or footer element\n */\nexport const getColumnIndexForHeaderFooterElement = (\n  rootElement: HTMLElement,\n  tableId: string,\n  cellElement: HTMLElement,\n  isHeader: boolean\n) => {\n  const columnElements = rootElement.querySelectorAll(\n    isHeader\n      ? `[data-oj-table-header-cell='${tableId}']`\n      : `[data-oj-table-footer-cell='${tableId}']`\n  );\n  const index = Array.prototype.indexOf.call(columnElements, cellElement);\n  if (index > -1) {\n    return index;\n  }\n  return undefined;\n};\n\n/**\n * Helper method to get the cell key definition from an element\n */\nexport function logicalCellExtractor<K extends string | number, D, C extends string>(\n  element: HTMLElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  cellSelector?: string,\n  onlyAncestors?: boolean\n): ActiveCell<K, C> | undefined {\n  const selectorString =\n    cellSelector != null ? cellSelector : `[data-oj-table-focusable='${tableId}']`;\n  const startingElement = onlyAncestors ? element.parentElement : element;\n  if (startingElement != null) {\n    const cellElement = startingElement.closest(selectorString) as HTMLElement;\n    if (cellElement != null) {\n      const cellType = getCellType(cellElement);\n      if (cellType === 'data') {\n        return {\n          rowKey: keyExtractor<K>(cellElement, `[data-oj-table-data-row='${tableId}']`)!,\n          columnKey: getColumnKey<C>(cellElement),\n          type: cellType\n        };\n      } else if (cellType === 'header' || cellType === 'footer') {\n        return { columnKey: getColumnKey<C>(cellElement), type: cellType };\n      } else if (cellType === 'noData' || cellType === 'pending') {\n        return { type: cellType };\n      } else if (cellType === 'loading' || cellType === 'loadMore') {\n        const columnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n        if (columnKey != null) {\n          return { columnKey: columnKey, type: cellType };\n        }\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n * Helper method to get an element from a cell descriptor\n */\nexport function getElementFromCell<K, C>(\n  rootElement: HTMLElement,\n  tableId: string,\n  cell: ActiveCell<K, C> | Cell<K, C>\n): HTMLElement | undefined {\n  if (cell.type === 'header') {\n    // header case\n    const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n    for (const headerElement of headerElements) {\n      if (cell.columnKey === getColumnKey(headerElement as HTMLElement)) {\n        return headerElement as HTMLElement;\n      }\n    }\n  } else if (cell.type === 'footer') {\n    // footer case\n    const footerElements = rootElement.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);\n    for (const footerElement of footerElements) {\n      if (cell.columnKey === getColumnKey(footerElement as HTMLElement)) {\n        return footerElement as HTMLElement;\n      }\n    }\n  } else if (cell.type === 'data') {\n    // data body case\n    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    for (const rowElement of rowElements) {\n      if (cell.rowKey === getRowKey(rowElement as HTMLElement)) {\n        const cellElements = rowElement.querySelectorAll(`[data-oj-table-focusable='${tableId}']`);\n        for (const cellElement of cellElements) {\n          if (cell.columnKey === getColumnKey(cellElement as HTMLElement)) {\n            return cellElement as HTMLElement;\n          }\n        }\n      }\n    }\n  } else if (cell.type === 'noData') {\n    // no data case\n    return rootElement.querySelector(`[data-oj-table-nodata-cell='${tableId}']`) as HTMLElement;\n  } else if (cell.type === 'pending') {\n    // pending skeletons case\n    return rootElement.querySelector(`[data-oj-table-pending-cell='${tableId}']`) as HTMLElement;\n  } else if (cell.type === 'loading') {\n    // loading skeletons case\n    return rootElement.querySelector(`[data-oj-table-loading-cell='${tableId}']`) as HTMLElement;\n  } else if (cell.type === 'loadMore') {\n    // loadMore skeletons case\n    return rootElement.querySelector(`[data-oj-table-load-more-cell='${tableId}']`) as HTMLElement;\n  }\n  return undefined;\n}\n\n/**\n * Helper method to get the top scroller offset of the Table\n */\nexport const getScrollerTopOffset = (rootElement: HTMLElement, tableId: string) => {\n  const headerRowElement = rootElement.querySelector(\n    `[data-oj-table-header-row='${tableId}']`\n  ) as HTMLElement;\n  return headerRowElement != null ? headerRowElement.getBoundingClientRect().height : 0;\n};\n\n/**\n * Helper method to get the bottom scroller offset of the Table\n */\nexport const getScrollerBottomOffset = (rootElement: HTMLElement, tableId: string) => {\n  const footerRowElement = rootElement.querySelector(\n    `[data-oj-table-footer-row='${tableId}']`\n  ) as HTMLElement;\n  return footerRowElement != null ? footerRowElement.getBoundingClientRect().height : 0;\n};\n\n/**\n * Returns the key of the first focusable row in the Table\n */\nexport const getFirstFocusableRowKey = <K>(rootElement: HTMLElement, tableId: string) => {\n  const firstRowElement = rootElement.querySelector(`[data-oj-table-data-row='${tableId}']`);\n  if (firstRowElement != null) {\n    return getRowKey<K>(firstRowElement as HTMLElement);\n  }\n  return undefined;\n};\n\n/**\n * Returns the key of the last focusable row in the Table\n */\nexport const getLastFocusableRowKey = <K>(rootElement: HTMLElement, tableId: string) => {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  const rowCount = rowElements.length;\n  if (rowCount > 0) {\n    return getRowKey(rowElements[rowCount - 1] as HTMLElement) as K;\n  }\n  return undefined;\n};\n\n/**\n * Returns the cell definition of the first rendered cell in the Table\n */\nexport const getFirstFocusableCell = <K extends string | number, C extends string>(\n  rootElement: HTMLElement,\n  tableId: string\n): ActiveCell<K, C> | undefined => {\n  const firstCellElement = rootElement.querySelector(\n    `[data-oj-table-focusable='${tableId}']`\n  ) as HTMLElement;\n  if (firstCellElement != null) {\n    const firstCellType = getCellType(firstCellElement);\n    if (firstCellType === 'header' || firstCellType === 'footer') {\n      return { columnKey: getColumnKey<C>(firstCellElement), type: firstCellType };\n    } else if (firstCellType === 'noData') {\n      return { type: 'noData' };\n    }\n    return {\n      rowKey: keyExtractor<K>(firstCellElement, `[data-oj-table-data-row='${tableId}']`)!,\n      columnKey: getColumnKey<C>(firstCellElement),\n      type: 'data'\n    };\n  }\n  return undefined;\n};\n\n/**\n * Helper function to get the first or last column key.\n */\nexport const getBoundaryColumnKey = <K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  isFirst: boolean\n) => {\n  if (columnsArray.length > 0) {\n    return isFirst ? columnsArray[0].key : columnsArray[columnsArray.length - 1].key;\n  }\n  return undefined;\n};\n\n/**\n * Helper method to get the 'pending' layout cell\n */\nexport const getPendingLayoutCellElement = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelector(`[data-oj-table-pending-cell='${tableId}']`) as HTMLElement;\n};\n\n/**\n * Helper method to get the 'noData' cell\n */\nexport const getNoDataCellElement = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelector(`[data-oj-table-nodata-cell='${tableId}']`) as HTMLElement;\n};\n\n/**\n * Helper method to determine if the 'loading' cell is present in the Table\n */\nexport const hasLoadingCell = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelector(`[data-oj-table-loading-cell='${tableId}']`) != null;\n};\n\n/**\n * Helper method to determine if the no data cell is present in the Table\n */\nexport const hasNoDataCell = (rootElement: HTMLElement, tableId: string) => {\n  return getNoDataCellElement(rootElement, tableId) != null;\n};\n\n/**\n * Helper method to determine if footer cells are present in the Table\n */\nexport const hasFooterCells = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelectorAll(`[data-oj-table-footer-row='${tableId}']`).length > 0;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { getCellType, getElementFromCell, logicalCellExtractor } from './TableDomUtils';\nimport { preventBrowserTooltipStyle } from '../themes/Table.css';\nimport { ActiveCell, TableColumn } from '../Table';\nimport { Cell } from '../../UNSAFE_TableView';\n\n/**\n * Helper method to determine if a given cell contains truncated text.\n */\nexport const hasTruncatedText = (cellElement: HTMLElement) => {\n  if (cellElement.getAttribute('data-oj-table-tooltip') !== 'enabled') {\n    return false;\n  }\n  const innerText = String(cellElement.innerText).trim();\n  if (innerText === '') {\n    return false;\n  }\n\n  const walker = document.createTreeWalker(cellElement, NodeFilter.SHOW_TEXT);\n  while (walker.nextNode()) {\n    const range = new Range();\n    const textNode = walker.currentNode;\n    range.selectNodeContents(textNode);\n    const untruncatedTextLength = range.getBoundingClientRect().width;\n\n    let firstParent = true;\n    let parentElement = textNode.parentElement;\n    while (parentElement != null) {\n      const parentStyles = getComputedStyle(parentElement);\n      if (firstParent) {\n        // only verify truncation status of 'visible' text nodes\n        if (untruncatedTextLength === 0 || parentStyles.visibility === 'hidden') {\n          break;\n        }\n        firstParent = false;\n      }\n      const padding = parseFloat(parentStyles.paddingLeft) + parseFloat(parentStyles.paddingRight);\n      const border = parseFloat(parentStyles.borderLeft) + parseFloat(parentStyles.borderRight);\n      const renderedTextLength = parentElement.getBoundingClientRect().width - padding - border;\n\n      // ensure at least 0.015px difference as browser zoom levels cause false positives due to rounding\n      // smaller than that value (0.01 for example) causes unnecessary tooltips to be shown on headers\n      // larger than that value (0.05 for example) causes actual truncation cases to be missed\n      if (untruncatedTextLength - renderedTextLength > 0.015) {\n        return true;\n      }\n      if (parentElement === cellElement) {\n        break;\n      }\n      parentElement = parentElement.parentElement;\n    }\n  }\n  return false;\n};\n\n/**\n * Helper function to handle updating the Table's tooltip due to a focus navigation gesture.\n */\nexport function handleNavigationTooltipGesture<K, C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  cell: ActiveCell<K, C>,\n  showTooltip: (cell: Cell<K, C>) => void,\n  hideTooltip: (isImmediate?: boolean) => void\n) {\n  hideTooltip(true);\n  if (cell.type === 'data' || cell.type === 'header' || cell.type === 'footer') {\n    const cellElement = getElementFromCell(rootElement, tableId, cell);\n    if (cellElement != null) {\n      showTooltip(cell);\n    }\n  }\n}\n\n/**\n * Helper function to handle updating the Table's tooltip due to a pointer move gesture.\n */\nexport function handleMoveTooltipGesture<K extends string | number, D, C extends string>(\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  event: PointerEvent,\n  showTooltip: (cell: Cell<K, C>) => void,\n  hideTooltip: (isImmediate?: boolean) => void,\n  tooltipId: string\n) {\n  let tooltipShown = false;\n  const targetElement = event.relatedTarget as HTMLElement;\n  if (targetElement != null && targetElement.closest(`#${tooltipId}`) != null) {\n    return;\n  }\n  const cellElement = (event.target as HTMLElement).closest(\n    `[data-oj-table-focusable='${tableId}']`\n  ) as HTMLElement;\n  if (cellElement != null) {\n    const type = getCellType(cellElement);\n    if (type === 'data' || type === 'header' || type === 'footer') {\n      showTooltip(logicalCellExtractor<K, D, C>(cellElement, tableId, columnsArray) as Cell<K, C>);\n      tooltipShown = true;\n    }\n  }\n  if (!tooltipShown) {\n    hideTooltip();\n  }\n}\n\n/**\n * Helper function to handle updating the Table's tooltip due to a pointer leave gesture.\n */\nexport const handleLeaveTableTooltipGesture = (\n  rootElement: HTMLDivElement,\n  event: PointerEvent,\n  hideTooltip: (isImmediate?: boolean) => void,\n  tooltipId: string\n) => {\n  const targetElement = event.relatedTarget as HTMLElement;\n  if (targetElement != null && targetElement.closest(`#${tooltipId}`) != null) {\n    // the pointer 'left' the table, but is only over a cell tooltip - in most cases, we want\n    // to just return here as the pointer is still 'over' the table. however, this can also\n    // occur when the pointer is technically outside of the table's bounds, and in that case\n    // we don't actually want to return as we should clear out our cell tooltip as expected\n    const boundingRect = rootElement.getBoundingClientRect();\n    const isOutOfBounds =\n      event.clientX < boundingRect.left ||\n      event.clientX > boundingRect.right ||\n      event.clientY < boundingRect.top ||\n      event.clientY > boundingRect.bottom;\n    if (!isOutOfBounds) {\n      return;\n    }\n  }\n  hideTooltip();\n};\n\n// Pointer Enter handler for elements that need to prevent default browser tooltips\nconst _pointerEnterHandler = (event: PointerEvent) => {\n  const targetElement = event.target as HTMLElement;\n  targetElement.classList.add(preventBrowserTooltipStyle);\n};\n\n// Pointer Leave handler for elements that need to prevent default browser tooltips\nconst _pointerLeaveHandler = (event: PointerEvent) => {\n  const targetElement = event.target as HTMLElement;\n  targetElement.classList.remove(preventBrowserTooltipStyle);\n};\n\n/*\n * Props that can be spread on elements that need to prevent default browser tooltips\n */\nexport const preventBrowserTooltipProps = {\n  onPointerEnter: _pointerEnterHandler,\n  onPointerLeave: _pointerLeaveHandler\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport {\n  CurrentRowVariant,\n  DataCellPadding,\n  DataCellTooltip,\n  TableRendererContext,\n  TableRowContext\n} from '../UNSAFE_TableView';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { getDataCellClassArray } from './utils/TableThemeUtils';\nimport { preventBrowserTooltipProps } from './utils/TableTooltipUtils';\n\n/**\n * Props for the TableCell Component\n */\nexport type TableCellProps<K, D, C> = {\n  tableId: string;\n  rowData: D;\n  columnKey: C;\n  columnIndex: number;\n  rowKey: K;\n  rowIndex: number;\n  isFinalRowIndex: boolean;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  hasFooters: boolean;\n  hasVerticalUnderflow: boolean;\n  hasMore: boolean;\n  isRowSelected: boolean;\n  isPreviousRowSelected: boolean;\n  isColumnSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  isRowHeader: boolean;\n  isRowSelectionEnabled: boolean;\n  isRowSingleSelection: boolean;\n  applyActiveStyle: boolean;\n  applyHoverStyle: boolean;\n  applyPseudoHoverStyle: boolean;\n  field?: keyof D;\n  stickyColumn?: 'enabled' | 'disabled';\n  renderer?: (context: TableRendererContext<K, D, C>) => ComponentChildren;\n  selectorRenderer?: () => ComponentChildren;\n  variant?: CurrentRowVariant;\n  padding?: DataCellPadding<K, D>;\n  tooltip?: DataCellTooltip<K, D>;\n  horizontalAlignment?: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment?: 'top' | 'center' | 'bottom';\n};\n\nfunction _defaultCellRenderer<K, D, C>({ rowData, field }: TableRendererContext<K, D, C>) {\n  return field != null ? String(rowData[field]) : undefined;\n}\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableCell<K, D, C>({\n  tableId,\n  rowData,\n  field,\n  columnKey,\n  columnIndex,\n  rowKey,\n  rowIndex,\n  isFinalRowIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  hasFooters,\n  hasVerticalUnderflow,\n  hasMore,\n  isRowSelected,\n  isPreviousRowSelected,\n  isColumnSelected,\n  isPreviousColumnSelected,\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  isRowHeader,\n  stickyColumn = 'disabled',\n  renderer = _defaultCellRenderer,\n  selectorRenderer,\n  isRowSelectionEnabled,\n  isRowSingleSelection,\n  variant,\n  applyActiveStyle,\n  applyHoverStyle,\n  applyPseudoHoverStyle,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl,\n  isHighContrast,\n  padding,\n  tooltip,\n  horizontalAlignment = 'start',\n  verticalAlignment = 'center'\n}: TableCellProps<K, D, C>) {\n  const browser = getClientHints().browser;\n\n  const rowContext: TableRowContext<K, D> = { key: rowKey, data: rowData };\n  const columnPadding = typeof padding === 'function' ? padding(rowContext) : padding;\n  const columnTooltip = typeof tooltip === 'function' ? tooltip(rowContext) : tooltip;\n  const supportsDefaultTooltip = columnTooltip !== 'disabled';\n  const hasLastHorizontalGridline =\n    hasHorizontalGridlines && (hasMore || hasVerticalUnderflow || !hasFooters);\n\n  const cellClasses = classNames(\n    getDataCellClassArray({\n      isFirstColumnIndex: columnIndex === 0,\n      isFinalColumnIndex,\n      isFirstRowIndex: rowIndex === 0,\n      isFinalRowIndex,\n      hasVerticalGridlines,\n      hasHorizontalGridlines,\n      hasLastHorizontalGridline,\n      isRowSelected,\n      isPreviousRowSelected,\n      isColumnSelected,\n      isPreviousColumnSelected,\n      isShowFocusRing,\n      isSticky: stickyColumn === 'enabled',\n      isRowSelectionEnabled,\n      isRowSingleSelection,\n      isActive: applyActiveStyle,\n      isHover: applyHoverStyle,\n      isPseudoHover: applyPseudoHoverStyle,\n      isStickyStartEdge,\n      isStickyEndEdge,\n      isRtl,\n      isHighContrast,\n      horizontalAlignment,\n      verticalAlignment,\n      variant,\n      padding: columnPadding\n    })\n  );\n\n  const cellRendererProps = {\n    rowData: rowData,\n    rowKey: rowKey,\n    field: field,\n    columnKey: columnKey,\n    selector: selectorRenderer,\n    isTabbable: isTabbableMode\n  };\n\n  return (\n    <td\n      aria-colindex={columnIndex + 1}\n      class={cellClasses}\n      tabIndex={hasTabIndex ? 0 : -1}\n      role={isRowHeader ? 'rowheader' : 'gridcell'}\n      data-oj-cell-type={'data'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-data-cell={tableId}\n      data-oj-table-tooltip={supportsDefaultTooltip ? 'enabled' : undefined}\n      {...(supportsDefaultTooltip && browser === 'safari' ? preventBrowserTooltipProps : {})}\n      {...(isColumnSelected ? { 'aria-selected': true } : {})}>\n      {renderer(cellRendererProps)}\n    </td>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { memo } from 'preact/compat';\nimport { SelectionDetail } from '../UNSAFE_Collection';\nimport { Selector } from '../UNSAFE_Selector';\nimport { CurrentRowVariant, TableSelectionDetail } from '../UNSAFE_TableView';\nimport { tableRowStyles, tableRowStylesHC } from './themes/TableRowStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey, isSameKey } from '../utils/UNSAFE_keys';\nimport { TableColumn } from './Table';\nimport { TableCell } from './TableCell';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\n\n/**\n * Props for the TableRow Component\n */\nexport type TableRowProps<K, D, C> = {\n  tableId: string;\n  rowKey: K;\n  rowData: D;\n  rowIndex: number;\n  isFinalRow: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  rowHeaderColumnKeys: Set<C>;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  hasFooters: boolean;\n  hasVerticalUnderflow: boolean;\n  hasMore: boolean;\n  isSelected: boolean;\n  isPreviousSelected: boolean;\n  isRowSelectionEnabled: boolean;\n  isSingleRowSelectionEnabled: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  selectedRowKeys?: Keys<K>;\n  isShowFocusRing: boolean;\n  activeColumnKey?: C;\n  isTabbableMode: boolean;\n  selectedColumnKeys?: Keys<C>;\n  variant?: CurrentRowVariant;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a single row in Table.\n */\nfunction TableRow<K, D, C>({\n  tableId,\n  rowKey,\n  rowData,\n  rowIndex,\n  isFinalRow,\n  columnsArray,\n  rowHeaderColumnKeys,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  hasFooters,\n  hasVerticalUnderflow,\n  hasMore,\n  isSelected,\n  isPreviousSelected,\n  isRowSelectionEnabled,\n  isSingleRowSelectionEnabled,\n  selectedRowKeys = { all: false, keys: new Set<K>() },\n  isShowFocusRing,\n  activeColumnKey,\n  isTabbableMode,\n  selectedColumnKeys = { all: false, keys: new Set<C>() },\n  variant,\n  disabledInteractionKeys,\n  onSelectionChange,\n  startStickyEdge,\n  endStickyEdge,\n  isRtl,\n  isHighContrast\n}: TableRowProps<K, D, C>) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle({ disabledKeys: disabledInteractionKeys });\n\n  const rowStyles = isHighContrast ? tableRowStylesHC : tableRowStyles;\n  const classArray = [rowStyles.base, isFinalRow ? rowStyles.lastRowHeight : rowStyles.rowHeight];\n  const classes = classNames(classArray);\n\n  const accessibleRowName = (rowIndex + 2).toString();\n  const handleRowSelectorChange = (detail: SelectionDetail<K>) => {\n    if (onSelectionChange != null) {\n      onSelectionChange(\n        {\n          value: {\n            row: detail.value,\n            column: { all: false, keys: new Set<C>() }\n          },\n          target: detail.target\n        },\n        false\n      );\n    }\n  };\n  const selectorRenderer =\n    isRowSelectionEnabled && !isSingleRowSelectionEnabled\n      ? () => {\n          // conversion from 0-based index and adding the header row as it is always rendered\n          return (\n            <Selector\n              aria-label={translations.collection_selectRow({ ROW_NAME: accessibleRowName })}\n              onChange={handleRowSelectorChange}\n              rowKey={rowKey}\n              selectedKeys={selectedRowKeys}\n            />\n          );\n        }\n      : undefined;\n\n  let isPreviousColumnSelected = false;\n  return (\n    <tr\n      aria-rowindex={rowIndex + 2}\n      class={classes}\n      role={'row'}\n      data-oj-key={rowKey}\n      data-oj-table-data-row={tableId}\n      {...(isRowSelectionEnabled\n        ? isSelected\n          ? { 'aria-selected': true }\n          : { 'aria-selected': false }\n        : {})}\n      {...(typeof rowKey === 'number' && { 'data-oj-key-type': 'number' })}\n      {...(isRowSelectionEnabled && interactionProps)}>\n      {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n        const columnKey = column.key;\n        const isColumnSelected = containsKey(selectedColumnKeys, columnKey);\n        const isActive = columnKey === activeColumnKey;\n        const hasTabIndex = isActive && !isTabbableMode;\n        const cellProps = {\n          tableId: tableId,\n          rowData: rowData,\n          field: column.value.field,\n          stickyColumn: column.value.sticky,\n          columnKey: columnKey,\n          columnIndex: columnIndex,\n          rowKey: rowKey,\n          rowIndex: rowIndex,\n          isFinalRowIndex: isFinalRow,\n          isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n          hasVerticalGridlines: hasVerticalGridlines,\n          hasHorizontalGridlines: hasHorizontalGridlines,\n          hasFooters: hasFooters,\n          hasVerticalUnderflow: hasVerticalUnderflow,\n          hasMore: hasMore,\n          isRowSelected: isSelected,\n          isPreviousRowSelected: isPreviousSelected,\n          isColumnSelected: isColumnSelected,\n          isPreviousColumnSelected: isPreviousColumnSelected,\n          isShowFocusRing: isShowFocusRing && isActive,\n          hasTabIndex: hasTabIndex,\n          isTabbableMode: isTabbableMode,\n          isRowHeader: rowHeaderColumnKeys.has(column.key),\n          renderer: column.value.renderer,\n          selectorRenderer: selectorRenderer,\n          isRowSelectionEnabled: isRowSelectionEnabled,\n          variant: variant,\n          isRowSingleSelection: isSingleRowSelectionEnabled,\n          applyActiveStyle: applyActiveStyle,\n          applyHoverStyle: applyHoverStyle,\n          applyPseudoHoverStyle: applyPseudoHoverStyle,\n          isStickyStartEdge: columnIndex === startStickyEdge,\n          isStickyEndEdge: columnIndex === endStickyEdge,\n          isRtl: isRtl,\n          isHighContrast: isHighContrast,\n          padding: column.value.padding,\n          tooltip: column.value.tooltip,\n          horizontalAlignment:\n            column.value.alignment?.horizontal != null\n              ? column.value.alignment.horizontal\n              : column.value.horizontalAlignment,\n          verticalAlignment: column.value.alignment?.vertical\n        };\n        isPreviousColumnSelected = isColumnSelected;\n        return <TableCell {...cellProps} />;\n      })}\n    </tr>\n  );\n}\n\nconst _areStringSetsEquivalent = (set1?: Set<string>, set2?: Set<string>) => {\n  if (set1 == null) {\n    return set2 == null;\n  }\n  if (set2 == null) {\n    return false;\n  }\n  return set1.size === set2.size && [...set1].every((x) => set2.has(x));\n};\n\nconst _areColumnsArraysEquivalent = (\n  columnsArray1: TableColumn<string | number, any, string>[],\n  columnsArray2: TableColumn<string | number, any, string>[]\n) => {\n  if (columnsArray1.length === columnsArray2.length) {\n    for (let i = 0; i < columnsArray1.length; i++) {\n      if (\n        columnsArray1[i].key !== columnsArray2[i].key ||\n        columnsArray1[i].value !== columnsArray2[i].value\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\nexport const MemoizeTableRow = memo(TableRow, (prev: any, next: any) => {\n  if (prev && next) {\n    return (\n      prev.tableId === next.tableId &&\n      prev.rowKey === next.rowKey &&\n      prev.rowData === next.rowData &&\n      prev.rowIndex === next.rowIndex &&\n      prev.isFinalRow === next.isFinalRow &&\n      _areColumnsArraysEquivalent(prev.columnsArray, next.columnsArray) &&\n      prev.hasHorizontalGridlines === next.hasHorizontalGridlines &&\n      prev.hasVerticalGridlines === next.hasVerticalGridlines &&\n      (!next.isFinalRow ||\n        (prev.hasFooters === next.hasFooters &&\n          prev.hasVerticalUnderflow === next.hasVerticalUnderflow &&\n          prev.hasMore === next.hasMore)) &&\n      _areStringSetsEquivalent(prev.rowHeaderColumnKeys, next.rowHeaderColumnKeys) &&\n      prev.isSelected === next.isSelected &&\n      prev.isPreviousSelected === next.isPreviousSelected &&\n      prev.isRowSelectionEnabled === next.isRowSelectionEnabled &&\n      prev.isSingleRowSelectionEnabled === next.isSingleRowSelectionEnabled &&\n      (prev.isRowSelectionEnabled && !prev.isSingleRowSelectionEnabled\n        ? isSameKey(prev.selectedRowKeys, next.selectedRowKeys)\n        : true) &&\n      isSameKey(prev.selectedColumnKeys, next.selectedColumnKeys) &&\n      prev.isShowFocusRing === next.isShowFocusRing &&\n      prev.activeColumnKey === next.activeColumnKey &&\n      prev.isTabbableMode === next.isTabbableMode &&\n      prev.variant === next.variant &&\n      prev.onSelectionChange === next.onSelectionChange &&\n      prev.startStickyEdge === next.startStickyEdge &&\n      prev.endStickyEdge === next.endStickyEdge &&\n      prev.isRtl === next.isRtl &&\n      prev.isHighContrast === next.isHighContrast &&\n      prev.disabledInteractionKeys === next.disabledInteractionKeys\n    );\n  }\n  return false;\n});\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { ComponentChildren, RefObject } from 'preact';\nimport { TableNoDataRendererContext } from '../UNSAFE_TableView';\nimport { useLayoutEffect } from 'preact/hooks';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { tableRowStyles } from './themes/TableRowStyles.css';\nimport { TableNoDataVariantOptions } from './themes/TableNoDataStyles.css';\nimport { TableNoDataRedwoodTheme } from './themes/redwood/TableNoDataTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\n\n/**\n * Props for the TableCell Component\n */\nexport type TableNoDataProps = {\n  rootRef: RefObject<HTMLDivElement>;\n  tableId: string;\n  columnsCount: number;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  ariaRowIndex: number;\n  renderer?: (context: TableNoDataRendererContext) => ComponentChildren;\n};\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableNoData({\n  rootRef,\n  tableId,\n  columnsCount,\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  ariaRowIndex,\n  renderer\n}: TableNoDataProps) {\n  const browser = getClientHints().browser;\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const rowClasses = classNames([tableRowStyles.base]);\n\n  const { classes: themeClasses } = useComponentTheme<TableNoDataVariantOptions>(\n    TableNoDataRedwoodTheme,\n    {\n      defaultRenderer: renderer == null ? 'isDefaultRenderer' : 'notDefaultRenderer',\n      showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing'\n    }\n  );\n\n  const cellClasses = classNames([themeClasses]);\n\n  function defaultContentRenderer() {\n    return translations.collection_noData();\n  }\n\n  const contentRenderer = renderer != null ? renderer : defaultContentRenderer;\n\n  // in firefox, table element heights are not stretched unless explicitly set in some cases\n  useLayoutEffect(() => {\n    if (browser === 'firefox') {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        const tableBodyElement = rootElement.querySelector(\n          `[data-oj-table-body='${tableId}']`\n        ) as HTMLElement;\n        const noDataElement = rootElement.querySelector(\n          `[data-oj-table-nodata-cell='${tableId}']`\n        ) as HTMLElement;\n        if (tableBodyElement != null && noDataElement != null) {\n          noDataElement.style.height = '';\n          noDataElement.style.height = `${tableBodyElement.getBoundingClientRect().height}px`;\n        }\n      }\n    }\n  });\n\n  return (\n    <tr aria-rowindex={ariaRowIndex} class={rowClasses} role={'row'}>\n      <td\n        aria-colindex={1}\n        class={cellClasses}\n        style={browser !== 'firefox' ? 'height: 100%;' : undefined}\n        tabIndex={hasTabIndex ? 0 : -1}\n        role={'gridcell'}\n        colSpan={columnsCount}\n        data-oj-cell-type={'noData'}\n        data-oj-table-focusable={tableId}\n        data-oj-table-nodata-cell={tableId}>\n        {contentRenderer({ isTabbable: isTabbableMode })}\n      </td>\n    </tr>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Fragment, type RefObject } from 'preact';\nimport { useCallback } from 'preact/hooks';\nimport { LoadMoreCollection } from '../PRIVATE_LoadMoreCollection';\nimport { ActiveCell, TableColumn, TableData, ViewportInfo } from './Table';\nimport { TableSkeletonRow } from './TableSkeletonRow';\nimport { MemoizeTableRow } from './TableRow';\nimport { ItemContext } from '../UNSAFE_Collection';\nimport {\n  CurrentRowVariant,\n  TableNoDataRendererContext,\n  TableRowContext,\n  TableSelectionDetail\n} from '../UNSAFE_TableView';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { backgroundStyles } from './themes/Table.css';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableNoData } from './TableNoData';\nimport { ComponentChildren } from 'preact';\n\n/**\n * Props for the TableBody Component\n */\nexport type TableBodyProps<K, D, C> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  isValidRender: boolean;\n  getAccessibleRowHeaders: (context: TableRowContext<K, D>) => Set<C>;\n  tableData: TableData<K, D>[];\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  hasFooters: boolean;\n  hasVerticalUnderflow: boolean;\n  isShowFocusRing: boolean;\n  isTabbableMode: boolean;\n  hasMore: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  onLoadMore: () => void;\n  activeCell?: ActiveCell<K, C>;\n  currentRowKey?: K;\n  currentRowVariant?: CurrentRowVariant;\n  selected: { row?: Keys<K>; column?: Keys<C> };\n  isRowSelectionEnabled: boolean;\n  isSingleRowSelectionEnabled: boolean;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  noDataRenderer?: (context: TableNoDataRendererContext) => ComponentChildren;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableBody<K, D, C>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  isValidRender,\n  getAccessibleRowHeaders,\n  tableData,\n  columnsArray,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  hasFooters,\n  hasVerticalUnderflow,\n  isShowFocusRing,\n  isTabbableMode,\n  hasMore,\n  onLoadMore,\n  activeCell,\n  currentRowKey,\n  currentRowVariant,\n  selected,\n  isRowSelectionEnabled,\n  isSingleRowSelectionEnabled,\n  disabledInteractionKeys,\n  onSelectionChange,\n  noDataRenderer,\n  startStickyEdge,\n  endStickyEdge,\n  isRtl,\n  isHighContrast\n}: TableBodyProps<K, D, C>) {\n  const browser = getClientHints().browser;\n\n  // returns a TableRowContext based on ItemContext (added key)\n  const getRowContext = useCallback((context: ItemContext<TableData<K, D>>) => {\n    return {\n      index: context.index,\n      data: context.data.data,\n      key: context.data.metadata\n    };\n  }, []);\n\n  let isPreviousSelected = false;\n  const collectionChildrenFunc = (context: ItemContext<TableData<K, D>>) => {\n    const tableRowContext = getRowContext(context);\n    const rowKey = tableRowContext.key;\n    const containsActiveCell = activeCell?.rowKey === rowKey;\n    const activeColumnKey = containsActiveCell ? activeCell.columnKey : undefined;\n    const isSelected = containsKey(selected.row, rowKey);\n    const rowProps = {\n      tableId: tableId,\n      columnsArray: columnsArray,\n      rowHeaderColumnKeys: getAccessibleRowHeaders(tableRowContext),\n      hasVerticalGridlines: hasVerticalGridlines,\n      hasHorizontalGridlines: hasHorizontalGridlines,\n      hasFooters: hasFooters,\n      hasVerticalUnderflow: hasVerticalUnderflow,\n      hasMore: hasMore,\n      isSelected: isSelected,\n      isPreviousSelected: isPreviousSelected,\n      disabledInteractionKeys: disabledInteractionKeys,\n      onSelectionChange: onSelectionChange,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      isSingleRowSelectionEnabled: isSingleRowSelectionEnabled,\n      variant: currentRowKey === rowKey ? currentRowVariant : 'none',\n      isShowFocusRing: isShowFocusRing && containsActiveCell,\n      activeColumnKey: activeColumnKey,\n      isTabbableMode: isTabbableMode,\n      selectedRowKeys: selected.row,\n      selectedColumnKeys: selected.column,\n      rowIndex: tableRowContext.index,\n      rowKey: rowKey,\n      rowData: tableRowContext.data,\n      isFinalRow: tableRowContext.index === tableData.length - 1,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isRtl: isRtl,\n      isHighContrast: isHighContrast\n    };\n    isPreviousSelected = isSelected;\n    return <MemoizeTableRow {...rowProps} />;\n  };\n\n  const getNoDataProps = () => {\n    const isActive = activeCell?.type === 'noData';\n    const hasTabIndex = isActive && !isTabbableMode;\n    return {\n      rootRef: rootRef,\n      tableId: tableId,\n      columnsCount: columnsArray.length,\n      isShowFocusRing: isShowFocusRing && isActive,\n      hasTabIndex: hasTabIndex,\n      isTabbableMode: isTabbableMode,\n      ariaRowIndex: isValidRender ? 2 : 1,\n      renderer: isValidRender ? noDataRenderer : undefined\n    };\n  };\n\n  const isShowEmptyLoading = tableData.length === 0 && hasMore;\n  const isShowNoData = tableData.length === 0 && !hasMore;\n  const loadMoreViewportConfig = {\n    scroller: () => viewportInfo.viewportConfig.scroller().current\n  };\n\n  return (\n    <tbody class={backgroundStyles.inherit} role={'presentation'} data-oj-table-body={tableId}>\n      {isShowNoData || !isValidRender ? (\n        <TableNoData {...getNoDataProps()} />\n      ) : (\n        <Fragment>\n          <LoadMoreCollection<TableData<K, D>>\n            data={tableData}\n            loadMoreIndicator={\n              <TableSkeletonRow\n                tableId={tableId}\n                hasTabIndex={\n                  isShowEmptyLoading\n                    ? activeCell?.type === 'loading'\n                    : activeCell?.type === 'loadMore'\n                }\n                colspan={columnsArray.length}\n                isLoadMore={!isShowEmptyLoading}\n                isShowFocusRing={\n                  isShowFocusRing &&\n                  (isShowEmptyLoading\n                    ? activeCell?.type === 'loading'\n                    : activeCell?.type === 'loadMore')\n                }\n                isHighContrast={isHighContrast}\n              />\n            }\n            hasMore={hasMore}\n            onLoadMore={onLoadMore}\n            viewportConfig={loadMoreViewportConfig}>\n            {collectionChildrenFunc}\n          </LoadMoreCollection>\n          <tr\n            style={browser !== 'firefox' ? 'height: 100%;' : undefined}\n            role={'presentation'}\n            data-oj-table-spacer-row={tableId}\n          />\n        </Fragment>\n      )}\n    </tbody>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { useCallback } from 'preact/hooks';\nimport { SelectionDetail } from '../UNSAFE_Collection';\nimport { SelectorAll } from '../UNSAFE_SelectorAll';\nimport {\n  CellPadding,\n  TableHeaderRendererContext,\n  TableSelectionDetail,\n  SortCriterionDetail\n} from '../UNSAFE_TableView';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, isSameKey } from '../utils/UNSAFE_keys';\nimport {\n  justifyContentStyles,\n  tableHeaderCellTextStyles,\n  tableHeaderSortContainerStyles,\n  tableHeaderSortIconStyles\n} from './themes/Table.css';\nimport { tableHeaderCellStyles } from './themes/TableHeaderCellStyles.css';\nimport { getHeaderFooterCellClassArray } from './utils/TableThemeUtils';\nimport { preventBrowserTooltipProps } from './utils/TableTooltipUtils';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport { EmbeddedIconButton } from '../PRIVATE_EmbeddedIconButton';\nimport { SortAscendingIcon } from '../PRIVATE_ThemedIcons/SortAscendingIcon';\nimport { SortDescendingIcon } from '../PRIVATE_ThemedIcons/SortDescendingIcon';\n\n/**\n * Props for the TableHeaderCell Component\n */\nexport type TableHeaderCellProps<K, C> = {\n  tableId: string;\n  columnKey: C;\n  columnIndex: number;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isColumnSelectionEnabled: boolean;\n  isSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isColumnSelectable: boolean;\n  isRowSelectionEnabled: boolean;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  headerText?: string;\n  selectedRowKeys?: Keys<K>;\n  stickyTopOffset?: number;\n  stickyColumn?: 'enabled' | 'disabled';\n  renderer?: (context: TableHeaderRendererContext<C>) => ComponentChildren;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  isShowSortIcon: boolean;\n  sortable?: 'enabled' | 'disabled';\n  sortDirection?: 'ascending' | 'descending';\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  padding?: CellPadding;\n  tooltip?: 'enabled' | 'disabled';\n  disabledInteractionKeys?: ('enter' | 'space')[];\n  horizontalAlignment?: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment?: 'top' | 'center' | 'bottom';\n};\n\n/**\n * The internal component used to render a single cell in a TableHeaderRow.\n */\nexport function TableHeaderCell<K, C>({\n  tableId,\n  columnKey,\n  columnIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  isColumnSelectionEnabled,\n  isSelected,\n  isPreviousColumnSelected,\n  isColumnSelectable,\n  isRowSelectionEnabled,\n  selectedRowKeys = { all: false, keys: new Set<K>() },\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  headerText,\n  stickyTopOffset = 0,\n  stickyColumn = 'disabled',\n  renderer,\n  disabledInteractionKeys,\n  onSelectionChange,\n  isShowSortIcon,\n  sortable = 'disabled',\n  sortDirection,\n  onSortCriterionChange,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl,\n  isHighContrast,\n  padding,\n  tooltip,\n  horizontalAlignment = 'start',\n  verticalAlignment = 'center'\n}: TableHeaderCellProps<K, C>) {\n  const browser = getClientHints().browser;\n  const supportsDefaultTooltip = tooltip !== 'disabled';\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle({ disabledKeys: disabledInteractionKeys });\n\n  const cellClasses = classNames(\n    getHeaderFooterCellClassArray({\n      isHeader: true,\n      isActive: applyActiveStyle,\n      isHover: applyHoverStyle,\n      isPseudoHover: applyPseudoHoverStyle,\n      isFirstColumnIndex: columnIndex === 0,\n      isFinalColumnIndex,\n      hasVerticalGridlines,\n      isColumnSelectionEnabled,\n      isSelected,\n      isPreviousColumnSelected,\n      isColumnSelectable,\n      isShowFocusRing,\n      isSticky: stickyColumn === 'enabled',\n      isStickyStartEdge,\n      isStickyEndEdge,\n      isRtl,\n      horizontalAlignment,\n      verticalAlignment,\n      isHighContrast,\n      padding\n    })\n  );\n\n  let selectorAllState: 'all' | 'none' | 'partial' | 'partial-all';\n  if (isSameKey(selectedRowKeys, { all: true, deletedKeys: new Set<K>() })) {\n    selectorAllState = 'all';\n  } else if (isSameKey(selectedRowKeys, { all: false, keys: new Set<K>() })) {\n    selectorAllState = 'none';\n  } else {\n    selectorAllState = 'partial';\n  }\n\n  const handleSelectorChange = (detail: SelectionDetail<K>) => {\n    if (onSelectionChange != null) {\n      onSelectionChange(\n        {\n          value: {\n            row: detail.value,\n            column: { all: false, keys: new Set<C>() }\n          },\n          target: detail.target\n        },\n        false\n      );\n    }\n  };\n\n  const selectorRenderer = isRowSelectionEnabled\n    ? () => (\n        <SelectorAll\n          aria-label={translations.collection_selectAllRows()}\n          onChange={handleSelectorChange}\n          selected={selectorAllState}\n        />\n      )\n    : undefined;\n\n  const handleSortGesture = useCallback(() => {\n    if (onSortCriterionChange != null) {\n      const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';\n      onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);\n    }\n  }, [columnKey, sortDirection, onSortCriterionChange]);\n\n  const iconClassArray = [tableHeaderSortIconStyles.base];\n  if (isShowSortIcon) {\n    iconClassArray.push(tableHeaderSortIconStyles.visible);\n  } else {\n    iconClassArray.push(tableHeaderSortIconStyles.hidden);\n  }\n  const iconClasses = classNames(iconClassArray);\n\n  const sortIconRenderer =\n    sortable === 'enabled' || sortDirection != null\n      ? () => (\n          <div class={iconClasses}>\n            <EmbeddedIconButton\n              aria-label={\n                sortable === 'enabled'\n                  ? translations.collection_sortEnabled()\n                  : translations.collection_sortDisabled()\n              }\n              isDisabled={sortable !== 'enabled'}\n              onAction={handleSortGesture}>\n              {sortDirection === 'descending' ? <SortDescendingIcon /> : <SortAscendingIcon />}\n            </EmbeddedIconButton>\n          </div>\n        )\n      : undefined;\n\n  const headerCellRendererProps = {\n    key: columnKey,\n    headerText: headerText,\n    sortable: sortable,\n    sortDirection: sortDirection,\n    selector: selectorRenderer,\n    sortControl: sortIconRenderer,\n    isTabbable: isTabbableMode\n  };\n\n  const getHeaderCellRenderer = useCallback(() => {\n    if (renderer != null) {\n      return renderer;\n    }\n    return ({ headerText, sortControl }: TableHeaderRendererContext<C>) => {\n      const text =\n        headerText != null ? (\n          <div class={tableHeaderCellTextStyles.base}>\n            <span class={tableHeaderCellStyles.defaultRendererSpan}>{headerText}</span>\n          </div>\n        ) : undefined;\n      if (sortControl != null) {\n        const isIconFirst =\n          horizontalAlignment === 'end' ||\n          (!isRtl && horizontalAlignment === 'right') ||\n          (isRtl && horizontalAlignment === 'left');\n\n        const containerClasses = classNames([\n          tableHeaderSortContainerStyles.base,\n          justifyContentStyles[horizontalAlignment]\n        ]);\n        return (\n          <div class={containerClasses}>\n            {isIconFirst && sortControl()}\n            {text}\n            {!isIconFirst && sortControl()}\n          </div>\n        );\n      }\n      return text;\n    };\n  }, [renderer, horizontalAlignment, isRtl]);\n\n  const getAriaSelected = () => {\n    if (isSelected) {\n      return { 'aria-selected': true };\n    }\n    return isColumnSelectable ? { 'aria-selected': false } : undefined;\n  };\n\n  const getAriaSort = () => {\n    if (sortDirection === 'ascending' || sortDirection === 'descending') {\n      return { 'aria-sort': sortDirection };\n    }\n    return undefined;\n  };\n\n  return (\n    <th\n      aria-colindex={columnIndex + 1}\n      {...getAriaSelected()}\n      {...getAriaSort()}\n      class={cellClasses}\n      style={`top:${stickyTopOffset}px;`}\n      tabIndex={hasTabIndex ? 0 : -1}\n      role={'columnheader'}\n      data-oj-cell-type={'header'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-header-cell={tableId}\n      data-oj-table-tooltip={supportsDefaultTooltip ? 'enabled' : undefined}\n      {...(supportsDefaultTooltip && browser === 'safari' ? preventBrowserTooltipProps : {})}\n      {...(isColumnSelectable && interactionProps)}>\n      {getHeaderCellRenderer()(headerCellRendererProps)}\n    </th>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableSelectionDetail, SortCriterionDetail } from '../UNSAFE_TableView';\nimport { TableColumn } from './Table';\nimport { TableHeaderCell } from './TableHeaderCell';\nimport { backgroundStyles, tableHeaderRowStyles } from './themes/Table.css';\n\n/**\n * Props for the TableHeader Component\n */\nexport type TableHeaderProps<K, D, C> = {\n  tableId: string;\n  isRendered: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  activeKey?: C;\n  isTabbableMode: boolean;\n  isShowFocusRing: boolean;\n  selectedColumnKeys?: Keys<C>;\n  selectedRowKeys?: Keys<K>;\n  isColumnSelectionEnabled: boolean;\n  isRowSelectionEnabled: boolean;\n  isResizeHover: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  isForceSortIcons: boolean;\n  hoverColumnKey?: C;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  stickyTopOffset?: number;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a header region in Table.\n */\nexport function TableHeader<K, D, C>({\n  tableId,\n  isRendered,\n  columnsArray,\n  hasVerticalGridlines,\n  activeKey,\n  isTabbableMode,\n  isShowFocusRing,\n  selectedColumnKeys,\n  selectedRowKeys,\n  isColumnSelectionEnabled,\n  isRowSelectionEnabled,\n  disabledInteractionKeys,\n  onSelectionChange,\n  isForceSortIcons,\n  hoverColumnKey,\n  sortCriterion,\n  onSortCriterionChange,\n  stickyTopOffset,\n  startStickyEdge,\n  endStickyEdge,\n  isResizeHover,\n  isRtl,\n  isHighContrast\n}: TableHeaderProps<K, D, C>) {\n  const rowClasses = classNames([tableHeaderRowStyles.base]);\n\n  const getStyle = () => {\n    return isResizeHover ? 'cursor: col-resize;' : '';\n  };\n\n  let isPreviousColumnSelected = false;\n  return isRendered ? (\n    <thead class={backgroundStyles.inherit} role={'presentation'}>\n      <tr\n        aria-rowindex={1}\n        class={rowClasses}\n        role={'row'}\n        style={getStyle()}\n        data-oj-table-header-row={tableId}>\n        {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n          const columnKey = column.key;\n          let sortDirection;\n          if (sortCriterion != null) {\n            for (const criterion of sortCriterion) {\n              if (criterion.key === columnKey) {\n                sortDirection = criterion.sortDirection;\n                break;\n              }\n            }\n          }\n          const sortable = column.value.sortable;\n          const hasSortIcon = sortable === 'enabled' || sortDirection != null;\n          const isShowSortIcon =\n            hasSortIcon &&\n            (isForceSortIcons || sortDirection != null || hoverColumnKey === columnKey);\n          const isSelected = containsKey(selectedColumnKeys, columnKey);\n          const isActive = columnKey === activeKey;\n          const hasTabIndex = isActive && !isTabbableMode;\n          const headerCellProps = {\n            tableId: tableId,\n            hasVerticalGridlines: hasVerticalGridlines,\n            columnKey: columnKey,\n            columnIndex: columnIndex,\n            isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n            stickyTopOffset: stickyTopOffset,\n            stickyColumn: column.value.sticky,\n            isColumnSelectionEnabled: isColumnSelectionEnabled,\n            isSelected: isSelected,\n            isPreviousColumnSelected: isPreviousColumnSelected,\n            selectedRowKeys: selectedRowKeys,\n            isColumnSelectable: isColumnSelectionEnabled && column.value.selectable !== 'disabled',\n            isRowSelectionEnabled: isRowSelectionEnabled,\n            isShowFocusRing: isShowFocusRing && isActive,\n            hasTabIndex: hasTabIndex,\n            isTabbableMode: isTabbableMode,\n            headerText: column.value.headerText,\n            renderer: column.value.headerRenderer,\n            disabledInteractionKeys: disabledInteractionKeys,\n            onSelectionChange: onSelectionChange,\n            isShowSortIcon: isShowSortIcon,\n            sortable: sortable,\n            sortDirection: sortDirection,\n            onSortCriterionChange: onSortCriterionChange,\n            isStickyStartEdge: columnIndex === startStickyEdge,\n            isStickyEndEdge: columnIndex === endStickyEdge,\n            isRtl: isRtl,\n            isHighContrast: isHighContrast,\n            padding: column.value.headerPadding,\n            tooltip: column.value.headerTooltip,\n            horizontalAlignment:\n              column.value.headerAlignment?.horizontal != null\n                ? column.value.headerAlignment.horizontal\n                : column.value.horizontalAlignment,\n            verticalAlignment: column.value.headerAlignment?.vertical\n          };\n          isPreviousColumnSelected = isSelected;\n          return <TableHeaderCell {...headerCellProps} />;\n        })}\n      </tr>\n    </thead>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { CellPadding, TableFooterRendererContext } from '../UNSAFE_TableView';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { getHeaderFooterCellClassArray } from './utils/TableThemeUtils';\nimport { preventBrowserTooltipProps } from './utils/TableTooltipUtils';\n\n/**\n * Props for the TableFooterCell Component\n */\nexport type TableFooterCellProps<C> = {\n  tableId: string;\n  columnKey: C;\n  columnIndex: number;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isColumnSelectionEnabled: boolean;\n  isSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isColumnSelectable: boolean;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  footerText?: string;\n  stickyBottomOffset?: number;\n  stickyColumn?: 'enabled' | 'disabled';\n  renderer?: (context: TableFooterRendererContext<C>) => ComponentChildren;\n  padding?: CellPadding;\n  tooltip?: 'enabled' | 'disabled';\n  disabledInteractionKeys?: ('enter' | 'space')[];\n  horizontalAlignment?: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment?: 'top' | 'center' | 'bottom';\n};\n\nfunction _defaultFooterCellRenderer<C>({ footerText }: TableFooterRendererContext<C>) {\n  return footerText != null ? footerText : undefined;\n}\n\n/**\n * The internal component used to render a single cell in a TableFooterRow.\n */\nexport function TableFooterCell<C>({\n  tableId,\n  columnKey,\n  columnIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  isColumnSelectionEnabled,\n  isSelected,\n  isPreviousColumnSelected,\n  isColumnSelectable,\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  stickyBottomOffset = 0,\n  stickyColumn = 'disabled',\n  footerText,\n  renderer = _defaultFooterCellRenderer,\n  disabledInteractionKeys,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  isRtl,\n  isHighContrast,\n  padding,\n  tooltip,\n  horizontalAlignment = 'start',\n  verticalAlignment = 'center'\n}: TableFooterCellProps<C>) {\n  const browser = getClientHints().browser;\n  const supportsDefaultTooltip = tooltip !== 'disabled';\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle({ disabledKeys: disabledInteractionKeys });\n\n  const cellClasses = classNames(\n    getHeaderFooterCellClassArray({\n      isHeader: false,\n      isActive: applyActiveStyle,\n      isHover: applyHoverStyle,\n      isPseudoHover: applyPseudoHoverStyle,\n      isFirstColumnIndex: columnIndex === 0,\n      isFinalColumnIndex,\n      hasVerticalGridlines,\n      isColumnSelectionEnabled,\n      isSelected,\n      isPreviousColumnSelected,\n      isColumnSelectable,\n      isShowFocusRing,\n      isSticky: stickyColumn === 'enabled',\n      isStickyStartEdge,\n      isStickyEndEdge,\n      isRtl,\n      horizontalAlignment,\n      verticalAlignment,\n      isHighContrast,\n      padding\n    })\n  );\n\n  const footerCellRendererProps = {\n    key: columnKey,\n    footerText: footerText,\n    isTabbable: isTabbableMode\n  };\n\n  return (\n    <td\n      aria-colindex={columnIndex + 1}\n      {...(isSelected\n        ? { 'aria-selected': true }\n        : isColumnSelectable\n        ? { 'aria-selected': false }\n        : {})}\n      class={cellClasses}\n      style={`bottom:${stickyBottomOffset}px;`}\n      tabIndex={hasTabIndex ? 0 : -1}\n      role={'gridcell'}\n      data-oj-cell-type={'footer'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-footer-cell={tableId}\n      data-oj-table-tooltip={supportsDefaultTooltip ? 'enabled' : undefined}\n      {...(supportsDefaultTooltip && browser === 'safari' ? preventBrowserTooltipProps : {})}\n      {...(isColumnSelectable && interactionProps)}>\n      {renderer(footerCellRendererProps)}\n    </td>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableColumn } from './Table';\nimport { TableFooterCell } from './TableFooterCell';\nimport { backgroundStyles, tableFooterRowStyles } from './themes/Table.css';\n\n/**\n * Props for the TableFooter Component\n */\nexport type TableFooterProps<K, D, C> = {\n  tableId: string;\n  isRendered: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  activeKey?: C;\n  isTabbableMode: boolean;\n  isShowFocusRing: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  selectedKeys?: Keys<C>;\n  isColumnSelectionEnabled: boolean;\n  stickyBottomOffset?: number;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  dataRowCount: number;\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a footer region in Table.\n */\nexport function TableFooter<K, D, C>({\n  tableId,\n  isRendered,\n  columnsArray,\n  hasVerticalGridlines,\n  activeKey,\n  isTabbableMode,\n  isShowFocusRing,\n  selectedKeys,\n  isColumnSelectionEnabled,\n  disabledInteractionKeys,\n  stickyBottomOffset,\n  startStickyEdge,\n  endStickyEdge,\n  dataRowCount,\n  isRtl,\n  isHighContrast\n}: TableFooterProps<K, D, C>) {\n  const rowClasses = classNames([tableFooterRowStyles.base]);\n\n  let isPreviousColumnSelected = false;\n  return isRendered ? (\n    <tfoot class={backgroundStyles.inherit} role={'presentation'}>\n      <tr\n        aria-rowindex={Math.max(dataRowCount, 1) + 2}\n        class={rowClasses}\n        role={'row'}\n        data-oj-table-footer-row={tableId}>\n        {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n          const columnKey = column.key;\n          const isSelected = containsKey(selectedKeys, columnKey);\n          const isActive = columnKey === activeKey;\n          const hasTabIndex = isActive && !isTabbableMode;\n          const footerCellProps = {\n            tableId: tableId,\n            columnKey: columnKey,\n            columnIndex: columnIndex,\n            isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n            hasVerticalGridlines: hasVerticalGridlines,\n            stickyBottomOffset: stickyBottomOffset,\n            stickyColumn: column.value.sticky,\n            isColumnSelectionEnabled: isColumnSelectionEnabled,\n            isSelected: isSelected,\n            isPreviousColumnSelected: isPreviousColumnSelected,\n            isColumnSelectable: isColumnSelectionEnabled && column.value.selectable !== 'disabled',\n            isShowFocusRing: isShowFocusRing && isActive,\n            hasTabIndex: hasTabIndex,\n            isTabbableMode: isTabbableMode,\n            footerText: column.value.footerText,\n            renderer: column.value.footerRenderer,\n            disabledInteractionKeys: disabledInteractionKeys,\n            isStickyStartEdge: columnIndex === startStickyEdge,\n            isStickyEndEdge: columnIndex === endStickyEdge,\n            isRtl: isRtl,\n            isHighContrast: isHighContrast,\n            padding: column.value.footerPadding,\n            tooltip: column.value.headerTooltip,\n            horizontalAlignment:\n              column.value.footerAlignment?.horizontal != null\n                ? column.value.footerAlignment.horizontal\n                : column.value.horizontalAlignment,\n            verticalAlignment: column.value.footerAlignment?.vertical\n          };\n          isPreviousColumnSelected = isSelected;\n          return <TableFooterCell {...footerCellProps} />;\n        })}\n      </tr>\n    </tfoot>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { tableDragIndicatorStyles } from './themes/Table.css';\n\n/**\n * Props for the TableDragIndicator Component\n */\nexport type TableDragIndicatorProps = {\n  isRtl: boolean;\n  position?: number;\n  height?: number;\n};\n\n/**\n * The internal component used to render a drag indicator line in the Table.\n */\nexport function TableDragIndicator({ position, isRtl, height }: TableDragIndicatorProps) {\n  const tableDragIndicatorClasses = classNames([tableDragIndicatorStyles.base]);\n\n  const getDragIndicatorStyle = () => {\n    const heightString = height != null ? `height:${height}px;` : '';\n    if (position != null) {\n      return isRtl\n        ? `right:${position}px;cursor:col-resize;${heightString}`\n        : `left:${position}px;cursor:col-resize;${heightString}`;\n    }\n    return `display:none;`;\n  };\n\n  return <div class={tableDragIndicatorClasses} style={getDragIndicatorStyle()} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentProps } from 'preact';\nimport { Menu } from '../UNSAFE_Menu';\nimport { CellContext, TableContextMenuConfig } from '../UNSAFE_TableView';\n\nexport type Props<K extends string | number, D, C extends string> = {\n  contextMenuConfig: TableContextMenuConfig<K, D, C>;\n  contextMenuContext: CellContext<K, D, C>;\n} & Omit<ComponentProps<typeof Menu>, 'children'>;\n\n/**\n * The internal component used to render a custom context menu on the Table\n */\nexport function TableContextMenu<K extends string | number, D, C extends string>({\n  contextMenuConfig,\n  contextMenuContext,\n  ...menuProps\n}: Props<K, D, C>) {\n  const accessibleLabel = contextMenuConfig.accessibleLabel;\n  return (\n    <Menu\n      {...menuProps}\n      {...(accessibleLabel != null && {\n        'aria-label': accessibleLabel\n      })}>\n      {menuProps.isOpen && contextMenuConfig.itemsRenderer(contextMenuContext)}\n    </Menu>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { Dispatch, MutableRef } from 'preact/hooks';\nimport { scrollerStyles } from '../themes/Table.css';\nimport { ScrollDetail, SizingInfo, TableColumn, ViewportInfo } from '../Table';\nimport {\n  ColumnWidths,\n  TableHorizontalScrollPosition,\n  TableVerticalScrollPosition,\n  TableViewportConfig\n} from '../../UNSAFE_TableView';\nimport { findElementByKey } from '../../utils/PRIVATE_collectionUtils';\nimport {\n  getColumnKey,\n  getElementFromCell,\n  getRowKey,\n  getRowKeyForRowIndex,\n  getScrollerBottomOffset,\n  getScrollerTopOffset\n} from './TableDomUtils';\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nfunction _scrollColumnIntoView<K, D, C>(\n  columnElement: HTMLElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  columnsArray: TableColumn<K, D, C>[],\n  scrollbarWidth: number,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  location?: 'inView' | 'start' | 'end'\n) {\n  const columnKey = getColumnKey(columnElement);\n\n  let columnIndex;\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].key === columnKey) {\n      columnIndex = i;\n      break;\n    }\n  }\n  if (columnIndex != null && fullColumnWidths != null) {\n    let startOffset = 0;\n    let endOffset = 0;\n\n    if (viewportInfo.isExternalScroller) {\n      const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;\n      if (scrollerOffsetStart != null) {\n        startOffset = scrollerOffsetStart;\n      }\n      const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;\n      if (scrollerOffsetEnd != null) {\n        endOffset = scrollerOffsetEnd;\n      }\n    }\n\n    const stickyColumns = getStickyColumnIndicies(columnsArray);\n    for (let i = 0; i < stickyColumns.length; i++) {\n      const stickyIndex = stickyColumns[i];\n      if (stickyIndex < columnIndex) {\n        startOffset += fullColumnWidths[stickyIndex];\n      } else {\n        break;\n      }\n    }\n    for (let i = stickyColumns.length - 1; i > -1; i--) {\n      const stickyIndex = stickyColumns[i];\n      if (stickyIndex > columnIndex) {\n        endOffset += fullColumnWidths[stickyIndex];\n      } else {\n        break;\n      }\n    }\n\n    const horizontalOverflowDiff = _getHorizontalOverflowDiff(\n      columnElement,\n      scrollerElement,\n      startOffset,\n      endOffset,\n      scrollbarWidth,\n      isRtl\n    );\n    const leftOverflowDiff = horizontalOverflowDiff.left;\n    const hasLeftOverflow = leftOverflowDiff >= 0;\n    const rightOverflowDiff = horizontalOverflowDiff.right;\n    const hasRightOverflow = rightOverflowDiff >= 0;\n\n    // don't adjust scroll position if row has overflow in both directions\n    if (hasLeftOverflow && hasRightOverflow) {\n      return;\n    }\n\n    if (location == null || location === 'inView') {\n      // if column fits fully in viewport, scroll overflow side into view\n      // otherwise, scroll the shortest amount to fill viewport with column\n      if (hasLeftOverflow) {\n        if (Math.abs(rightOverflowDiff) > Math.abs(leftOverflowDiff)) {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft - leftOverflowDiff,\n            false\n          );\n        } else {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft + rightOverflowDiff,\n            true\n          );\n        }\n      } else if (hasRightOverflow) {\n        if (Math.abs(leftOverflowDiff) > Math.abs(rightOverflowDiff)) {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft + rightOverflowDiff,\n            true\n          );\n        } else {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft - leftOverflowDiff,\n            false\n          );\n        }\n      }\n    } else if (location === 'start') {\n      scrollerElement.scrollLeft = _roundScrollValue(\n        scrollerElement.scrollLeft - leftOverflowDiff,\n        false\n      );\n    } else {\n      scrollerElement.scrollLeft = _roundScrollValue(\n        scrollerElement.scrollLeft + rightOverflowDiff,\n        true\n      );\n    }\n  }\n}\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nconst _scrollRowIntoView = (\n  rootElement: HTMLDivElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  rowElement: HTMLElement,\n  scrollerElement: HTMLElement,\n  scrollbarHeight: number,\n  location?: 'inView' | 'top' | 'bottom'\n) => {\n  let topOffset = 0;\n  let bottomOffset = 0;\n\n  if (viewportInfo.isExternalScroller) {\n    const scrollerOffsetTop = viewportInfo.viewportConfig.scrollerOffsetTop;\n    if (scrollerOffsetTop != null) {\n      topOffset = scrollerOffsetTop;\n    }\n    const scrollerOffsetBottom = viewportInfo.viewportConfig.scrollerOffsetBottom;\n    if (scrollerOffsetBottom != null) {\n      bottomOffset = scrollerOffsetBottom;\n    }\n  }\n  topOffset += getScrollerTopOffset(rootElement, tableId);\n  bottomOffset += getScrollerBottomOffset(rootElement, tableId);\n\n  const verticalOverflowDiff = _getVerticalOverflowDiff(\n    rowElement,\n    scrollerElement,\n    topOffset,\n    bottomOffset,\n    scrollbarHeight\n  );\n  const topOverflowDiff = verticalOverflowDiff.top;\n  const hasTopOverflow = topOverflowDiff >= 0;\n  const bottomOverflowDiff = verticalOverflowDiff.bottom;\n  const hasBottomOverflow = bottomOverflowDiff >= 0;\n\n  // don't adjust scroll position if row has overflow in both directions\n  if (hasTopOverflow && hasBottomOverflow) {\n    return;\n  }\n  if (location == null || location === 'inView') {\n    // if row fits fully in viewport, scroll overflow side into view\n    // otherwise, scroll the shortest amount to fill viewport with row\n    if (hasBottomOverflow) {\n      if (Math.abs(topOverflowDiff) > Math.abs(bottomOverflowDiff)) {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop + bottomOverflowDiff,\n          true\n        );\n      } else {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop - topOverflowDiff,\n          false\n        );\n      }\n    } else if (hasTopOverflow) {\n      if (Math.abs(bottomOverflowDiff) > Math.abs(topOverflowDiff)) {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop - topOverflowDiff,\n          false\n        );\n      } else {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop + bottomOverflowDiff,\n          true\n        );\n      }\n    }\n  } else if (location === 'top') {\n    scrollerElement.scrollTop = _roundScrollValue(\n      scrollerElement.scrollTop - topOverflowDiff,\n      false\n    );\n  } else {\n    scrollerElement.scrollTop = _roundScrollValue(\n      scrollerElement.scrollTop + bottomOverflowDiff,\n      true\n    );\n  }\n};\n\n/**\n * Helper method to round a desired scrollTop or scrollLeft value to the nearest valid value\n * depending on the client browser.\n */\nconst _roundScrollValue = (value: number, isOver: boolean) => {\n  // use Math.floor() and Math.ceil() to ensure we round to nearest containing valid\n  // pixel value in either direction as valid scrollTop values are only integers\n  return isOver ? Math.ceil(value) : Math.floor(value);\n};\n\n/**\n * A helper to get the horizontal overflow diff of the given element\n */\nconst _getHorizontalOverflowDiff = (\n  element: HTMLElement,\n  scrollerElement: HTMLElement,\n  startOffset: number,\n  endOffset: number,\n  scrollbarWidth: number,\n  isRtl: boolean\n) => {\n  const elementRect = element.getBoundingClientRect();\n  const scrollerRect = scrollerElement.getBoundingClientRect();\n\n  if (isRtl) {\n    return {\n      left: scrollerRect.left - elementRect.left + endOffset + scrollbarWidth,\n      right: elementRect.right - scrollerRect.right + startOffset\n    };\n  } else {\n    return {\n      left: scrollerRect.left - elementRect.left + startOffset,\n      right: elementRect.right - scrollerRect.right + endOffset + scrollbarWidth\n    };\n  }\n};\n\n/**\n * A helper to get the vertical overflow diff of the given element\n */\nexport const _getVerticalOverflowDiff = (\n  element: HTMLElement,\n  scrollerElement: HTMLElement,\n  topOffset: number,\n  bottomOffset: number,\n  scrollbarHeight: number\n) => {\n  const elementRect = element.getBoundingClientRect();\n  const scrollerRect = scrollerElement.getBoundingClientRect();\n\n  return {\n    top: scrollerRect.top - elementRect.top + topOffset,\n    bottom: elementRect.bottom - scrollerRect.bottom + bottomOffset + scrollbarHeight\n  };\n};\n\n/**\n * Helper to set the horizontal scroll position on the Table.\n */\nexport function setHorizontalScrollPosition<K, D, C>(\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  isRtl: boolean,\n  horizontalScrollPosition?: TableHorizontalScrollPosition<C>\n) {\n  const x = _getScrollLeftFromScrollPosition(\n    scrollerElement,\n    columnsArray,\n    fullColumnWidths,\n    horizontalScrollPosition\n  );\n  scrollerElement.scrollLeft = x != null ? (isRtl ? -x : x) : 0;\n}\n\n/**\n * Helper to set the vertical scroll position on the Table.\n */\nexport function setVerticalScrollPosition<K>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  verticalScrollPosition?: TableVerticalScrollPosition<K>\n) {\n  const y = _getScrollTopFromScrollPosition(\n    rootElement,\n    scrollerElement,\n    tableId,\n    verticalScrollPosition\n  );\n  scrollerElement.scrollTop = y != null ? y : 0;\n}\n\n/**\n * Helper to determine the 'x' value of a given scroll position.\n */\nfunction _getScrollLeftFromScrollPosition<K, D, C>(\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  scrollPosition?: TableHorizontalScrollPosition<C>\n) {\n  if (scrollPosition != null) {\n    let columnKey;\n    let useColumn = false;\n    if (scrollPosition.columnKey != null) {\n      // columnKey takes precedence over everything else\n      useColumn = true;\n      columnKey = scrollPosition.columnKey;\n    } else if (scrollPosition.offsetX != null && scrollPosition.x == null) {\n      // offsetX can be used on its own if it is the only horizontal aspect provided\n      useColumn = true;\n      const currentHorizontalScrollPosition = getHorizontalScrollPosition(\n        scrollerElement,\n        columnsArray,\n        fullColumnWidths\n      );\n      columnKey = currentHorizontalScrollPosition.columnKey;\n    }\n    if (useColumn) {\n      if (columnKey != null) {\n        let x = 0;\n        for (let i = 0; i < fullColumnWidths.length; i++) {\n          if (columnsArray[i].key === columnKey) {\n            return x + (scrollPosition.offsetX != null ? scrollPosition.offsetX : 0);\n          }\n          if (columnsArray[i].value.sticky !== 'enabled') {\n            x += fullColumnWidths[i];\n          }\n        }\n      }\n    } else if (scrollPosition.x != null) {\n      return scrollPosition.x;\n    }\n  }\n  // either nothing was provided, or what was provided was invalid\n  return undefined;\n}\n\n/**\n * Helper to determine the 'y' value of a given scroll position.\n */\nfunction _getScrollTopFromScrollPosition<K>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  scrollPosition?: TableVerticalScrollPosition<K>\n) {\n  if (scrollPosition != null) {\n    let rowKey;\n    let useRow = false;\n    if (scrollPosition.rowKey != null) {\n      // rowKey takes precedence over everything else\n      useRow = true;\n      rowKey = scrollPosition.rowKey;\n    } else if (scrollPosition.offsetY != null && scrollPosition.y == null) {\n      // offsetY can be used on its own if it is the only vertical aspect provided\n      useRow = true;\n      rowKey = getVerticalScrollPosition(rootElement, scrollerElement, tableId).rowKey;\n    }\n    if (useRow) {\n      if (rowKey != null) {\n        let y = 0;\n        const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n        for (let i = 0; i < rowElements.length; i++) {\n          if (rowKey === getRowKey(rowElements[i] as HTMLElement)) {\n            return y + (scrollPosition.offsetY != null ? scrollPosition.offsetY : 0);\n          }\n          y += rowElements[i].getBoundingClientRect().height;\n        }\n      }\n    } else if (scrollPosition.y != null) {\n      return scrollPosition.y;\n    }\n  }\n  // either nothing was provided, or what was provided was invalid\n  return undefined;\n}\n\n/**\n * Helper to get the logical scroll position for the given scrollLeft value. If no scrollLeft value is given,\n * it will use the current scrollLeft value of the Table.\n */\nexport function getHorizontalScrollPosition<K, D, C>(\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  newScrollLeft?: number\n) {\n  // ensure scroll position x value is initialized\n  const scrollLeft = Math.abs(newScrollLeft == null ? scrollerElement.scrollLeft : newScrollLeft);\n\n  const scrollPosition: TableHorizontalScrollPosition<C> = {\n    x: scrollLeft,\n    columnKey: undefined,\n    offsetX: undefined\n  };\n\n  let columnEnd = 0;\n  if (columnsArray.length > 0) {\n    if (scrollLeft === 0) {\n      scrollPosition.columnKey = columnsArray[0].key;\n      scrollPosition.offsetX = 0;\n      return scrollPosition;\n    }\n  }\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].value.sticky !== 'enabled') {\n      columnEnd += fullColumnWidths[i];\n    }\n    if (scrollLeft < columnEnd) {\n      scrollPosition.columnKey = columnsArray[i].key;\n      scrollPosition.offsetX = fullColumnWidths[i] + scrollLeft - columnEnd;\n      break;\n    }\n  }\n  return scrollPosition;\n}\n\n/**\n * Helper to get the logical scroll position for the given scrollTop value. If no scrollTop value is given,\n * it will use the current scrollTop value of the Table.\n */\nexport function getVerticalScrollPosition<K>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  newScrollTop?: number\n) {\n  // ensure scroll position y value is initialized\n  const scrollTop = Math.abs(newScrollTop == null ? scrollerElement.scrollTop : newScrollTop);\n\n  const scrollPosition: TableVerticalScrollPosition<K> = {\n    y: scrollTop,\n    rowKey: undefined,\n    offsetY: undefined\n  };\n\n  let rowBottom = 0;\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  if (rowElements.length > 0) {\n    if (scrollTop === 0) {\n      scrollPosition.rowKey = getRowKeyForRowIndex<K>(rootElement, tableId, 0)!;\n      scrollPosition.offsetY = 0;\n      return scrollPosition;\n    }\n  }\n  for (let i = 0; i < rowElements.length; i++) {\n    const rowHeight = rowElements[i].getBoundingClientRect().height;\n    rowBottom += rowHeight;\n    if (scrollTop < rowBottom) {\n      scrollPosition.rowKey = getRowKeyForRowIndex<K>(rootElement, tableId, i)!;\n      scrollPosition.offsetY = rowHeight + scrollTop - rowBottom;\n      break;\n    }\n  }\n  return scrollPosition;\n}\n\nexport function applyScrollDetail<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfo: SizingInfo,\n  scrollDetail: ScrollDetail<K, C>,\n  isRtl: boolean,\n  fullColumnWidths?: number[]\n) {\n  if (scrollDetail.cell.type === 'data') {\n    const rowElement = findElementByKey(\n      rootElement,\n      scrollDetail.cell.rowKey,\n      `[data-oj-table-data-row='${tableId}']`\n    ) as HTMLElement;\n    if (rowElement != null && scrollDetail.locationY != null && !sizingInfo.isInitialRender) {\n      const scrollbarHeight = sizingInfo.boxHeight - sizingInfo.contentHeight;\n      _scrollRowIntoView(\n        rootElement,\n        viewportInfo,\n        tableId,\n        rowElement,\n        scrollerElement,\n        scrollbarHeight,\n        scrollDetail.locationY\n      );\n    }\n  }\n  if (\n    scrollDetail.cell.type === 'data' ||\n    scrollDetail.cell.type === 'header' ||\n    scrollDetail.cell.type === 'footer'\n  ) {\n    const cellElement = getElementFromCell(rootElement, tableId, scrollDetail.cell);\n    if (cellElement != null && scrollDetail.locationX != null && !sizingInfo.isInitialRender) {\n      const scrollbarWidth = sizingInfo.boxWidth - sizingInfo.contentWidth;\n      _scrollColumnIntoView(\n        cellElement,\n        scrollerElement,\n        viewportInfo,\n        columnsArray,\n        scrollbarWidth,\n        isRtl,\n        fullColumnWidths,\n        scrollDetail.locationX\n      );\n    }\n  }\n  if (scrollDetail.cell.type === 'loadMore' || scrollDetail.cell.type === 'loading') {\n    const cellElement = getElementFromCell(rootElement, tableId, scrollDetail.cell);\n    if (cellElement != null && scrollDetail.locationY != null && !sizingInfo.isInitialRender) {\n      const scrollbarHeight = sizingInfo.boxHeight - sizingInfo.contentHeight;\n      _scrollRowIntoView(\n        rootElement,\n        viewportInfo,\n        tableId,\n        cellElement,\n        scrollerElement,\n        scrollbarHeight,\n        scrollDetail.cell.type === 'loading' && scrollDetail.locationY === 'inView'\n          ? 'top'\n          : scrollDetail.locationY\n      );\n    }\n  }\n}\n\n/**\n * Helper function to update the 'left' and 'right' values of all sticky columns to correspond\n * to the given sizing information.\n */\nexport function updateStickyColumns<K, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  isRtl: boolean,\n  columnsArray: TableColumn<K, D, C>[],\n  appliedColumnWidths: ColumnWidths<C>,\n  stickyEdgesState: { start?: number; end?: number },\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void,\n  isHorizontalScroll: boolean\n) {\n  let stickyIndex;\n  let stickyStartOffset = 0;\n  let stickyEndOffset = 0;\n  if (viewportInfo.isExternalScroller) {\n    const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;\n    if (scrollerOffsetStart != null) {\n      stickyStartOffset = scrollerOffsetStart;\n    }\n    const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;\n    if (scrollerOffsetEnd != null) {\n      stickyEndOffset = scrollerOffsetEnd;\n    }\n  }\n\n  const fullColumnWidths = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const width = appliedColumnWidths[columnsArray[i].key];\n    fullColumnWidths.push(width);\n  }\n\n  const stickyIndicies = getStickyColumnIndicies(columnsArray);\n  for (let i = 0; i < stickyIndicies.length; i++) {\n    stickyIndex = stickyIndicies[i];\n    _applyStickyColumnOffset(rootElement, tableId, isRtl, stickyIndex, stickyStartOffset, true);\n    stickyStartOffset += fullColumnWidths[stickyIndex];\n  }\n  for (let i = stickyIndicies.length - 1; i > -1; i--) {\n    stickyIndex = stickyIndicies[i];\n    _applyStickyColumnOffset(rootElement, tableId, isRtl, stickyIndex, stickyEndOffset, false);\n    stickyEndOffset += fullColumnWidths[stickyIndex];\n  }\n\n  // only apply sticky edge styling if horizontal overflow is present\n  if (isHorizontalScroll) {\n    updateStickyEdges(\n      scrollerElement,\n      columnsArray,\n      fullColumnWidths,\n      stickyEdgesState,\n      setStickyEdgesState\n    );\n  } else if (stickyEdgesState.start != null || stickyEdgesState.end != null) {\n    setStickyEdgesState({});\n  }\n}\n\n/**\n * Helper function to get the sticky column indicies.\n */\nexport const getStickyColumnIndicies = <K, D, C>(columnsArray: TableColumn<K, D, C>[]) => {\n  const stickyColumns = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].value.sticky === 'enabled') {\n      stickyColumns.push(i);\n    }\n  }\n  return stickyColumns;\n};\n\n/**\n * Helper function to update the 'left' and 'right' values of a specific column.\n */\nconst _applyStickyColumnOffset = (\n  rootElement: HTMLDivElement,\n  tableId: string,\n  isRtl: boolean,\n  columnIndex: number,\n  stickyOffset: number,\n  isStart: boolean\n) => {\n  const styleProperty = (isStart && !isRtl) || (!isStart && isRtl) ? 'left' : 'right';\n  const styleValue = `${stickyOffset}px`;\n\n  const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n  const headerElement = headerElements[columnIndex] as HTMLElement;\n  headerElement.style[styleProperty] = styleValue;\n\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  for (let j = 0; j < rowElements.length; j++) {\n    const rowElement = rowElements[j] as HTMLElement;\n    const cellElements = rowElement.querySelectorAll(`[data-oj-table-data-cell='${tableId}']`);\n    const cellElement = cellElements[columnIndex] as HTMLElement;\n    cellElement.style[styleProperty] = styleValue;\n  }\n\n  const footerElements = rootElement.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);\n  if (footerElements.length > 0) {\n    const footerElement = footerElements[columnIndex] as HTMLElement;\n    footerElement.style[styleProperty] = styleValue;\n  }\n};\n\n/**\n * Helper function to update the sticky edges based on the given scrollLeft value.\n */\nexport function updateStickyEdges<K, D, C>(\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  stickyEdgesState: { start?: number; end?: number },\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void,\n  scrollLeft?: number\n) {\n  if (columnsArray.length > 0) {\n    let i;\n    let currentScrollIndex;\n    const newScrollPosition = getHorizontalScrollPosition(\n      scrollerElement,\n      columnsArray,\n      fullColumnWidths,\n      scrollLeft\n    );\n    for (i = 0; i < columnsArray.length; i++) {\n      if (columnsArray[i].key === newScrollPosition.columnKey) {\n        currentScrollIndex = i;\n        break;\n      }\n    }\n\n    let startIndex;\n    const stickyIndicies = getStickyColumnIndicies(columnsArray);\n    // browser zoom levels cause rounding issues where the start scroll\n    // position may never be reached, but it should always be within 1\n    if (newScrollPosition.x! >= 1) {\n      for (i = 0; i < stickyIndicies.length; i++) {\n        const currentIndex = stickyIndicies[i];\n        if (currentIndex < currentScrollIndex!) {\n          startIndex = currentIndex;\n        } else {\n          break;\n        }\n      }\n    }\n\n    let endIndex;\n    let currentWidth = 0;\n    const maxScrollPos = scrollerElement.scrollWidth - scrollerElement.clientWidth;\n    const endOverflow = maxScrollPos - newScrollPosition.x!;\n    // browser zoom levels cause rounding issues where the max scroll\n    // position may never be reached, but it should always be within 1\n    if (endOverflow >= 1) {\n      for (let i = columnsArray.length - 1; i > -1; i--) {\n        if (stickyIndicies.indexOf(i) !== -1) {\n          endIndex = i;\n        } else {\n          currentWidth += fullColumnWidths[i];\n          if (currentWidth > endOverflow) {\n            break;\n          }\n        }\n      }\n    }\n    if (stickyEdgesState.start != startIndex || stickyEdgesState.end != endIndex) {\n      setStickyEdgesState({ start: startIndex, end: endIndex });\n    }\n  }\n}\n\n/**\n * Helper function to hide a currently shown tooltip once the anchor cell scrolls out of view.\n */\nexport function hideOutOfViewTooltip<K, C, D>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  sizingInfo: SizingInfo,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  tooltipAnchorRef: MutableRef<HTMLElement | undefined>,\n  hideTooltip: (isImmediate?: boolean) => void,\n  isRtl: boolean\n) {\n  if (tooltipAnchorRef.current != null) {\n    const verticalOverflowDiff = _getVerticalOverflowDiff(\n      tooltipAnchorRef.current,\n      scrollerElement,\n      getScrollerTopOffset(rootElement, tableId),\n      getScrollerBottomOffset(rootElement, tableId),\n      sizingInfo.boxHeight! - sizingInfo.contentHeight!\n    );\n    const topOverflowDiff = verticalOverflowDiff.top;\n    const hasTopOverflow = topOverflowDiff >= 0;\n    const bottomOverflowDiff = verticalOverflowDiff.bottom;\n    const hasBottomOverflow = bottomOverflowDiff >= 0;\n\n    if (\n      (hasTopOverflow && Math.abs(topOverflowDiff) > tooltipAnchorRef.current.offsetHeight) ||\n      (hasBottomOverflow && Math.abs(bottomOverflowDiff) > tooltipAnchorRef.current.offsetHeight)\n    ) {\n      hideTooltip(true);\n      return;\n    }\n\n    let startOffset = 0;\n    let endOffset = 0;\n\n    const stickyColumns = getStickyColumnIndicies(columnsArray);\n    for (let i = 0; i < stickyColumns.length; i++) {\n      const stickyIndex = stickyColumns[i];\n      startOffset += fullColumnWidths[stickyIndex];\n    }\n    for (let i = stickyColumns.length - 1; i > -1; i--) {\n      const stickyIndex = stickyColumns[i];\n      endOffset += fullColumnWidths[stickyIndex];\n    }\n    const horizontalOverflowDiff = _getHorizontalOverflowDiff(\n      tooltipAnchorRef.current,\n      scrollerElement,\n      startOffset,\n      endOffset,\n      sizingInfo.boxWidth! - sizingInfo.contentWidth!,\n      isRtl\n    );\n    const leftOverflowDiff = horizontalOverflowDiff.left;\n    const hasLeftOverflow = leftOverflowDiff >= 0;\n    const rightOverflowDiff = horizontalOverflowDiff.right;\n    const hasRightOverflow = rightOverflowDiff >= 0;\n\n    if (\n      (hasLeftOverflow && Math.abs(leftOverflowDiff) > tooltipAnchorRef.current.offsetWidth) ||\n      (hasRightOverflow && Math.abs(rightOverflowDiff) > tooltipAnchorRef.current.offsetWidth)\n    ) {\n      hideTooltip(true);\n    }\n  }\n}\n\n/**\n * Helper function to reset the scroll position of the scroller element\n */\nexport const resetVerticalScrollPosition = (scrollerElement: HTMLElement) => {\n  scrollerElement.scrollTop = 0;\n};\n\n/**\n * Helper function to get the viewport config. TODO: this needs help for table still\n */\nexport const getViewportConfig = (\n  scrollerRef: RefObject<HTMLElement>,\n  config?: TableViewportConfig\n) => {\n  return (\n    config ?? {\n      scroller: () => {\n        return scrollerRef;\n      }\n    }\n  );\n};\n\n/**\n * Helper function to update the scroller element's styling based on overflow status.\n */\nexport const applyOverflowStatus = (\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  contentWidth: number,\n  availableWidth: number,\n  contentHeight: number,\n  availableHeight: number,\n  scrollbarWidth: number,\n  overflowRef: MutableRef<{ isHorizontal: boolean; isVertical: boolean }>,\n  setHasVerticalUnderflow: Dispatch<boolean>\n) => {\n  // check for at least 0.5px difference to account for browser rounding issues\n  const hasHorizontalOverflow = contentWidth - availableWidth > 0.5;\n  const hasVerticalOverflow = contentHeight - availableHeight > 0.5;\n  if (hasHorizontalOverflow) {\n    scrollerElement.classList.remove(scrollerStyles.noHorizontalScroll);\n    scrollerElement.classList.add(scrollerStyles.horizontalScroll);\n  } else {\n    scrollerElement.classList.remove(scrollerStyles.horizontalScroll);\n    scrollerElement.classList.add(scrollerStyles.noHorizontalScroll);\n  }\n  if (hasVerticalOverflow) {\n    scrollerElement.classList.remove(scrollerStyles.noVerticalScroll);\n    scrollerElement.classList.add(scrollerStyles.verticalScroll);\n    scrollerElement.style.paddingInlineEnd = '';\n  } else {\n    scrollerElement.classList.remove(scrollerStyles.verticalScroll);\n    scrollerElement.classList.add(scrollerStyles.noVerticalScroll);\n    scrollerElement.style.paddingInlineEnd = `${scrollbarWidth}px`;\n  }\n  overflowRef.current.isHorizontal = hasHorizontalOverflow;\n  overflowRef.current.isVertical = hasVerticalOverflow;\n  applyUnderflowStatus(rootElement, tableId, setHasVerticalUnderflow);\n};\n\n/**\n * Helper function to update the undeflow status of the Table based on the spacer element sizing.\n */\nexport const applyUnderflowStatus = (\n  rootElement: HTMLDivElement,\n  tableId: string,\n  setHasVerticalUnderflow: Dispatch<boolean>\n) => {\n  const spacerRowElement = rootElement.querySelector(\n    `[data-oj-table-spacer-row='${tableId}']`\n  ) as HTMLElement;\n  if (spacerRowElement != null) {\n    setHasVerticalUnderflow(spacerRowElement.offsetHeight > 0);\n  }\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  CurrencyStatus,\n  SizingInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { getBoundaryColumnKey, getElementFromCell } from './TableDomUtils';\nimport { applyScrollDetail, resetVerticalScrollPosition } from '../utils/TableScrollUtils';\nimport { Cell, CellContext, CellOverride } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to determine if a given active cell represents a 'transient' state.\n */\nexport function isTransientCell<K, C>(activeCell?: ActiveCell<K, C>) {\n  return (\n    activeCell != null &&\n    (activeCell.type === 'loadMore' ||\n      activeCell.type === 'loading' ||\n      activeCell.type === 'pending')\n  );\n}\n\n/**\n * Helper function to compare two given cell descriptors.\n */\nexport function cellComparator<K, C>(\n  cell1?: ActiveCell<K, C> | Cell<K, C>,\n  cell2?: ActiveCell<K, C> | Cell<K, C>\n) {\n  if (cell1 == null) {\n    return cell2 == null;\n  }\n  if (cell2 == null) {\n    return false;\n  }\n  if (cell1.type === cell2.type && cell1.rowKey === cell2.rowKey) {\n    // special case the transient 'loading' cell types as column keys are hints used for when a user\n    // navigates back to another region using the keyboard - otherwise we'd go to the first column\n    if (cell1.type === 'loading' || cell1.type === 'loadMore' || cell1.type === 'pending') {\n      return true;\n    }\n    return cell1.columnKey === cell2.columnKey;\n  }\n  return false;\n}\n\nexport function getCellContextFromCell<K extends string | number, D, C extends string>(\n  tableData: TableData<K, D>[],\n  cell?: ActiveCell<K, C>\n) {\n  if (cell?.type === 'data') {\n    for (const rowData of tableData) {\n      if (rowData.metadata === cell.rowKey) {\n        return {\n          rowData: rowData.data,\n          rowKey: cell.rowKey,\n          columnKey: cell.columnKey,\n          type: 'data'\n        } as CellContext<K, D, C>;\n      }\n    }\n  } else if (cell?.type === 'header' || cell?.type === 'footer') {\n    return {\n      columnKey: cell.columnKey,\n      type: cell.type\n    } as CellContext<K, D, C>;\n  }\n  return undefined;\n}\n\n/**\n * Helper function to determine the resulting cell from a cell override.\n */\nfunction _getCellFromCellOverride<K, D, C>(\n  tableData: TableData<K, D>[],\n  columnsArray: TableColumn<K, D, C>[],\n  cellOverride: CellOverride<K, C>,\n  currentCell?: Cell<K, C>\n): Cell<K, C> | undefined {\n  let cellType;\n  let cellRowKey;\n  let cellColumnKey;\n  if (cellOverride.rowKey != null) {\n    cellType = 'data';\n    cellRowKey = cellOverride.rowKey;\n    if (cellOverride.columnKey != null) {\n      cellColumnKey = cellOverride.columnKey;\n    } else if (currentCell?.columnKey != null) {\n      cellColumnKey = currentCell.columnKey;\n    } else {\n      cellColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n    }\n    if (cellColumnKey == null) {\n      return undefined;\n    }\n  } else if (cellOverride.columnKey != null) {\n    cellColumnKey = cellOverride.columnKey;\n    if (cellOverride.type != null) {\n      cellType = cellOverride.type;\n    } else if (currentCell?.type != null && currentCell.type !== 'noData') {\n      cellType = currentCell.type;\n    } else {\n      cellType = 'header';\n    }\n    if (cellType === 'data') {\n      if (currentCell?.rowKey != null) {\n        cellRowKey = currentCell.rowKey;\n      } else if (tableData.length > 0) {\n        cellRowKey = tableData[0].metadata;\n      }\n      if (cellRowKey == null) {\n        return undefined;\n      }\n    }\n  } else if (cellOverride.type != null) {\n    cellType = cellOverride.type;\n    if (cellType !== 'noData') {\n      if (currentCell?.columnKey != null) {\n        cellColumnKey = currentCell.columnKey;\n      } else {\n        cellColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n      }\n      if (cellColumnKey == null) {\n        return undefined;\n      }\n      if (cellType === 'data') {\n        if (currentCell?.rowKey != null) {\n          cellRowKey = currentCell.rowKey;\n        } else if (tableData.length > 0) {\n          cellRowKey = tableData[0].metadata;\n        }\n        if (cellRowKey == null) {\n          return undefined;\n        }\n      }\n    }\n  } else {\n    return undefined;\n  }\n  return { type: cellType, rowKey: cellRowKey, columnKey: cellColumnKey } as Cell<K, C>;\n}\n\n/**\n * Helper function to determine the resulting cell type from a cell override.\n */\nfunction _getCellTypeFromCellOverride<K, C>(\n  cellOverride: CellOverride<K, C>,\n  currentCell?: Cell<K, C>\n) {\n  if (cellOverride.type != null) {\n    return cellOverride.type;\n  }\n  if (cellOverride.rowKey != null) {\n    return 'data';\n  }\n  // if no type or rowKey was given, a columnKey must have been given\n  if (currentCell?.type != null && currentCell.type !== 'noData') {\n    return currentCell.type;\n  }\n  return 'header';\n}\n\n/**\n * Helper function to apply a current cell override if necessary.\n */\nexport function applyCurrentCellOverride<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  tableData: TableData<K, D>[],\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  currencyStatusRef: MutableRef<CurrencyStatus<K, D, C>>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isExtendSelectionGesture?: boolean) => void,\n  isEmbeddedSelect: boolean,\n  isPendingLayout: boolean,\n  isDataLoaded: boolean,\n  isRtl: boolean,\n  currentCellOverride?: CellOverride<K, C>,\n  fullColumnWidths?: number[]\n) {\n  // when embedded select, use most recent non-null current cell value as override base\n  const currentCell = isEmbeddedSelect\n    ? currencyStatusRef.current.previousEmbeddedSelectCurrentCell\n    : currencyStatusRef.current.currentCell;\n  // ensure any new currentCellOverride settings are applied if necessary\n  if (\n    currencyStatusRef.current.hasPendingCurrentCellOverride ||\n    currencyStatusRef.current.currentCellOverride !== currentCellOverride\n  ) {\n    if (currentCellOverride != null) {\n      // attempt to find the cell the override specifies\n      const realizedCell = _getCellFromCellOverride<K, D, C>(\n        tableData,\n        columnsArray,\n        currentCellOverride,\n        currentCell\n      );\n      if (realizedCell != null) {\n        // override cell was determined - apply the override immediately\n        onActiveCellChanged({ value: realizedCell });\n        currencyStatusRef.current.currentCellOverride = currentCellOverride;\n        currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n        if (isEmbeddedSelect) {\n          // scroll 'current-cell-override' vertically into view immediately for embedded select\n          // otherwise, cell will be scrolled into view once the component or cell receives focus\n          if (!isPendingLayout && getElementFromCell(rootElement, tableId, realizedCell) != null) {\n            applyScrollDetail(\n              rootElement,\n              scrollerElement,\n              viewportInfo,\n              tableId,\n              columnsArray,\n              sizingInfoRef.current,\n              { cell: realizedCell, locationY: 'inView' },\n              isRtl,\n              fullColumnWidths\n            );\n            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n          } else if (isPendingLayout || !isDataLoaded) {\n            // corresponding element was not found - data is not ready for scrolling\n            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = true;\n          } else {\n            // corresponding element was not found - value was garbage\n            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n          }\n        } else {\n          // not in an embedded select, so no scrolling should be performed\n          currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n        }\n      } else if (!isDataLoaded) {\n        // override cell could not be determined - data is still fetching\n        currencyStatusRef.current.hasPendingCurrentCellOverride = true;\n      } else {\n        // override cell could not be determined - value was garbage\n        currencyStatusRef.current.currentCellOverride = currentCellOverride;\n        currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n      }\n    } else {\n      // override is set to clear the current cell\n      onActiveCellChanged({ value: currentCellOverride });\n      currencyStatusRef.current.currentCellOverride = currentCellOverride;\n      currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n      if (isEmbeddedSelect) {\n        // scroll back to the top for embedded select\n        resetVerticalScrollPosition(scrollerElement);\n      }\n      currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n    }\n  } else if (currencyStatusRef.current.hasPendingCurrentCellOverrideScroll) {\n    // try and apply any pending scroll from a previous cell override at this time\n    if (currencyStatusRef.current.currentCell != null) {\n      if (\n        !isPendingLayout &&\n        getElementFromCell(rootElement, tableId, currencyStatusRef.current.currentCell) != null\n      ) {\n        applyScrollDetail(\n          rootElement,\n          scrollerElement,\n          viewportInfo,\n          tableId,\n          columnsArray,\n          sizingInfoRef.current,\n          { cell: currencyStatusRef.current.currentCell, locationY: 'inView' },\n          isRtl,\n          fullColumnWidths\n        );\n        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n      } else if (!isPendingLayout && isDataLoaded) {\n        // corresponding element was not found - value was garbage\n        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n      }\n    } else {\n      // there is no longer a current cell to try and scroll to\n      currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n    }\n  }\n}\n\n/**\n * Helper to determine if the given render state includes the cell specified.\n */\nfunction _renderIncludesCell<K, D, C>(\n  cell: ActiveCell<K, C>,\n  columnsArray: TableColumn<K, D, C>[],\n  tableData: TableData<K, D>[],\n  hasMore: boolean,\n  isPendingLayout: boolean,\n  hasFooters: boolean\n) {\n  // pending layout is special as other regions exist, but are not yet navigable\n  if (isPendingLayout) {\n    return cell.type === 'pending';\n  }\n  if (cell.type === 'header' || (hasFooters && cell.type === 'footer')) {\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (columnsArray[i].key === cell.columnKey) {\n        return true;\n      }\n    }\n  } else if (tableData.length > 0) {\n    if (cell.type === 'loadMore') {\n      return hasMore;\n    }\n    if (cell.type === 'data') {\n      let isColumnValid = false;\n      for (let i = 0; i < columnsArray.length; i++) {\n        if (columnsArray[i].key === cell.columnKey) {\n          isColumnValid = true;\n          break;\n        }\n      }\n      if (isColumnValid) {\n        for (let i = 0; i < tableData.length; i++) {\n          if (tableData[i].metadata === cell.rowKey) {\n            return true;\n          }\n        }\n      }\n    }\n  } else {\n    return (cell.type === 'loading' && hasMore) || (cell.type === 'noData' && !hasMore);\n  }\n  return false;\n}\n\n/**\n * Helper to get the cell that should currently be a tab stop for the given render state.\n */\nexport function determineActiveCell<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  currencyStatusRef: MutableRef<CurrencyStatus<K, D, C>>,\n  tableData: TableData<K, D>[],\n  hasMore: boolean,\n  isPendingLayout: boolean,\n  isEmbeddedSelect: boolean,\n  hasFooters: boolean,\n  currentCellOverride?: CellOverride<K, C>\n): ActiveCell<K, C> | undefined {\n  if (isPendingLayout) {\n    return { type: 'pending' };\n  }\n  // if no columns are specified, it is a special case 'noData' display\n  const firstColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n  if (firstColumnKey == null) {\n    return { type: 'noData' };\n  }\n  // if nothing specifies where focus should go, use the first header cell\n  const defaultFirstCell: ActiveCell<K, C> = {\n    type: 'header',\n    columnKey: firstColumnKey\n  };\n\n  // when embedded select, use most recent non-null current cell value as override base\n  const currentCell = isEmbeddedSelect\n    ? currencyStatusRef.current.previousEmbeddedSelectCurrentCell\n    : currencyStatusRef.current.currentCell;\n  if (\n    currencyStatusRef.current.hasPendingCurrentCellOverride ||\n    currencyStatusRef.current.currentCellOverride !== currentCellOverride\n  ) {\n    if (currentCellOverride != null) {\n      // attempt to find the cell the override specifies\n      const realizedCell = _getCellFromCellOverride<K, D, C>(\n        tableData,\n        columnsArray,\n        currentCellOverride,\n        currentCell\n      );\n      if (\n        realizedCell != null &&\n        _renderIncludesCell(\n          realizedCell,\n          columnsArray,\n          tableData,\n          hasMore,\n          isPendingLayout,\n          hasFooters\n        )\n      ) {\n        return realizedCell;\n      }\n      // if here, the resulting cell from the override could not be determined or was not valid\n      const overrideCellType = _getCellTypeFromCellOverride(currentCellOverride, currentCell);\n      if (overrideCellType === 'data') {\n        if (tableData.length === 0 && hasMore) {\n          // pending 'data' override when 'loading' skeletons are shown\n          return { type: 'loading', columnKey: currentCell?.columnKey as C };\n        }\n      } else if (overrideCellType === 'noData' && tableData.length === 0 && hasMore) {\n        // pending 'noData' override when 'loading' skeletons are shown\n        return { type: 'loading', columnKey: currentCell?.columnKey as C };\n      }\n    } else if (\n      _renderIncludesCell(\n        defaultFirstCell,\n        columnsArray,\n        tableData,\n        hasMore,\n        isPendingLayout,\n        hasFooters\n      )\n    ) {\n      return defaultFirstCell;\n    } else {\n      return undefined;\n    }\n  }\n\n  // if here, there is no current cell override that can be applied during this render\n  const activeCell = currencyStatusRef.current.activeCell;\n  if (activeCell != null) {\n    if (activeCell.type === 'loadMore') {\n      const initialData = currencyStatusRef.current.loadMoreInitialData;\n      // if loadMore skeletons are no longer shown, or the data has changed, shift to\n      // the next row in the data set if possible - otherwise just the closest row\n      if (tableData.length > 0 && tableData !== initialData) {\n        const rowKey =\n          initialData != null && tableData.length > initialData.length\n            ? tableData[initialData.length].metadata\n            : tableData[tableData.length - 1].metadata;\n        const columnKey = currentCell?.columnKey != null ? currentCell.columnKey : firstColumnKey;\n        const cell: ActiveCell<K, C> = { type: 'data', rowKey: rowKey, columnKey: columnKey };\n        if (\n          _renderIncludesCell(cell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)\n        ) {\n          return cell;\n        }\n      } else if (tableData.length === 0) {\n        if (hasMore) {\n          return { type: 'loading', columnKey: currentCell?.columnKey as C };\n        } else {\n          return { type: 'noData' };\n        }\n      }\n    }\n    if (\n      _renderIncludesCell(activeCell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)\n    ) {\n      return activeCell;\n    } else if (activeCell.type === 'loading') {\n      if (currentCell != null && (currentCell.type === 'data' || currentCell.type === 'noData')) {\n        // if the current cell is already set to 'data' or 'noData', and is now available, return it\n        if (\n          _renderIncludesCell(\n            currentCell,\n            columnsArray,\n            tableData,\n            hasMore,\n            isPendingLayout,\n            hasFooters\n          )\n        ) {\n          return currentCell;\n        }\n      }\n      // otherwise, find the first row if available, and try and maintain the columnKey\n      if (tableData.length > 0) {\n        const rowKey = tableData[0].metadata;\n        const columnKey = currentCell?.columnKey != null ? currentCell.columnKey : firstColumnKey;\n        const cell: ActiveCell<K, C> = { type: 'data', rowKey: rowKey, columnKey: columnKey };\n        if (\n          _renderIncludesCell(cell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)\n        ) {\n          return cell;\n        }\n      } else {\n        return { type: 'noData' };\n      }\n    }\n  }\n\n  // if here, there is no active cell, or the active cell is no longer valid\n  if (currentCell != null) {\n    if (\n      _renderIncludesCell(\n        currentCell,\n        columnsArray,\n        tableData,\n        hasMore,\n        isPendingLayout,\n        hasFooters\n      )\n    ) {\n      return currentCell;\n    }\n    if (currentCell.type === 'data') {\n      if (tableData.length === 0 && hasMore) {\n        // pending 'data' override when 'loading' skeletons are shown\n        return { type: 'loading', columnKey: currentCell.columnKey };\n      }\n    } else if (currentCell.type === 'noData' && tableData.length === 0 && hasMore) {\n      // pending 'noData' override when 'loading' skeletons are shown\n      return { type: 'loading', columnKey: firstColumnKey };\n    }\n  }\n  if (\n    _renderIncludesCell(\n      defaultFirstCell,\n      columnsArray,\n      tableData,\n      hasMore,\n      isPendingLayout,\n      hasFooters\n    )\n  ) {\n    return defaultFirstCell;\n  }\n  return undefined;\n}\n","import { ComponentProps } from 'preact';\nimport { useCallback, useState, useRef } from 'preact/hooks';\nimport { Menu } from '../../UNSAFE_Menu';\nimport { CellContext, TableContextMenuConfig } from '../../UNSAFE_TableView';\nimport { useContextMenuGesture } from '../../hooks/UNSAFE_useContextMenuGesture';\nimport { ActiveCell, TableData } from '../Table';\nimport { getCellContextFromCell } from '../utils/TableFocusUtils';\n\ntype MenuProps = Pick<\n  ComponentProps<typeof Menu>,\n  'anchorRef' | 'initialFocus' | 'placement' | 'offsetValue' | 'isOpen'\n>;\n\nconst TOUCH_OFFSET_VALUE = 40;\n\nconst menuPropGestureStates: Record<\n  'mouse' | 'keyboard' | 'touch',\n  Omit<Required<MenuProps>, 'anchorRef' | 'isOpen'>\n> = {\n  mouse: {\n    initialFocus: 'menu',\n    placement: 'bottom-start',\n    offsetValue: 2\n  },\n  keyboard: {\n    initialFocus: 'firstItem',\n    placement: 'bottom-start',\n    offsetValue: 0\n  },\n  touch: {\n    initialFocus: 'menu',\n    placement: 'end',\n    offsetValue: TOUCH_OFFSET_VALUE\n  }\n};\n\nconst _initialMenuProps: MenuProps = {\n  isOpen: false,\n  initialFocus: 'menu',\n  placement: 'bottom-start',\n  offsetValue: 0,\n  anchorRef: { current: null }\n};\n\nexport const useContextMenu = <K extends string | number, D, C extends string>(\n  tableId: string,\n  tableData: TableData<K, D>[],\n  activeCell?: ActiveCell<K, C>,\n  contextMenuConfig?: TableContextMenuConfig<K, D, C>\n) => {\n  const [contextMenuContext, setContextMenuContext] = useState<CellContext<K, D, C>>();\n  const [menuProps, setMenuProps] = useState<MenuProps>(_initialMenuProps);\n  const currentCellElementRef = useRef<HTMLElement>();\n\n  const { triggerProps } = useContextMenuGesture(\n    ({ gesture, anchor, target }) => {\n      if (activeCell != null) {\n        const cellContext = getCellContextFromCell<K, D, C>(tableData, activeCell);\n        if (cellContext != null) {\n          // find the cell element the menu is being launched from\n          const cellElement = (target as HTMLElement).closest(\n            `[data-oj-table-focusable='${tableId}']`\n          ) as HTMLElement;\n          if (cellElement != null) {\n            currentCellElementRef.current = cellElement;\n            const anchorBasedOnGesture = gesture === 'keyboard' ? cellElement : anchor;\n            setContextMenuContext(cellContext);\n            setMenuProps({\n              ...menuPropGestureStates[gesture],\n              anchorRef: { current: anchorBasedOnGesture },\n              isOpen: true\n            });\n          }\n        }\n      }\n    },\n    {\n      isDisabled: !contextMenuConfig\n    }\n  );\n\n  const handleCloseContextMenu = useCallback<Required<ComponentProps<typeof Menu>>['onClose']>(\n    (detail) => {\n      // set focus back on the cell that was determined as the initial target\n      if (detail.reason === 'dismissed' || detail.reason === 'itemAction') {\n        currentCellElementRef.current?.focus({ preventScroll: true });\n      }\n      // close the menu\n      setMenuProps({ ..._initialMenuProps });\n    },\n    []\n  );\n\n  return {\n    menuProps: { ...menuProps, onClose: handleCloseContextMenu },\n    onClose: handleCloseContextMenu,\n    contextMenuContext: contextMenuContext,\n    contextMenuTriggerProps: triggerProps\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useEffect, useRef, useState } from 'preact/hooks';\nimport { useId } from '../../hooks/UNSAFE_useId';\nimport { useColorScheme } from '../../hooks/UNSAFE_useColorScheme';\nimport { useScale } from '../../hooks/UNSAFE_useScale';\nimport { TooltipContent } from '../../hooks/UNSAFE_useTooltip/TooltipContent';\nimport {\n  getGlobalTooltipManager,\n  getWrappedTooltipContent,\n  SHOW_TOOLTIP_DELAY,\n  HIDE_TOOLTIP_DELAY\n} from '../../utils/PRIVATE_tooltipUtils';\nimport { getElementFromCell } from '../utils/TableDomUtils';\nimport { cellComparator } from '../utils/TableFocusUtils';\nimport { hasTruncatedText } from '../utils/TableTooltipUtils';\nimport { Cell } from '../../UNSAFE_TableView';\n\ntype UseTruncationTooltipOptions = {\n  rootRef: RefObject<HTMLDivElement>;\n  tableId: string;\n};\n\n// delay small interaction times concerning a tooltip\nconst SMALL_INTERACTION_DELAY = 50;\nconst TABLE_HIDE_TOOLTIP_DELAY = Math.max(\n  Math.min(SHOW_TOOLTIP_DELAY - SMALL_INTERACTION_DELAY, HIDE_TOOLTIP_DELAY),\n  0\n);\n\n/**\n * Hook that manages cell template tooltip interactions on the Table when truncation is present.\n */\nexport function useTruncationTooltip<K, C>({ rootRef, tableId }: UseTruncationTooltipOptions) {\n  const globalTooltipManager = getGlobalTooltipManager();\n\n  const tooltipId = useId();\n\n  const tooltipCellRef = useRef<Cell<K, C>>();\n  const pendingShowTooltipCellRef = useRef<Cell<K, C>>();\n  const tooltipAnchorRef = useRef<HTMLElement>();\n  const tooltipTextRef = useRef<string>();\n  const [tooltipText, setTooltipText] = useState<string>();\n\n  const pointerDownRef = useRef<boolean>(false);\n  const pointerDownTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n\n  const showTooltipTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n  const hideTooltipTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n\n  // helper method for clearing the hide tooltip timeout\n  const _clearHideTooltipTimeout = useCallback(() => {\n    clearTimeout(hideTooltipTimeoutRef.current);\n    hideTooltipTimeoutRef.current = undefined;\n  }, []);\n\n  // helper method for clearing the show tooltip timeout\n  const _clearShowTooltipTimeout = useCallback(() => {\n    clearTimeout(showTooltipTimeoutRef.current);\n    showTooltipTimeoutRef.current = undefined;\n    pendingShowTooltipCellRef.current = undefined;\n  }, []);\n\n  // helper method for setting up the show tooltip timeout\n  const _setupShowTooltipTimeout = useCallback(() => {\n    showTooltipTimeoutRef.current = setTimeout(function () {\n      // when showing a tooltip, clear any pending 'clear tooltip timeouts'\n      if (hideTooltipTimeoutRef.current != null) {\n        _clearHideTooltipTimeout();\n      }\n      showTooltipTimeoutRef.current = undefined;\n      const cell = pendingShowTooltipCellRef.current;\n      const rootElement = rootRef.current;\n      if (rootElement != null && cell != null) {\n        const cellElement = getElementFromCell(rootElement, tableId, cell);\n        if (cellElement != null && hasTruncatedText(cellElement)) {\n          setTooltipText(String(cellElement.innerText).trim());\n          tooltipAnchorRef.current = cellElement;\n          tooltipCellRef.current = cell;\n        }\n      }\n      pendingShowTooltipCellRef.current = undefined;\n    }, SHOW_TOOLTIP_DELAY);\n  }, [rootRef, tableId, _clearHideTooltipTimeout]);\n\n  // helper method for setting up the hide tooltip timeout\n  const _setupHideTooltipTimeout = useCallback(() => {\n    hideTooltipTimeoutRef.current = setTimeout(function () {\n      // unlike in the showtooltip timeout logic, we do not want to clear\n      // pending show tooltip timeouts when clearing a tooltip as it could\n      // still be waiting to be shown in another location at this time\n      hideTooltipTimeoutRef.current = undefined;\n      setTooltipText(undefined);\n      tooltipAnchorRef.current = undefined;\n      tooltipCellRef.current = undefined;\n    }, TABLE_HIDE_TOOLTIP_DELAY);\n  }, []);\n\n  // callback method to signal a tooltip is desired on the given cell\n  const showTooltip = useCallback(\n    (anchorCell: Cell<K, C>) => {\n      if (cellComparator(tooltipCellRef.current, anchorCell)) {\n        // if the tooltip is already showing in the right cell, clear all timeouts\n        if (showTooltipTimeoutRef.current != null) {\n          _clearShowTooltipTimeout();\n        }\n        if (hideTooltipTimeoutRef.current != null) {\n          _clearHideTooltipTimeout();\n        }\n        return;\n      }\n      if (showTooltipTimeoutRef.current == null) {\n        // if no tooltip is already pending, start a new tooltip timeout\n        pendingShowTooltipCellRef.current = anchorCell;\n        _setupShowTooltipTimeout();\n      } else if (!cellComparator(pendingShowTooltipCellRef.current, anchorCell)) {\n        // if a different tooltip is already pending, start a new tooltip timeout\n        _clearShowTooltipTimeout();\n        pendingShowTooltipCellRef.current = anchorCell;\n        _setupShowTooltipTimeout();\n      }\n      if (tooltipCellRef.current != null && hideTooltipTimeoutRef.current == null) {\n        // if the tooltip is showing on a different cell, ensure a hide timeout is setup\n        _setupHideTooltipTimeout();\n      }\n    },\n    [\n      _setupShowTooltipTimeout,\n      _setupHideTooltipTimeout,\n      _clearShowTooltipTimeout,\n      _clearHideTooltipTimeout\n    ]\n  );\n\n  // callback method to signal the current tooltip is no longer desired\n  const hideTooltip = useCallback(\n    (isImmediate?: boolean) => {\n      // ignore hide tooltip calls if due to focus loss from a pointer down on the tooltip itself\n      if (pointerDownRef.current) {\n        return;\n      }\n      if (showTooltipTimeoutRef.current != null) {\n        _clearShowTooltipTimeout();\n      }\n      if (isImmediate) {\n        if (hideTooltipTimeoutRef.current != null) {\n          _clearHideTooltipTimeout();\n        }\n        setTooltipText(undefined);\n        tooltipAnchorRef.current = undefined;\n        tooltipCellRef.current = undefined;\n      } else if (hideTooltipTimeoutRef.current == null) {\n        _setupHideTooltipTimeout();\n      }\n    },\n    [_setupHideTooltipTimeout, _clearShowTooltipTimeout, _clearHideTooltipTimeout]\n  );\n\n  // Pointer move handler for the tooltip.\n  const _pointerMoveHandler = useCallback((_event: PointerEvent) => {\n    if (showTooltipTimeoutRef.current != null) {\n      clearTimeout(showTooltipTimeoutRef.current);\n      showTooltipTimeoutRef.current = undefined;\n      pendingShowTooltipCellRef.current = undefined;\n    }\n    if (hideTooltipTimeoutRef.current != null) {\n      clearTimeout(hideTooltipTimeoutRef.current);\n      hideTooltipTimeoutRef.current = undefined;\n    }\n  }, []);\n\n  // Pointer leave handler for the tooltip.\n  const _pointerLeaveHandler = useCallback(\n    (event: PointerEvent) => {\n      const targetElement = event.relatedTarget as HTMLElement;\n      if (targetElement != null && targetElement.closest(`#${tableId}`) != null) {\n        return;\n      }\n      hideTooltip();\n    },\n    [tableId, hideTooltip]\n  );\n\n  // Pointer down handler for the tooltip.\n  const _pointerDownHandler = useCallback((_event: PointerEvent) => {\n    pointerDownRef.current = true;\n    if (pointerDownTimeoutRef.current != null) {\n      clearTimeout(pointerDownTimeoutRef.current);\n    }\n    pointerDownTimeoutRef.current = setTimeout(function () {\n      pointerDownRef.current = false;\n      pointerDownTimeoutRef.current = undefined;\n    }, SMALL_INTERACTION_DELAY);\n  }, []);\n\n  // handles logic involving competing tooltips managed outside of the TableView.\n  // make sure this check runs BEFORE the rendered content is created below\n  const isOpenOverrideRef = useRef<boolean>(true);\n  if (tooltipText != null && tooltipText !== tooltipTextRef.current) {\n    isOpenOverrideRef.current = true;\n  }\n\n  const tooltipPointerProps = {\n    onPointerLeave: _pointerLeaveHandler,\n    onPointerMove: _pointerMoveHandler,\n    onPointerDown: _pointerDownHandler\n  };\n\n  // avoid applying undefined text after initial render completes as it can appear\n  // while the tooltip is going through its closing animation and looks broken\n  const renderRawContent = (\n    <TooltipContent\n      {...tooltipPointerProps}\n      id={tooltipId}\n      isOpen={isOpenOverrideRef.current}\n      isDatatip={false}>\n      {tooltipText != null ? tooltipText : tooltipTextRef.current}\n    </TooltipContent>\n  );\n\n  // make sure these are in sync AFTER the rendered content is created above - this helps ensure\n  // that empty text does not show up while the tooltip is going through a closing animation.\n  tooltipTextRef.current = tooltipText;\n\n  // offsets attempt to show the tooltip without overlapping content of nearby cells\n  const scale = useScale();\n  let mainAxisOffset = -8;\n  let crossAxisOffset = -14;\n  if (scale === 'md') {\n    mainAxisOffset = -7;\n    crossAxisOffset = -12;\n  } else if (scale === 'sm') {\n    mainAxisOffset = -6;\n    crossAxisOffset = -11;\n  }\n  const currentColorScheme = useColorScheme();\n  const tooltipContent =\n    tooltipAnchorRef.current != null\n      ? getWrappedTooltipContent(\n          renderRawContent,\n          'tooltip',\n          currentColorScheme,\n          tooltipAnchorRef as RefObject<HTMLElement>,\n          'end-top',\n          { mainAxis: mainAxisOffset, crossAxis: crossAxisOffset }\n        )\n      : undefined;\n\n  const destroyCallback = useCallback(() => {\n    hideTooltip(true);\n  }, [hideTooltip]);\n\n  useEffect(() => {\n    if (isOpenOverrideRef.current && tooltipAnchorRef.current != null) {\n      globalTooltipManager.register(destroyCallback);\n    } else {\n      globalTooltipManager.unregister(destroyCallback);\n    }\n  }, [tooltipAnchorRef, destroyCallback, tooltipText, globalTooltipManager]);\n\n  return { tooltipContent, tooltipId, showTooltip, hideTooltip, tooltipAnchorRef };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useEffect, useMemo, useRef, useState, MutableRef } from 'preact/hooks';\nimport {\n  getElementContainsFunc,\n  handleEnterActionableMode,\n  handleWrapActionableFocus\n} from '../../utils/PRIVATE_collectionUtils';\nimport {\n  FocusableElement,\n  allTabbableElements,\n  getActiveElement,\n  getBodyElement,\n  isTabbableElement\n} from '../../utils/PRIVATE_tabbableUtils';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  CurrencyStatus,\n  SizingInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { getCellType, getElementFromCell, logicalCellExtractor } from '../utils/TableDomUtils';\nimport {\n  applyCurrentCellOverride,\n  cellComparator,\n  determineActiveCell,\n  isTransientCell\n} from '../utils/TableFocusUtils';\nimport { applyScrollDetail } from '../utils/TableScrollUtils';\nimport { handleNavigationTooltipGesture } from '../utils/TableTooltipUtils';\nimport { Cell, CellOverride, CurrentCellDetail } from '../../UNSAFE_TableView';\n\ntype UseFocusHandlingProps<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  hasMore: boolean;\n  hasFooters: boolean;\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  sizingInfoRef: MutableRef<SizingInfo>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  cellSupportsTabbable: (cell: ActiveCell<K, C>) => boolean;\n  fullColumnWidths?: number[];\n  currentCellOverride?: CellOverride<K, C>;\n  onPersistCurrentCell?: (detail: CurrentCellDetail<K, C>) => void;\n  showTooltip: (cell: Cell<K, C>) => void;\n  hideTooltip: (isImmediate?: boolean) => void;\n  isPendingLayout: boolean;\n  isEmbeddedSelect: boolean;\n  isDataLoaded: boolean;\n};\n\n// constant timeout values for delays following a input gesture until enabling focus rings\nconst MOUSE_FOCUS_SHIFT_TIMEOUT = 100;\nconst TOUCH_FOCUS_SHIFT_TIMEOUT = 200;\n\n// constant event.key values that trigger focus ring logic\nconst NAVIGATION_KEYS = [\n  ' ',\n  'F2',\n  'Enter',\n  'Esc', // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n  'Escape',\n  'ArrowLeft',\n  'ArrowUp',\n  'ArrowRight',\n  'ArrowDown',\n  'Home',\n  'End',\n  'PageUp',\n  'PageDown'\n];\n\n// constant event.key values that trigger 'scroll to current' logic\nconst SCROLL_KEYS = [\n  ' ',\n  'F2',\n  'Enter',\n  'Esc', // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n  'Escape'\n];\n\n/**\n * Hook that manages focus interactions on the Preact Table\n */\nexport function useFocusHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  isRtl,\n  tableData,\n  hasMore,\n  hasFooters,\n  columnsArray,\n  sizingInfoRef,\n  selectionExtensionElementRef,\n  cellSupportsTabbable,\n  fullColumnWidths,\n  currentCellOverride,\n  onPersistCurrentCell,\n  showTooltip,\n  hideTooltip,\n  isPendingLayout,\n  isEmbeddedSelect,\n  isDataLoaded\n}: UseFocusHandlingProps<K, D, C>) {\n  // tracks whether the most recent 'blur' was caused by focus being lost by the browser window (or iframe)\n  const blurFromWindowRef = useRef<boolean>(false);\n\n  // tracks focus loss during render cycle for potential focus recapture cases\n  const isRenderCycle = useRef<boolean>(true);\n  isRenderCycle.current = true;\n  const blurredRenderCycleElementRef = useRef<FocusableElement | null>(null);\n  const isPendingLayoutFocusRef = useRef<boolean>(false);\n\n  // track current 'focus info' state\n  const hasFocusRef = useRef<boolean>(false);\n  const [isTabbableMode, setIsTabbableMode] = useState<boolean>(false);\n  const [isShowFocusRing, setIsShowFocusRing] = useState<boolean>(false);\n\n  // track pointer down information\n  const recentPointerRef = useRef<boolean>(false);\n  const pointerTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const isShowFocusRingOverrideRef = useRef<boolean | null>(null);\n\n  // track the active and current cell information\n  const [activeCell, setActiveCell] = useState<ActiveCell<K, C> | undefined>(undefined);\n  const currencyStatusRef = useRef<CurrencyStatus<K, D, C>>({\n    hasPendingCurrentCellOverride: false,\n    hasPendingCurrentCellOverrideScroll: false\n  });\n\n  const currentActiveCell = determineActiveCell<K, D, C>(\n    columnsArray,\n    currencyStatusRef,\n    tableData,\n    hasMore,\n    isPendingLayout,\n    isEmbeddedSelect,\n    hasFooters,\n    currentCellOverride\n  );\n\n  // intercept onPersistCurrentCell calls to ensure internal state is updated appropriately\n  const onActiveCellChanged = useMemo(() => {\n    return (detail: ActiveCellDetail<K, C>, isSelectionExtension?: boolean) => {\n      const newActiveCell = detail.value;\n      if (!cellComparator(currencyStatusRef.current.activeCell, newActiveCell)) {\n        setActiveCell(newActiveCell);\n        currencyStatusRef.current.activeCell = newActiveCell;\n        if (!isTransientCell(newActiveCell)) {\n          const newCurrentCell = newActiveCell as Cell<K, C>;\n          // only update current cell when 'active' is not one of the transient 'skeleton' regions\n          if (onPersistCurrentCell != null) {\n            onPersistCurrentCell({ value: newCurrentCell });\n          }\n          currencyStatusRef.current.currentCell = newCurrentCell;\n\n          // make sure pending current cell override states are updated on current changed\n          if (newCurrentCell != null) {\n            currencyStatusRef.current.previousEmbeddedSelectCurrentCell = newCurrentCell;\n          }\n          currencyStatusRef.current.currentCellOverride = currentCellOverride;\n          currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n          currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n        } else if (newActiveCell?.type === 'loadMore') {\n          currencyStatusRef.current.loadMoreInitialData = tableData;\n        }\n        if (!isSelectionExtension) {\n          selectionExtensionElementRef.current = undefined;\n        }\n      }\n    };\n  }, [currentCellOverride, tableData, onPersistCurrentCell, selectionExtensionElementRef]);\n\n  // Helper function to set the Table's focus tracking state to reflect that it is inactive.\n  const _setAsInactive = useCallback(() => {\n    hasFocusRef.current = false;\n    isPendingLayoutFocusRef.current = false;\n\n    setIsTabbableMode(false);\n    setIsShowFocusRing(false);\n    hideTooltip();\n  }, [hideTooltip]);\n\n  // Helper function to set the Table's focus tracking state to reflect that one of its cells has focus.\n  const _enableNavigationMode = useCallback(\n    (cell: ActiveCell<K, C>, skipScrollCellIntoView?: boolean) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null && scrollerElement != null) {\n        setIsTabbableMode(false);\n        const focusRingState =\n          isShowFocusRingOverrideRef.current !== null\n            ? isShowFocusRingOverrideRef.current\n            : !recentPointerRef.current;\n        setIsShowFocusRing(focusRingState);\n        if (focusRingState) {\n          handleNavigationTooltipGesture(rootElement, tableId, cell, showTooltip, hideTooltip);\n        }\n        if (!recentPointerRef.current && !skipScrollCellIntoView) {\n          applyScrollDetail(\n            rootElement,\n            scrollerElement,\n            viewportInfo,\n            tableId,\n            columnsArray,\n            sizingInfoRef.current,\n            { cell: cell, locationX: 'inView', locationY: 'inView' },\n            isRtl,\n            fullColumnWidths\n          );\n        }\n        onActiveCellChanged({ value: cell });\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      sizingInfoRef,\n      isRtl,\n      onActiveCellChanged,\n      fullColumnWidths,\n      showTooltip,\n      hideTooltip\n    ]\n  );\n\n  // Helper function to set the Table's focus tracking state to reflect that it is tabbable.\n  const _enableTabbableMode = useCallback(\n    (cell: ActiveCell<K, C>, isKeyboard?: boolean, skipScrollCellIntoView?: boolean) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null && scrollerElement != null) {\n        setIsTabbableMode(true);\n        if (!isKeyboard) {\n          setIsShowFocusRing(false);\n          onActiveCellChanged({ value: cell });\n          if (!recentPointerRef.current && !skipScrollCellIntoView) {\n            applyScrollDetail(\n              rootElement,\n              scrollerElement,\n              viewportInfo,\n              tableId,\n              columnsArray,\n              sizingInfoRef.current,\n              { cell: cell, locationX: 'inView', locationY: 'inView' },\n              isRtl,\n              fullColumnWidths\n            );\n          }\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      sizingInfoRef,\n      isRtl,\n      onActiveCellChanged,\n      fullColumnWidths\n    ]\n  );\n\n  // Helper function to set the Table's focus tracking state to reflect that a user has\n  // exited tabbable mode via the keyboard (esc or 'F2')\n  const _disableTabbableMode = useCallback(\n    (cell: ActiveCell<K, C>) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        setIsTabbableMode(false);\n        const cellElement = getElementFromCell(rootElement, tableId, cell);\n        if (cellElement != null) {\n          cellElement.focus({ preventScroll: true });\n        } else {\n          rootElement.focus({ preventScroll: true });\n        }\n      }\n    },\n    [rootRef, tableId]\n  );\n\n  const notifyFocusFromPointer = useCallback((isTouch: boolean) => {\n    if (pointerTimerRef.current != null) {\n      clearTimeout(pointerTimerRef.current);\n    }\n    recentPointerRef.current = true;\n    pointerTimerRef.current = setTimeout(\n      () => {\n        recentPointerRef.current = false;\n      },\n      isTouch ? TOUCH_FOCUS_SHIFT_TIMEOUT : MOUSE_FOCUS_SHIFT_TIMEOUT\n    );\n  }, []);\n\n  // PointerDown handler for the outer Table. Focus transfers that occur following a pointerdown\n  // on desktop devices should not result in a focus ring being shown on the focused element\n  const _pointerDownHandler = useCallback(\n    (event: PointerEvent) => {\n      if (isShowFocusRing) {\n        setIsShowFocusRing(false);\n      }\n      if (event.pointerType !== 'touch') {\n        notifyFocusFromPointer(false);\n      }\n    },\n    [isShowFocusRing, notifyFocusFromPointer]\n  );\n\n  // PointerUp handler for the outer Table. Focus transfers that occur following a pointerup\n  // on any type of device should not result in a focus ring being shown on the focused element\n  const _pointerUpHandler = useCallback(\n    (event: PointerEvent) => {\n      notifyFocusFromPointer(event.pointerType === 'touch');\n    },\n    [notifyFocusFromPointer]\n  );\n\n  // Focus handler for the outer Table. On focus, a focusable area needs to be 'active'.\n  // If an 'active' area already exists, nothing further is needed. Otherwise, the first\n  // focusable element should be made 'active'.\n  const _onFocusHandler = (event: FocusEvent) => {\n    hasFocusRef.current = true;\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (rootElement != null) {\n      // don't scroll active into view if previous blur was due to window focus loss\n      const skipScrollCellIntoView = blurFromWindowRef.current || isPendingLayout;\n      blurFromWindowRef.current = false;\n\n      const targetElement = event.target as HTMLElement;\n      if (targetElement === rootElement || targetElement === scrollerElement) {\n        if (currentActiveCell != null) {\n          _enableNavigationMode(currentActiveCell, skipScrollCellIntoView);\n        }\n      } else {\n        const cell = logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray);\n        if (cell != null) {\n          if (getCellType(targetElement) != null) {\n            // handle individual focusable regions receiving focus\n            _enableNavigationMode(cell, skipScrollCellIntoView);\n          } else {\n            _enableTabbableMode(cell, false, skipScrollCellIntoView);\n          }\n        }\n      }\n    }\n    isShowFocusRingOverrideRef.current = null;\n  };\n\n  // Blur handler for the outer Table. When a blur is caused by the browser window itself\n  // losing focus (changing tabs or leaving an iframe for example), an eventual re-focus due\n  // to the window re-gaining focus needs to be handled differently (no auto-scroll mostly).\n  const _onBlurHandler = useCallback(\n    (event: FocusEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        if (event.target === document.activeElement) {\n          // save focus ring state so it's set once focus comes back\n          isShowFocusRingOverrideRef.current = isShowFocusRing;\n        }\n        const relatedTarget = event.relatedTarget as Element;\n        const isUnknownRelatedTarget = relatedTarget == null;\n        blurFromWindowRef.current = isUnknownRelatedTarget;\n        if (isUnknownRelatedTarget || !getElementContainsFunc(rootElement, true)(relatedTarget)) {\n          _setAsInactive();\n          if (isRenderCycle.current) {\n            // store element that loses focus during a render cycle for recapturing focus logic\n            blurredRenderCycleElementRef.current = event.target as FocusableElement;\n          }\n        }\n      }\n    },\n    [rootRef, isShowFocusRing, _setAsInactive]\n  );\n\n  // KeyDown handler for the outer Table. This specific handler tracks 'focus' transfer keys\n  // Esc, F2, Enter, and Tab. It also ensures the active cell is scrolled into view on any key\n  const _onKeyDownHandler = useCallback(\n    (event: KeyboardEvent) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null && scrollerElement != null) {\n        const isNavigationKey = NAVIGATION_KEYS.indexOf(event.key) > -1;\n        if (isNavigationKey) {\n          if (pointerTimerRef.current != null) {\n            clearTimeout(pointerTimerRef.current);\n          }\n          pointerTimerRef.current = null;\n          recentPointerRef.current = false;\n        }\n        if (isPendingLayout) {\n          if (isNavigationKey) {\n            setIsShowFocusRing(true);\n          }\n        } else if (activeCell != null) {\n          if (cellSupportsTabbable(activeCell)) {\n            if (event.key === 'F2') {\n              if (isTabbableMode) {\n                _disableTabbableMode(activeCell);\n              } else {\n                _enableTabbableMode(activeCell, true);\n              }\n            } else if (event.key === 'Esc' || event.key === 'Escape') {\n              // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n              _disableTabbableMode(activeCell);\n            } else if (event.key === 'Enter' && !isTabbableMode) {\n              _enableTabbableMode(activeCell, true);\n            }\n          }\n          if (!isTabbableMode) {\n            if (isNavigationKey) {\n              setIsShowFocusRing(true);\n            }\n            if (SCROLL_KEYS.indexOf(event.key) > -1) {\n              applyScrollDetail(\n                rootElement,\n                scrollerElement,\n                viewportInfo,\n                tableId,\n                columnsArray,\n                sizingInfoRef.current,\n                { cell: activeCell, locationX: 'inView', locationY: 'inView' },\n                isRtl,\n                fullColumnWidths\n              );\n            }\n          }\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      sizingInfoRef,\n      isRtl,\n      isTabbableMode,\n      activeCell,\n      cellSupportsTabbable,\n      fullColumnWidths,\n      isPendingLayout,\n      _enableTabbableMode,\n      _disableTabbableMode\n    ]\n  );\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onStartFocusTracking = useCallback(\n    (detail: {\n      activeElement: FocusableElement;\n      hasFocusWithin: boolean;\n      tabbableElements: FocusableElement[];\n    }) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null && activeCell != null) {\n        handleEnterActionableMode(\n          detail.hasFocusWithin && getCellType(detail.activeElement) == null,\n          allTabbableElements(\n            getElementFromCell(rootElement, tableId, activeCell) as FocusableElement\n          ),\n          (value?: ActiveCell<K, D>) => {\n            setIsTabbableMode(value != undefined);\n          }\n        );\n      }\n    },\n    [rootRef, activeCell, tableId]\n  );\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onFocusStartEdge = useCallback((detail: { tabbableElements: FocusableElement[] }) => {\n    handleWrapActionableFocus(true, detail.tabbableElements, (value?: ActiveCell<K, D>) => {\n      setIsTabbableMode(value != undefined);\n    });\n  }, []);\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onFocusEndEdge = useCallback((detail: { tabbableElements: FocusableElement[] }) => {\n    handleWrapActionableFocus(false, detail.tabbableElements, (value?: ActiveCell<K, D>) => {\n      setIsTabbableMode(value != undefined);\n    });\n  }, []);\n\n  // Ensure focus is properly set at the completion of every render cycle\n  // NO DEPENDENCY ARRAY HERE TO ENSURE THIS RUNS ON EVERY RENDER CYCLE\n  useEffect(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (rootElement != null && scrollerElement != null) {\n      // ensure current-cell-override is up to date on each render\n      applyCurrentCellOverride(\n        rootElement,\n        scrollerElement,\n        viewportInfo,\n        tableId,\n        tableData,\n        columnsArray,\n        sizingInfoRef,\n        currencyStatusRef,\n        onActiveCellChanged,\n        isEmbeddedSelect,\n        isPendingLayout,\n        isDataLoaded,\n        isRtl,\n        currentCellOverride,\n        fullColumnWidths\n      );\n\n      const blurredRenderCycleElement = blurredRenderCycleElementRef.current;\n      blurredRenderCycleElementRef.current = null;\n      isRenderCycle.current = false;\n\n      const activeElement = getActiveElement(rootElement);\n      // if we were tracking focus during the render cycle, ensure we recapture focus if needed\n      if (\n        blurredRenderCycleElement != null &&\n        activeElement === getBodyElement(rootElement) &&\n        (!getElementContainsFunc(rootElement, true)(blurredRenderCycleElement) ||\n          !isTabbableElement(blurredRenderCycleElement, true))\n      ) {\n        rootElement.focus({ preventScroll: true });\n        return;\n      }\n      if (hasFocusRef.current) {\n        if (\n          currentActiveCell != null &&\n          cellComparator(activeCell, currencyStatusRef.current.activeCell)\n        ) {\n          // ensure real browser focus is on the correct cell element\n          const cellElement = getElementFromCell(rootElement, tableId, currentActiveCell);\n          if (cellElement != null) {\n            // cell is valid, so set focus on it if needed\n            if (\n              (!isTabbableMode && activeElement !== cellElement) ||\n              (isTabbableMode && !getElementContainsFunc(cellElement, true)(activeElement))\n            ) {\n              cellElement.focus({ preventScroll: true });\n            }\n          }\n        }\n      }\n    }\n  });\n\n  return {\n    focusHandlingProps: {\n      onPointerDown: _pointerDownHandler,\n      onPointerUp: _pointerUpHandler,\n      onFocus: _onFocusHandler,\n      onBlur: _onBlurHandler,\n      onKeyDown: _onKeyDownHandler\n    },\n    activeCell,\n    onActiveCellChanged,\n    currentCell: currencyStatusRef.current.currentCell,\n    currentActiveCell,\n    isShowFocusRing,\n    isTabbableMode,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { getRowIndexForRowElement, getElementFromCell } from './TableDomUtils';\nimport { ActiveCell, TableColumn, TableData } from '../Table';\nimport { RowActionDetail, SortCriterionDetail } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to get the row action context from a pointer or keyboard event\n */\nfunction _getRowActionGestureContext<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  tableData: TableData<K, D>[],\n  targetElement: HTMLElement,\n  targetCell?: ActiveCell<K, C>\n) {\n  let rowKey: K | null;\n  let rowElement;\n  if (targetCell?.type === 'data') {\n    rowKey = targetCell.rowKey;\n    const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);\n    if (targetCellElement != null) {\n      rowElement = targetCellElement.parentElement;\n    }\n  } else {\n    rowKey = keyExtractor<K>(targetElement, `[data-oj-table-data-row='${tableId}']`);\n    if (rowKey != null) {\n      rowElement = targetElement.closest(`[data-oj-table-data-row='${tableId}']`);\n    }\n  }\n  if (rowKey != null && rowElement != null) {\n    const rowIndex = getRowIndexForRowElement(rootElement, tableId, rowElement as HTMLElement);\n    if (rowIndex != null) {\n      return {\n        key: rowKey,\n        data: tableData[rowIndex].data\n      };\n    }\n  }\n  return undefined;\n}\n\n/**\n * Helper function to handle a row action gesture from a pointer or keyboard event\n */\nexport function handleRowActionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  tableData: TableData<K, D>[],\n  onRowAction: (detail: RowActionDetail<K, D>) => void,\n  targetElement: HTMLElement,\n  targetCell?: ActiveCell<K, C>\n) {\n  const rowActionContext = _getRowActionGestureContext(\n    rootElement,\n    tableId,\n    tableData,\n    targetElement,\n    targetCell\n  );\n  if (rowActionContext != null) {\n    onRowAction({ context: rowActionContext, target: targetElement });\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper function to determine if a pointer or keyboard event should trigger a sort action gesture\n */\nfunction _isSortActionGesture<K, D, C>(columnsArray: TableColumn<K, D, C>[], columnKey: C) {\n  for (const column of columnsArray) {\n    if (column.key === columnKey) {\n      return column.value.sortable === 'enabled';\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a sort action gesture\n */\nexport function handleSortActionGesture<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  columnKey: C,\n  onSortCriterionChange: (detail: SortCriterionDetail<C>) => void,\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[]\n) {\n  if (_isSortActionGesture(columnsArray, columnKey)) {\n    let sortDirection;\n    if (sortCriterion != null) {\n      for (const criterion of sortCriterion) {\n        if (criterion.key === columnKey) {\n          sortDirection = criterion.sortDirection;\n          break;\n        }\n      }\n    }\n    const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';\n    onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);\n    return true;\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { ActiveCell, ActiveCellDetail, SizingInfo, TableColumn, ViewportInfo } from '../Table';\nimport {\n  getBoundaryColumnKey,\n  getElementFromCell,\n  getFirstFocusableRowKey,\n  getLastFocusableRowKey,\n  getRowKey,\n  hasFooterCells,\n  hasNoDataCell,\n  getScrollerBottomOffset,\n  getRowKeyForRowIndex,\n  getRowIndexForRowKey\n} from './TableDomUtils';\nimport { cellComparator } from './TableFocusUtils';\nimport { applyScrollDetail, getVerticalScrollPosition } from './TableScrollUtils';\nimport { findElementByKey } from '../../utils/PRIVATE_collectionUtils';\n\n/**\n * Helper function to handle an 'Up' or 'Down' arrow key press.\n * Up - Moves to the same cell in the previous row (including headers and footers). No op if already on the first row.\n * Down - Moves to the same cell in the next row (including headers and footers). No op if already on the last row.\n */\nexport function handleAdjacentRowGesture<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isSelectionExtension?: boolean) => void,\n  isPrevious: boolean,\n  isExtendSelectionGesture: boolean,\n  isRtl: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  fullColumnWidths?: number[]\n) {\n  const firstColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n  if (firstColumnKey == null) {\n    return;\n  }\n  let newCell = initialCell;\n  const cellType = initialCell.type;\n  if (cellType === 'noData') {\n    const newColumnKey = firstColumnKey;\n    if (isPrevious) {\n      newCell = { columnKey: newColumnKey, type: 'header' };\n      onActiveCellChanged({ value: newCell });\n    } else if (hasFooterCells(rootElement, tableId)) {\n      newCell = { columnKey: newColumnKey, type: 'footer' };\n      onActiveCellChanged({ value: newCell });\n    }\n  } else if (cellType === 'loading') {\n    if (isPrevious) {\n      newCell = { columnKey: initialCell.columnKey, type: 'header' };\n      onActiveCellChanged({ value: newCell });\n    } else if (hasFooterCells(rootElement, tableId)) {\n      newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n      onActiveCellChanged({ value: newCell });\n    }\n  } else if (cellType === 'loadMore') {\n    if (isPrevious) {\n      const rowKey = getLastFocusableRowKey<K>(rootElement, tableId);\n      if (rowKey != null) {\n        newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n        onActiveCellChanged({ value: newCell });\n      }\n    } else if (hasFooterCells(rootElement, tableId)) {\n      newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n      onActiveCellChanged({ value: newCell });\n    }\n  } else if (cellType !== 'pending') {\n    if (cellType === 'data') {\n      const currentRowKey = initialCell.rowKey;\n      const currentRowElement = findElementByKey(\n        rootElement,\n        currentRowKey,\n        `[data-oj-table-data-row='${tableId}']`\n      );\n      if (currentRowElement != null) {\n        const adjacentRowElement = isPrevious\n          ? (currentRowElement.previousElementSibling as HTMLElement)\n          : (currentRowElement.nextElementSibling as HTMLElement);\n        // if adjacent row has no children, it is the 'buffer' row used for height sizing\n        if (adjacentRowElement != null && adjacentRowElement.children.length > 0) {\n          const rowKey = getRowKey<K>(adjacentRowElement);\n          if (rowKey != null) {\n            newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n            onActiveCellChanged({ value: newCell }, isExtendSelectionGesture);\n          } else if (!isExtendSelectionGesture) {\n            newCell = { columnKey: initialCell.columnKey, type: 'loadMore' };\n            if (getElementFromCell(rootElement, tableId, newCell) != null) {\n              onActiveCellChanged({ value: newCell });\n            }\n          }\n        } else if (!isExtendSelectionGesture && isPrevious) {\n          newCell = { columnKey: initialCell.columnKey, type: 'header' };\n          onActiveCellChanged({ value: newCell });\n        } else if (!isExtendSelectionGesture && hasFooterCells(rootElement, tableId)) {\n          newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n          onActiveCellChanged({ value: newCell });\n        }\n      }\n    } else if (cellType === 'header' && !isPrevious) {\n      const rowKey = getFirstFocusableRowKey<K>(rootElement, tableId);\n      if (rowKey != null) {\n        newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n        onActiveCellChanged({ value: newCell });\n      } else if (hasNoDataCell(rootElement, tableId)) {\n        newCell = { type: 'noData' };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        newCell = { columnKey: initialCell.columnKey, type: 'loading' };\n        if (getElementFromCell(rootElement, tableId, newCell) != null) {\n          onActiveCellChanged({ value: newCell });\n        } else if (hasFooterCells(rootElement, tableId)) {\n          newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n          onActiveCellChanged({ value: newCell });\n        }\n      }\n    } else if (cellType === 'footer' && isPrevious) {\n      if (hasNoDataCell(rootElement, tableId)) {\n        newCell = { type: 'noData' };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        newCell = { columnKey: initialCell.columnKey, type: 'loading' };\n        if (getElementFromCell(rootElement, tableId, newCell) != null) {\n          onActiveCellChanged({ value: newCell });\n        } else {\n          newCell = { columnKey: initialCell.columnKey, type: 'loadMore' };\n          if (getElementFromCell(rootElement, tableId, newCell) != null) {\n            onActiveCellChanged({ value: newCell });\n          } else {\n            const rowKey = getLastFocusableRowKey<K>(rootElement, tableId);\n            if (rowKey != null) {\n              newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n              onActiveCellChanged({ value: newCell });\n            } else {\n              newCell = { columnKey: initialCell.columnKey, type: 'header' };\n              onActiveCellChanged({ value: newCell });\n            }\n          }\n        }\n      }\n    }\n  }\n  if (!cellComparator(initialCell, newCell)) {\n    hideTooltip(true);\n  }\n  applyScrollDetail(\n    rootElement,\n    scrollerElement,\n    viewportInfo,\n    tableId,\n    columnsArray,\n    sizingInfoRef.current,\n    { cell: newCell, locationX: 'inView', locationY: 'inView' },\n    isRtl,\n    fullColumnWidths\n  );\n}\n\n/**\n * Helper function to handle a 'PageUp' or 'PageDown' arrow key press.\n * PageUp - Moves to the same cell in the first visible row in the current viewport,\n * and scrolls the Table so it becomes the last visible row in the viewport when able.\n * PageDown - Moves to the same cell in the last visible row in the current viewport,\n * and scrolls the Table so it becomes the first visible row in the viewport when able.\n */\nexport function handlePageRowGesture<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isExtendSelectionGesture?: boolean) => void,\n  isPrevious: boolean,\n  isRtl: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  fullColumnWidths?: number[]\n) {\n  if (initialCell.type !== 'noData' && initialCell.type !== 'pending') {\n    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    if (rowElements.length > 0) {\n      const verticalScrollPosition = getVerticalScrollPosition(\n        rootElement,\n        scrollerElement,\n        tableId\n      );\n      const verticalRowIndex = getRowIndexForRowKey(\n        rootElement,\n        tableId,\n        verticalScrollPosition.rowKey!\n      );\n      let targetRowIndex;\n      if (isPrevious) {\n        if (verticalScrollPosition.offsetY === 0) {\n          targetRowIndex = Math.max(verticalRowIndex! - 1, 0);\n        } else {\n          targetRowIndex = verticalRowIndex!;\n        }\n      } else {\n        const scrollerRect = scrollerElement.getBoundingClientRect();\n        const scrollbarHeight =\n          sizingInfoRef.current.boxHeight! - sizingInfoRef.current.contentHeight!;\n        const scrollerBottom =\n          scrollerRect.bottom + getScrollerBottomOffset(rootElement, tableId) + scrollbarHeight;\n        targetRowIndex = verticalRowIndex!;\n        while (rowElements.length > targetRowIndex + 1) {\n          targetRowIndex += 1;\n          const elementBottom = rowElements[targetRowIndex].getBoundingClientRect().bottom;\n          if (elementBottom > scrollerBottom) {\n            break;\n          }\n        }\n      }\n      const newRowKey = getRowKeyForRowIndex<K>(rootElement, tableId, targetRowIndex);\n      if (newRowKey != null) {\n        const newCell: ActiveCell<K, C> = {\n          rowKey: newRowKey,\n          columnKey: initialCell.columnKey,\n          type: 'data'\n        };\n        if (newRowKey !== initialCell.rowKey) {\n          onActiveCellChanged({ value: newCell });\n        }\n        if (!cellComparator(initialCell, newCell)) {\n          hideTooltip(true);\n        }\n        applyScrollDetail(\n          rootElement,\n          scrollerElement,\n          viewportInfo,\n          tableId,\n          columnsArray,\n          sizingInfoRef.current,\n          { cell: newCell, locationX: 'inView', locationY: isPrevious ? 'bottom' : 'top' },\n          isRtl,\n          fullColumnWidths\n        );\n      }\n    }\n  }\n}\n\n/**\n * Helper function to get the column key next to the given column key in the specified direction. Returns\n * null if there is no adjacent column in the direction specified.\n */\nfunction _getAdjacentColumnKey<K, D, C>(\n  initialKey: C,\n  columnsArray: TableColumn<K, D, C>[],\n  isPrevious: boolean\n) {\n  let currentIndex = -1;\n  const columnsCount = columnsArray.length;\n  for (let i = 0; i < columnsCount; i++) {\n    if (columnsArray[i].key === initialKey) {\n      currentIndex = i;\n      break;\n    }\n  }\n  if (isPrevious && currentIndex !== 0) {\n    return columnsArray[currentIndex - 1].key;\n  } else if (!isPrevious && currentIndex !== columnsCount - 1) {\n    return columnsArray[currentIndex + 1].key;\n  }\n  return undefined;\n}\n\n/**\n * Helper function to handle a 'Previous' or 'Next' arrow key press.\n * Previous - Moves to the previous cell in the current row. No op if already on the first cell in that row.\n * Next - Moves to the next cell in the current row. No op if already on the last cell in that row.\n */\nexport function handleAdjacentColumnGesture<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isExtendSelectionGesture?: boolean) => void,\n  isPrevious: boolean,\n  isRtl: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  fullColumnWidths?: number[]\n) {\n  let newCell = initialCell;\n  const cellType = initialCell.type;\n  if (cellType === 'data' || cellType === 'header' || cellType === 'footer') {\n    const initialKey = initialCell.columnKey;\n    const newKey = _getAdjacentColumnKey(initialKey, columnsArray, isPrevious);\n    if (newKey != null) {\n      if (cellType === 'data') {\n        newCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        newCell = { columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell });\n      }\n    }\n  }\n  if (!cellComparator(initialCell, newCell)) {\n    hideTooltip(true);\n  }\n  applyScrollDetail(\n    rootElement,\n    scrollerElement,\n    viewportInfo,\n    tableId,\n    columnsArray,\n    sizingInfoRef.current,\n    { cell: newCell, locationX: 'inView', locationY: 'inView' },\n    isRtl,\n    fullColumnWidths\n  );\n}\n\n/**\n * Helper function to handle a 'Home' or 'End' key press.\n * Home - Jumps to the first cell in the current row. No op if already on the first cell in that row.\n * Ctrl/Cmd + Home - Jumps to the first cell in the first data row. If no data rows are present,\n * jumps to the first cell in the current region (header or footer). No op if already on that cell.\n * End - Jumps to the last cell in the current row. No op if already on the last cell in that row.\n * Ctrl/Cmd + End - Jumps to the last cell in the last data row. If no data rows are present,\n * jumps to the last cell in the current region (header or footer). No op if already on that cell.\n */\nexport function handleJumpColumnGesture<K extends string | number, D, C>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isExtendSelectionGesture?: boolean) => void,\n  isPrevious: boolean,\n  includeRows: boolean,\n  isRtl: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  fullColumnWidths?: number[]\n) {\n  const newKey = getBoundaryColumnKey<K, D, C>(columnsArray, isPrevious);\n  if (newKey == null) {\n    return;\n  }\n  let newCell = initialCell;\n  const cellType = initialCell.type;\n  if (cellType === 'data' || cellType === 'header' || cellType === 'footer') {\n    const initialKey = initialCell.columnKey;\n    if (includeRows) {\n      if (hasNoDataCell(rootElement, tableId)) {\n        newCell = { type: 'noData' };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        const newRowKey = isPrevious\n          ? getFirstFocusableRowKey<K>(rootElement, tableId)\n          : getLastFocusableRowKey<K>(rootElement, tableId);\n        if (newRowKey != null) {\n          newCell = { rowKey: newRowKey, columnKey: newKey, type: 'data' };\n          onActiveCellChanged({ value: newCell });\n        }\n      }\n    } else if (newKey !== initialKey) {\n      if (cellType === 'data') {\n        newCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell });\n      } else {\n        newCell = { columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell });\n      }\n    }\n  }\n  if (!cellComparator(initialCell, newCell)) {\n    hideTooltip(true);\n  }\n  applyScrollDetail(\n    rootElement,\n    scrollerElement,\n    viewportInfo,\n    tableId,\n    columnsArray,\n    sizingInfoRef.current,\n    { cell: newCell, locationX: 'inView', locationY: 'inView' },\n    isRtl,\n    fullColumnWidths\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { Keys, containsKey, isSameKey, addKey, removeKey } from '../../utils/UNSAFE_keys';\nimport { ActiveCell, ActiveCellDetail, SizingInfo, TableColumn, ViewportInfo } from '../Table';\nimport {\n  logicalCellExtractor,\n  getCellType,\n  getRowKey,\n  getRowKeyForRowIndex,\n  getRowIndexForRowElement,\n  getElementFromCell,\n  getColumnIndexForHeaderFooterElement\n} from './TableDomUtils';\nimport { applyScrollDetail } from './TableScrollUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport { TableSelectionDetail } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to handle a selection gesture (click, spacebar, etc...)\n */\nexport function handleSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  isMultiSelectGesture: boolean,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isDropDownSelection: boolean,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const emptyKeys = { all: false, keys: new Set() };\n  let selectedRows = selected?.row != null ? selected.row : (emptyKeys as Keys<K>);\n  let selectedColumns = selected?.column != null ? selected.column : (emptyKeys as Keys<C>);\n\n  const newRowKey = keyExtractor<K>(targetElement, `[data-oj-table-data-row='${tableId}']`);\n  if (newRowKey != null) {\n    if (selectionMode?.row === 'single' || selectionMode?.row === 'multiple') {\n      const isMultiSelectRowGesture = isMultiSelectGesture || isDropDownSelection;\n      if (selectedRows == null) {\n        selectedRows = { all: false, keys: new Set([newRowKey]) };\n      } else if (!containsKey(selectedRows, newRowKey)) {\n        if (isMultiSelectRowGesture && selectionMode.row === 'multiple') {\n          selectedRows = addKey(selectedRows, newRowKey);\n        } else {\n          selectedRows = { all: false, keys: new Set([newRowKey]) };\n        }\n      } else if (isMultiSelectRowGesture) {\n        selectedRows = removeKey(selectedRows, newRowKey, false);\n      } else {\n        selectedRows = { all: false, keys: new Set([newRowKey]) };\n      }\n      selectedColumns = emptyKeys as Keys<C>;\n    }\n  } else if (selectionMode?.column === 'single' || selectionMode?.column === 'multiple') {\n    const cellElement = targetElement.closest(\n      `[data-oj-table-focusable='${tableId}']`\n    ) as HTMLElement;\n    if (cellElement != null) {\n      const cellType = getCellType(cellElement);\n      if (cellType === 'header' || cellType === 'footer') {\n        const index = getColumnIndexForHeaderFooterElement(\n          rootElement,\n          tableId,\n          cellElement,\n          cellType === 'header'\n        );\n        if (index != null) {\n          const column = columnsArray[index];\n          if (column.value.selectable !== 'disabled') {\n            if (selectedColumns == null) {\n              selectedColumns = { all: false, keys: new Set([column.key]) };\n            } else if (!containsKey(selectedColumns, column.key)) {\n              if (isMultiSelectGesture && selectionMode.column === 'multiple') {\n                selectedColumns = addKey(selectedColumns, column.key);\n              } else {\n                selectedColumns = { all: false, keys: new Set([column.key]) };\n              }\n            } else if (isMultiSelectGesture) {\n              selectedColumns = removeKey(selectedColumns, column.key, false);\n            } else {\n              selectedColumns = { all: false, keys: new Set([column.key]) };\n            }\n            selectedRows = emptyKeys as Keys<K>;\n          }\n        }\n      }\n    }\n  }\n\n  if (!isSameKey(selectedRows, selected?.row) || !isSameKey(selectedColumns, selected?.column)) {\n    onSelectionChange(\n      { value: { row: selectedRows, column: selectedColumns }, target: targetElement },\n      false\n    );\n  }\n}\n\n/**\n * Helper function to calculate and apply a new selection state corresponding to the range provided\n */\nfunction _applyRangeSelection<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  startIndex: number,\n  endIndex: number,\n  isRowGesture: boolean,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isDropDownSelection: boolean,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> },\n  previousEndIndex?: number\n) {\n  const emptyKeys = { all: false, keys: new Set() };\n  let selectedRows = selected?.row != null ? selected.row : (emptyKeys as Keys<K>);\n  let selectedColumns = selected?.column != null ? selected.column : (emptyKeys as Keys<C>);\n\n  if (isRowGesture) {\n    selectedColumns = emptyKeys as Keys<C>;\n    if (selectionMode?.row === 'multiple') {\n      selectedRows = isDropDownSelection ? selectedRows : (emptyKeys as Keys<K>);\n      // selected rows should be added in the order that they are selected\n      if (startIndex <= endIndex) {\n        for (let i = startIndex; i <= endIndex; i++) {\n          const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n          selectedRows = addKey(selectedRows, key) as Keys<K>;\n        }\n        // for dropdown selection gesture is additive except for rows added from previous gesture\n        if (isDropDownSelection && previousEndIndex != null) {\n          if (previousEndIndex > endIndex) {\n            for (let i = previousEndIndex; i > endIndex; i--) {\n              const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n              selectedRows = removeKey(selectedRows, key, false) as Keys<K>;\n            }\n          } else if (previousEndIndex < startIndex) {\n            for (let i = previousEndIndex; i < startIndex; i++) {\n              const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n              selectedRows = removeKey(selectedRows, key, false) as Keys<K>;\n            }\n          }\n        }\n      } else {\n        for (let i = startIndex; i >= endIndex; i--) {\n          const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n          selectedRows = addKey(selectedRows, key) as Keys<K>;\n        }\n        // for dropdown selection gesture is additive except for rows added from previous gesture\n        if (isDropDownSelection && previousEndIndex != null) {\n          if (previousEndIndex < endIndex) {\n            for (let i = previousEndIndex; i < endIndex; i++) {\n              const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n              selectedRows = removeKey(selectedRows, key, false) as Keys<K>;\n            }\n          } else if (previousEndIndex > startIndex) {\n            for (let i = previousEndIndex; i > startIndex; i--) {\n              const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n              selectedRows = removeKey(selectedRows, key, false) as Keys<K>;\n            }\n          }\n        }\n      }\n    }\n  } else {\n    selectedRows = emptyKeys as Keys<K>;\n    if (selectionMode?.column === 'multiple') {\n      selectedColumns = emptyKeys as Keys<C>;\n      // selected columns should be added in the order that they are selected\n      if (startIndex <= endIndex) {\n        for (let i = startIndex; i <= endIndex; i++) {\n          const column = columnsArray[i];\n          if (column.value.selectable !== 'disabled') {\n            selectedColumns = addKey(selectedColumns, column.key);\n          }\n        }\n      } else {\n        for (let i = startIndex; i >= endIndex; i--) {\n          const column = columnsArray[i];\n          if (column.value.selectable !== 'disabled') {\n            selectedColumns = addKey(selectedColumns, column.key);\n          }\n        }\n      }\n    }\n  }\n\n  if (!isSameKey(selectedRows, selected?.row) || !isSameKey(selectedColumns, selected?.column)) {\n    onSelectionChange(\n      { value: { row: selectedRows, column: selectedColumns }, target: targetElement },\n      true\n    );\n  }\n}\n\n/**\n * Determines whether a potential range selection gesture is valid based on the given target\n */\nexport function isRangeSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  activeCell: ActiveCell<K, C>,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode }\n) {\n  const targetCell = logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray);\n  if (\n    ((selectionMode?.row === 'multiple' && activeCell.type === 'data') ||\n      (selectionMode?.column === 'multiple' &&\n        (activeCell.type === 'header' || activeCell.type === 'footer'))) &&\n    targetCell?.type === activeCell.type\n  ) {\n    const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);\n    const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);\n    if (activeCellElement != null && targetCellElement != null) {\n      const isRow = targetCell.type === 'data';\n      if (isRow) {\n        return (\n          getRowIndexForRowElement(\n            rootElement,\n            tableId,\n            activeCellElement.parentElement as HTMLElement\n          ) != null &&\n          getRowIndexForRowElement(\n            rootElement,\n            tableId,\n            targetCellElement.parentElement as HTMLElement\n          ) != null\n        );\n      } else if (targetCell.type === 'header' || targetCell.type === 'footer') {\n        const isHeader = targetCell.type === 'header';\n        return (\n          getColumnIndexForHeaderFooterElement(rootElement, tableId, activeCellElement, isHeader) !=\n            null &&\n          getColumnIndexForHeaderFooterElement(rootElement, tableId, targetCellElement, isHeader) !=\n            null\n        );\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a range selection gesture (shift+click)\n */\nexport function handleRangeSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  activeCell: ActiveCell<K, C>,\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isSelectionExtension?: boolean) => void,\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isDropDownSelection: boolean,\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const targetCell = logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray);\n  if (targetCell != null) {\n    const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);\n    const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);\n    if (activeCellElement != null && targetCellElement != null) {\n      if (\n        ((selectionMode?.row === 'multiple' && targetCell.type === 'data') ||\n          (selectionMode?.column === 'multiple' &&\n            (targetCell.type === 'header' || targetCell.type === 'footer'))) &&\n        targetCell.type === activeCell.type\n      ) {\n        let startIndex;\n        let endIndex;\n        let previousEndIndex;\n        let endElement;\n        const isRow = targetCell.type === 'data';\n        if (isRow) {\n          endElement = targetCellElement.parentElement as HTMLElement;\n          const startElement =\n            isDropDownSelection && selectionExtensionElementRef.current != null\n              ? selectionExtensionElementRef.current\n              : (activeCellElement.parentElement as HTMLElement);\n          startIndex = getRowIndexForRowElement(rootElement, tableId, startElement);\n          endIndex = getRowIndexForRowElement(rootElement, tableId, endElement);\n          const previousElement = isDropDownSelection\n            ? (activeCellElement.parentElement as HTMLElement)\n            : selectionExtensionElementRef.current;\n          if (previousElement != null) {\n            previousEndIndex = getRowIndexForRowElement(rootElement, tableId, previousElement);\n          }\n        } else if (targetCell.type === 'header' || targetCell.type === 'footer') {\n          const isHeader = targetCell.type === 'header';\n          endElement = targetCellElement;\n          startIndex = getColumnIndexForHeaderFooterElement(\n            rootElement,\n            tableId,\n            activeCellElement,\n            isHeader\n          );\n          endIndex = getColumnIndexForHeaderFooterElement(\n            rootElement,\n            tableId,\n            targetCellElement,\n            isHeader\n          );\n        }\n        if (startIndex != null && endIndex != null) {\n          if (!isRow || !isDropDownSelection) {\n            selectionExtensionElementRef.current = endElement;\n          } else {\n            if (selectionExtensionElementRef.current == null) {\n              selectionExtensionElementRef.current = activeCellElement.parentElement as HTMLElement;\n            }\n            onActiveCellChanged({ value: targetCell }, true);\n            targetCellElement.focus({ preventScroll: true });\n          }\n          _applyRangeSelection(\n            rootElement,\n            tableId,\n            columnsArray,\n            targetElement,\n            startIndex,\n            endIndex,\n            isRow,\n            onSelectionChange,\n            isDropDownSelection,\n            selectionMode,\n            selected,\n            previousEndIndex\n          );\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a selection extension gesture (shift+arrow key)\n */\nexport function handleExtendSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  sizingInfoRef: MutableRef<SizingInfo>,\n  targetElement: HTMLElement,\n  isPrevious: boolean,\n  activeCell: ActiveCell<K, C>,\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isDropDownSelection: boolean,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode },\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);\n  if (activeCellElement != null) {\n    let startIndex;\n    let startElement;\n    const isRow = activeCell.type === 'data';\n    const isHeader = activeCell.type === 'header';\n    if (isRow) {\n      startElement =\n        isDropDownSelection && selectionExtensionElementRef.current != null\n          ? selectionExtensionElementRef.current\n          : (activeCellElement.parentElement as HTMLElement);\n      startIndex = getRowIndexForRowElement(rootElement, tableId, startElement);\n    } else {\n      startElement = activeCellElement;\n      startIndex = getColumnIndexForHeaderFooterElement(\n        rootElement,\n        tableId,\n        startElement,\n        isHeader\n      );\n    }\n    if (startIndex != null) {\n      let endIndex;\n      let previousEndIndex;\n      let extendedElement;\n      const cursorElement =\n        isDropDownSelection && isRow\n          ? (activeCellElement.parentElement as HTMLElement)\n          : selectionExtensionElementRef.current;\n      if (cursorElement != null) {\n        previousEndIndex = isRow\n          ? getRowIndexForRowElement(rootElement, tableId, cursorElement)\n          : getColumnIndexForHeaderFooterElement(rootElement, tableId, cursorElement, isHeader);\n        extendedElement = isPrevious\n          ? (cursorElement.previousElementSibling as HTMLElement)\n          : (cursorElement.nextElementSibling as HTMLElement);\n        if (extendedElement != null && (!isRow || (isRow && getRowKey(extendedElement) != null))) {\n          if (!isDropDownSelection || !isRow) {\n            selectionExtensionElementRef.current = extendedElement;\n          } else if (selectionExtensionElementRef.current == null) {\n            selectionExtensionElementRef.current = activeCellElement.parentElement as HTMLElement;\n          }\n          endIndex = isRow\n            ? getRowIndexForRowElement(rootElement, tableId, extendedElement)\n            : getColumnIndexForHeaderFooterElement(rootElement, tableId, extendedElement, isHeader);\n        } else {\n          endIndex = isRow\n            ? getRowIndexForRowElement(rootElement, tableId, cursorElement)\n            : getColumnIndexForHeaderFooterElement(rootElement, tableId, cursorElement, isHeader);\n        }\n      } else {\n        extendedElement = isPrevious\n          ? (startElement.previousElementSibling as HTMLElement)\n          : (startElement.nextElementSibling as HTMLElement);\n        if (extendedElement != null && (!isRow || (isRow && getRowKey(extendedElement) != null))) {\n          selectionExtensionElementRef.current = extendedElement;\n          endIndex = isRow\n            ? getRowIndexForRowElement(rootElement, tableId, extendedElement)\n            : getColumnIndexForHeaderFooterElement(rootElement, tableId, extendedElement, isHeader);\n        } else {\n          endIndex = startIndex;\n        }\n      }\n      if (endIndex != null) {\n        _applyRangeSelection(\n          rootElement,\n          tableId,\n          columnsArray,\n          targetElement,\n          startIndex,\n          endIndex,\n          isRow,\n          onSelectionChange,\n          isDropDownSelection,\n          selectionMode,\n          selected,\n          previousEndIndex\n        );\n      }\n\n      // scroll 'extensionElement' into view if focus is not shifted\n      if (!isRow || !isDropDownSelection) {\n        const extensionElement =\n          selectionExtensionElementRef.current != null\n            ? selectionExtensionElementRef.current\n            : activeCellElement;\n        let extensionCell;\n        if (isRow) {\n          const rowKey = keyExtractor<K>(extensionElement, `[data-oj-table-data-row='${tableId}']`);\n          if (rowKey != null) {\n            extensionCell = {\n              type: activeCell.type,\n              rowKey: rowKey,\n              columnKey: activeCell.columnKey\n            };\n          }\n        } else {\n          extensionCell = logicalCellExtractor<K, D, C>(extensionElement, tableId, columnsArray);\n        }\n        if (extensionCell != null) {\n          applyScrollDetail(\n            rootElement,\n            scrollerElement,\n            viewportInfo,\n            tableId,\n            columnsArray,\n            sizingInfoRef.current,\n            { cell: extensionCell, locationX: 'inView', locationY: 'inView' },\n            isRtl,\n            fullColumnWidths\n          );\n        }\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { ColumnResizeInfo, TableColumn } from '../Table';\nimport { ColumnResizeDetail, ColumnWidths } from '../../UNSAFE_TableView';\nimport { getElementContainsFunc } from '../../utils/PRIVATE_collectionUtils';\n\n/**\n * Helper function to handle a hover over a resizable column region gesture.\n */\nexport function handleOverResizeRegionGesture<K, D, C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean\n) {\n  // handle hover feedback around potentially resizable columns\n  _updateResizingState(rootElement, tableId, event, columnsArray, resizeInfoRef, isRtl);\n}\n\n/**\n * Helper function to handle a column resize start gesture (pointer down).\n */\nexport function handleColumnResizeStartGesture<K, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (fullColumnWidths != null) {\n    if (resizeInfoRef.current.key == null) {\n      _updateResizingState(rootElement, tableId, event, columnsArray, resizeInfoRef, isRtl);\n    }\n    if (resizeInfoRef.current.key != null) {\n      const rect = scrollerElement.getBoundingClientRect();\n      const pointerX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n      const resizeColumnWidths = [];\n      for (let i = 0; i < fullColumnWidths.length; i++) {\n        const columnWidth = fullColumnWidths[i];\n        resizeColumnWidths.push(columnWidth as number);\n      }\n      resizeInfoRef.current = {\n        isResizing: true,\n        isResizeHover: true,\n        key: resizeInfoRef.current.key,\n        startX: pointerX,\n        delta: 0,\n        fullColumnWidths: resizeColumnWidths,\n        ignoreClick: resizeInfoRef.current.ignoreClick\n      };\n      if (onColumnResizing != null) {\n        onColumnResizing({\n          key: resizeInfoRef.current.key,\n          delta: 0,\n          allColumnWidths: appliedColumnWidths\n        });\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to ensure the resizing state is updated based on the latest pointer event.\n */\nfunction _updateResizingState<K, D, C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean\n) {\n  const headerRowElement = rootElement.querySelector(\n    `[data-oj-table-header-row='${tableId}']`\n  ) as HTMLElement;\n  if (headerRowElement != null) {\n    const headerElements = headerRowElement.querySelectorAll(\n      `[data-oj-table-header-cell='${tableId}']`\n    ) as NodeListOf<HTMLElement>;\n    if (getElementContainsFunc(headerRowElement)(event.target as HTMLElement)) {\n      let isResizeHover = false;\n      for (let i = 0; i < headerElements.length; i++) {\n        const headerElement = headerElements[i];\n        const cellRect = headerElement.getBoundingClientRect();\n        const endEdge = isRtl ? cellRect.left : cellRect.right;\n        if (Math.abs(endEdge - event.pageX) <= 8) {\n          if (columnsArray[i].value.edgeResizable !== 'enabled') {\n            break;\n          }\n          // resize operation on end side of header cell\n          resizeInfoRef.current.key = columnsArray[i].key;\n          headerRowElement.style.cursor = 'col-resize';\n          isResizeHover = true;\n          resizeInfoRef.current.isResizeHover = true;\n        }\n      }\n      if (!isResizeHover) {\n        headerRowElement.style.cursor = '';\n        resizeInfoRef.current.key = undefined;\n        resizeInfoRef.current.isResizeHover = false;\n      }\n    } else {\n      if (headerRowElement != null) {\n        headerRowElement.style.cursor = '';\n      }\n      resizeInfoRef.current.key = undefined;\n      resizeInfoRef.current.isResizeHover = false;\n    }\n  }\n}\n\n/**\n * Helper function to handle a pointer move gesture during a column resize.\n */\nexport function handleColumnResizingGesture<C extends string>(\n  scrollerElement: HTMLElement,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  fullColumnWidths?: number[],\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (resizeInfoRef.current.isResizing && fullColumnWidths != null) {\n    const rect = scrollerElement.getBoundingClientRect();\n    const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n    resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;\n    // handle resize move operation\n    if (onColumnResizing != null) {\n      onColumnResizing({\n        key: resizeInfoRef.current.key,\n        delta: resizeInfoRef.current.delta,\n        allColumnWidths: appliedColumnWidths\n      });\n    }\n  }\n}\n\n/**\n * Helper function to handle a column resize end gesture (pointer up).\n */\nexport function handleColumnResizeEndGesture<C extends string>(\n  scrollerElement: HTMLElement,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (resizeInfoRef.current.isResizing) {\n    if (onColumnResize != null) {\n      const resizeColumnWidths = [];\n      for (const columnWidth of resizeInfoRef.current.fullColumnWidths) {\n        resizeColumnWidths.push(columnWidth);\n      }\n      const rect = scrollerElement.getBoundingClientRect();\n      const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n      resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;\n      onColumnResize({\n        key: resizeInfoRef.current.key,\n        delta: resizeInfoRef.current.delta,\n        allColumnWidths: appliedColumnWidths\n      });\n    }\n  }\n  resizeInfoRef.current = {\n    isResizing: false,\n    isResizeHover: resizeInfoRef.current.isResizeHover,\n    ignoreClick: resizeInfoRef.current.ignoreClick\n  };\n}\n\n/**\n * Helper function to handle the pointer leaving the entire Table when previously hovering\n * over a column resize region.\n */\nexport function handleLeaveResizingGesture<C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>\n) {\n  if (!resizeInfoRef.current.isResizing) {\n    const headerRowElement = rootElement.querySelector(\n      `[data-oj-table-header-row='${tableId}']`\n    ) as HTMLElement;\n    if (headerRowElement != null) {\n      headerRowElement.style.cursor = '';\n    }\n    resizeInfoRef.current.isResizeHover = false;\n  }\n}\n\n/**\n * Helper function to handle a pointer entering the Table when it was previously handling\n * a column resize gesture.\n */\nexport function handleEnterResizingGesture<C extends string>(\n  scrollerElement: HTMLElement,\n  event: PointerEvent,\n  appliedColumnWidths: ColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void\n) {\n  // handle case where user was resizing, moved pointer out of the Table,\n  // released the button, and has now entered the table once again\n  if (resizeInfoRef.current.isResizing && event.buttons === 0) {\n    handleColumnResizeEndGesture(\n      scrollerElement,\n      event,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      onColumnResize\n    );\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useRef, useState, MutableRef } from 'preact/hooks';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { getIsSelectionPending } from '../../utils/PRIVATE_textSelectionUtils';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  ColumnResizeInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { handleRowActionGesture } from '../utils/TableActionUtils';\nimport { logicalCellExtractor } from '../utils/TableDomUtils';\nimport {\n  handleSelectionGesture,\n  handleRangeSelectionGesture,\n  isRangeSelectionGesture\n} from '../utils/TableSelectionUtils';\nimport {\n  handleOverResizeRegionGesture,\n  handleColumnResizeStartGesture,\n  handleColumnResizingGesture,\n  handleColumnResizeEndGesture,\n  handleLeaveResizingGesture,\n  handleEnterResizingGesture\n} from '../utils/TableSizingUtils';\nimport {\n  handleOverColumnHeaderGesture,\n  handleLeaveColumnHeaderGesture\n} from '../utils/TableSortUtils';\nimport {\n  handleLeaveTableTooltipGesture,\n  handleMoveTooltipGesture\n} from '../utils/TableTooltipUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport {\n  Cell,\n  ColumnWidths,\n  RowActionDetail,\n  ColumnResizeDetail,\n  TableSelectionDetail\n} from '../../UNSAFE_TableView';\n\ntype PointerInfo = {\n  target: EventTarget | null;\n  x: number;\n  y: number;\n}\n\ntype UsePointerHandlingOptions<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  appliedColumnWidths?: ColumnWidths<C>;\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  fullColumnWidths?: number[];\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void;\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void;\n  activeCell?: ActiveCell<K, C>;\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isSelectionExtension?: boolean) => void;\n  isDropDownSelection: boolean;\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode };\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onTableSelectionChange?: (\n    detail: TableSelectionDetail<K, C>,\n    isSelectionExtension: boolean\n  ) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  showTooltip: (cell: Cell<K, C>) => void;\n  hideTooltip: (isImmediate?: boolean) => void;\n  tooltipId: string;\n};\n\n/**\n * Hook that manages pointer interactions on the Preact Table\n */\nexport function usePointerHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  tableData,\n  isRtl,\n  columnsArray,\n  appliedColumnWidths,\n  resizeInfoRef,\n  selectionExtensionElementRef,\n  fullColumnWidths,\n  onColumnResizing,\n  onColumnResize,\n  activeCell,\n  onActiveCellChanged,\n  isDropDownSelection,\n  selectionMode,\n  selected,\n  onTableSelectionChange,\n  onRowAction,\n  showTooltip,\n  hideTooltip,\n  tooltipId\n}: UsePointerHandlingOptions<K, D, C>) {\n  // tracks whether the most recent 'pointerdown' event was due to a touch gesture\n  const selectionTouchRef = useRef<boolean>(false);\n\n  // tracks the column key for any header being hovered over\n  const [hoverColumnKey, setHoverColumnKey] = useState<C>();\n\n  // tracks the current 'pointer over' element for comparison during 'click' event handling to\n  // prevent screen readers from triggering undesired selection gestures from simulated events\n  const pointerInfoRef = useRef<PointerInfo>();\n\n  // Pointer move handler for the outer Table.\n  const _pointerMoveHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null) {\n        pointerInfoRef.current = { target: event.target, x: event.clientX, y: event.clientY };\n        handleMoveTooltipGesture(tableId, columnsArray, event, showTooltip, hideTooltip, tooltipId);\n        if (onColumnResizing != null) {\n          if (!resizeInfoRef.current.isResizing) {\n            handleOverResizeRegionGesture(\n              rootElement,\n              tableId,\n              event,\n              columnsArray,\n              resizeInfoRef,\n              isRtl\n            );\n          } else if (scrollerElement != null && appliedColumnWidths != null) {\n            handleColumnResizingGesture(\n              scrollerElement,\n              event,\n              appliedColumnWidths,\n              resizeInfoRef,\n              isRtl,\n              fullColumnWidths,\n              onColumnResizing\n            );\n          }\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      fullColumnWidths,\n      onColumnResizing,\n      showTooltip,\n      hideTooltip,\n      tooltipId\n    ]\n  );\n\n  // Pointer over handler for the outer Table.\n  const _pointerOverHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        pointerInfoRef.current = { target: event.target, x: event.clientX, y: event.clientY };\n        handleOverColumnHeaderGesture(tableId, event, setHoverColumnKey, hoverColumnKey);\n      }\n    }, [\n      rootRef,\n      tableId,\n      hoverColumnKey\n    ]\n  );\n\n  // Pointer down handler for the outer Table. It ensures the area targeted is 'current'.\n  // NOTE - This event handling is triggered prior to 'onFocus' handling and ensures the\n  // 'pending current' area is set when an initial pointer interaction focuses the Table.\n  const _pointerDownHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null) {\n        selectionTouchRef.current = event.pointerType === 'touch';\n        const targetElement = event.target as HTMLElement;\n        if (\n          onTableSelectionChange != null &&\n          activeCell != null &&\n          event.shiftKey &&\n          isRangeSelectionGesture(\n            rootElement,\n            tableId,\n            columnsArray,\n            targetElement,\n            activeCell,\n            selectionMode\n          )\n        ) {\n          // prevent focus change on selection extension gesture\n          if (!getIsSelectionPending()) {\n            event.preventDefault();\n          }\n        } else if (\n          scrollerElement != null &&\n          appliedColumnWidths != null &&\n          handleColumnResizeStartGesture(\n            rootElement,\n            scrollerElement,\n            tableId,\n            event,\n            columnsArray,\n            appliedColumnWidths,\n            resizeInfoRef,\n            isRtl,\n            fullColumnWidths,\n            onColumnResizing\n          )\n        ) {\n          // prevent focus change on column resize gesture\n          event.preventDefault();\n          resizeInfoRef.current.ignoreClick = true;\n        } else if (logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray) == null) {\n          // prevent focus shift when interacting with 'non-focusable' regions (ie - scrollbar)\n          event.preventDefault();\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      activeCell,\n      selectionMode,\n      onTableSelectionChange,\n      fullColumnWidths,\n      onColumnResizing\n    ]\n  );\n\n  // Pointer up handler for the outer Table.\n  const _pointerUpHandler = useCallback(\n    (event: PointerEvent) => {\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (scrollerElement != null && appliedColumnWidths != null) {\n        handleColumnResizeEndGesture(\n          scrollerElement,\n          event,\n          appliedColumnWidths,\n          resizeInfoRef,\n          isRtl,\n          onColumnResize\n        );\n      }\n    },\n    [viewportInfo, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize]\n  );\n\n  // Pointer leave handler for the outer Table.\n  const _pointerLeaveHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        handleLeaveColumnHeaderGesture(setHoverColumnKey, hoverColumnKey);\n        handleLeaveResizingGesture(rootElement, tableId, resizeInfoRef);\n        handleLeaveTableTooltipGesture(rootElement, event, hideTooltip, tooltipId);\n      }\n      pointerInfoRef.current = undefined;\n    },\n    [rootRef, tableId, resizeInfoRef, hoverColumnKey, hideTooltip, tooltipId]\n  );\n\n  // Pointer enter handler for the outer Table.\n  const _pointerEnterHandler = useCallback(\n    (event: PointerEvent) => {\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (scrollerElement != null && appliedColumnWidths != null) {\n        handleEnterResizingGesture(\n          scrollerElement,\n          event,\n          appliedColumnWidths,\n          resizeInfoRef,\n          isRtl,\n          onColumnResize\n        );\n      }\n    },\n    [viewportInfo, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize]\n  );\n\n  // Click handler for the outer Table. It ensures the Table's selection state is\n  // updated to reflect the area targeted, and any action events are fired correctly.\n  const _clickHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        // only handle click events that match the latest mouse over/move info to prevent screen readers\n        // from triggering undesired selections due to simulated click events when transferring focus\n        if (\n          event.pointerType !== 'mouse' || (\n            pointerInfoRef.current != null &&\n            pointerInfoRef.current.target === event.target &&\n            Math.abs(pointerInfoRef.current.x - event.clientX) <= 1  &&\n            Math.abs(pointerInfoRef.current.y - event.clientY) <= 1\n          )\n        ) {\n          let isSelectionExtension = false;\n          const platform = getClientHints().platform;\n          const target = event.target as HTMLElement;\n          if (\n            onTableSelectionChange != null &&\n            !resizeInfoRef.current.ignoreClick &&\n            !getIsSelectionPending()\n          ) {\n            if (activeCell != null && event.shiftKey) {\n              isSelectionExtension = handleRangeSelectionGesture(\n                rootElement,\n                tableId,\n                columnsArray,\n                target,\n                activeCell,\n                onActiveCellChanged,\n                selectionExtensionElementRef,\n                onTableSelectionChange,\n                isDropDownSelection,\n                selectionMode,\n                selected\n              );\n            }\n            if (!isSelectionExtension) {\n              handleSelectionGesture(\n                rootElement,\n                tableId,\n                columnsArray,\n                target,\n                (platform === 'mac' ? event.metaKey : event.ctrlKey) || selectionTouchRef.current,\n                onTableSelectionChange,\n                isDropDownSelection,\n                selectionMode,\n                selected\n              );\n            }\n          }\n          if (\n            onRowAction != null &&\n            !getIsSelectionPending() &&\n            handleRowActionGesture(rootElement, tableId, tableData, onRowAction, target)\n          ) {\n            event.stopPropagation();\n          }\n        }\n      }\n      resizeInfoRef.current.ignoreClick = false;\n    },\n    [\n      rootRef,\n      tableId,\n      columnsArray,\n      tableData,\n      resizeInfoRef,\n      selectionExtensionElementRef,\n      activeCell,\n      onActiveCellChanged,\n      isDropDownSelection,\n      selectionMode,\n      selected,\n      onTableSelectionChange,\n      onRowAction\n    ]\n  );\n\n  return {\n    pointerHandlingProps: {\n      onPointerOver: _pointerOverHandler,\n      onPointerMove: _pointerMoveHandler,\n      onPointerDown: _pointerDownHandler,\n      onPointerUp: _pointerUpHandler,\n      onPointerLeave: _pointerLeaveHandler,\n      onPointerEnter: _pointerEnterHandler,\n      onClick: _clickHandler\n    },\n    hoverColumnKey\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Dispatch, StateUpdater } from 'preact/hooks';\nimport { getCellType, getColumnKey } from './TableDomUtils';\n\n/**\n * Helper function to handle a hover over a column header region gesture.\n */\nexport function handleOverColumnHeaderGesture<C>(\n  tableId: string,\n  event: PointerEvent,\n  setHoverColumnKey: Dispatch<StateUpdater<C | undefined>>,\n  hoverColumnKey?: C\n) {\n  // only enable sort icon visibility due to mouse events\n  if (event.pointerType === 'mouse') {\n    const cellElement = (event.target as HTMLElement).closest(\n      `[data-oj-table-focusable='${tableId}']`\n    ) as HTMLElement;\n    if (cellElement != null && getCellType(cellElement) === 'header') {\n      const columnKey = getColumnKey<C>(cellElement);\n      if (columnKey !== hoverColumnKey) {\n        setHoverColumnKey(columnKey);\n      }\n    } else if (hoverColumnKey != null) {\n      setHoverColumnKey(undefined);\n    }\n  }\n}\n\n/**\n * Helper function to handle a mouse leave the table region.\n */\nexport function handleLeaveColumnHeaderGesture<C>(\n  setHoverColumnKey: Dispatch<StateUpdater<C | undefined>>,\n  hoverColumnKey?: C\n) {\n  if (hoverColumnKey != null) {\n    setHoverColumnKey(undefined);\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useLayoutEffect, useRef, MutableRef } from 'preact/hooks';\nimport { TableHorizontalScrollPosition, TableVerticalScrollPosition } from '../../UNSAFE_TableView';\nimport { LayoutInfo, SizingInfo, TableColumn, ViewportInfo } from '../Table';\nimport {\n  hideOutOfViewTooltip,\n  setHorizontalScrollPosition,\n  setVerticalScrollPosition,\n  updateStickyEdges\n} from '../utils/TableScrollUtils';\n\ntype UseScrollHandlingProps<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  layoutInfo: LayoutInfo;\n  sizingInfoRef: MutableRef<SizingInfo>;\n  columnsArray: TableColumn<K, D, C>[];\n  stickyEdgesState: { start?: number; end?: number };\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void;\n  fullColumnWidths?: number[];\n  horizontalScrollPositionOverride?: TableHorizontalScrollPosition<C>;\n  verticalScrollPositionOverride?: TableVerticalScrollPosition<K>;\n  tooltipAnchorRef: MutableRef<HTMLElement | undefined>;\n  hideTooltip: (isImmediate?: boolean) => void;\n  isPendingLayout: boolean;\n  isRtl: boolean;\n};\n\n/**\n * Hook that manages handling scroll events on the Preact Table\n */\nexport function useScrollHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  layoutInfo,\n  sizingInfoRef,\n  columnsArray,\n  stickyEdgesState,\n  setStickyEdgesState,\n  fullColumnWidths,\n  horizontalScrollPositionOverride,\n  verticalScrollPositionOverride,\n  tooltipAnchorRef,\n  hideTooltip,\n  isPendingLayout,\n  isRtl\n}: UseScrollHandlingProps<K, D, C>) {\n  const horizontalScrollPositionOverrideRef = useRef<TableHorizontalScrollPosition<C>>();\n  const verticalScrollPositionOverrideRef = useRef<TableVerticalScrollPosition<K>>();\n\n  // update horizontal and/or vertical scroll position if a new value is provided\n  // NO DEPENDENCY ARRAY AS THIS SHOULD RUN ON EVERY RENDER\n  useLayoutEffect(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (\n      rootElement != null &&\n      scrollerElement != null &&\n      !isPendingLayout &&\n      !layoutInfo.isLayoutRequired\n    ) {\n      if (horizontalScrollPositionOverrideRef.current !== horizontalScrollPositionOverride) {\n        setHorizontalScrollPosition(\n          scrollerElement,\n          columnsArray,\n          layoutInfo.columnWidthsArray,\n          isRtl,\n          horizontalScrollPositionOverride\n        );\n        horizontalScrollPositionOverrideRef.current = horizontalScrollPositionOverride;\n      }\n      if (verticalScrollPositionOverrideRef.current !== verticalScrollPositionOverride) {\n        setVerticalScrollPosition(\n          rootElement,\n          scrollerElement,\n          tableId,\n          verticalScrollPositionOverride\n        );\n        verticalScrollPositionOverrideRef.current = verticalScrollPositionOverride;\n      }\n    }\n  });\n\n  // Scroll hander for the outer Table. It ensures the Table's sticky edges are updated\n  // and any out of view tooltips are hidden.\n  const _scrollHandler = useCallback(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (rootElement != null && scrollerElement != null && fullColumnWidths != null) {\n      updateStickyEdges(\n        scrollerElement,\n        columnsArray,\n        fullColumnWidths,\n        stickyEdgesState,\n        setStickyEdgesState,\n        scrollerElement.scrollLeft\n      );\n      hideOutOfViewTooltip(\n        rootElement,\n        scrollerElement,\n        tableId,\n        sizingInfoRef.current,\n        columnsArray,\n        fullColumnWidths,\n        tooltipAnchorRef,\n        hideTooltip,\n        isRtl\n      );\n    }\n  }, [\n    rootRef,\n    viewportInfo,\n    tableId,\n    sizingInfoRef,\n    columnsArray,\n    stickyEdgesState,\n    setStickyEdgesState,\n    fullColumnWidths,\n    tooltipAnchorRef,\n    hideTooltip,\n    isRtl\n  ]);\n\n  useLayoutEffect(() => {\n    const isExternalScroller = viewportInfo.isExternalScroller;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    let scrollerEventElement: Element | typeof globalThis;\n    if (isExternalScroller && scrollerElement != null) {\n      if (scrollerElement === document.body || scrollerElement === document.documentElement) {\n        scrollerEventElement = window;\n      } else {\n        scrollerEventElement = scrollerElement;\n      }\n      scrollerEventElement.addEventListener('scroll', _scrollHandler);\n    }\n    return () => {\n      if (isExternalScroller && scrollerEventElement != null) {\n        scrollerEventElement.removeEventListener('scroll', _scrollHandler);\n      }\n    };\n  }, [viewportInfo, _scrollHandler]);\n\n  return viewportInfo.isExternalScroller ? {} : { onScroll: _scrollHandler };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useImperativeHandle, useMemo, useRef, MutableRef } from 'preact/hooks';\nimport { ForwardedRef } from 'preact/compat';\nimport { useCollectionInteractionContext } from '../../hooks/UNSAFE_useCollectionInteractionContext';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\nimport {\n  ActiveCell,\n  ColumnResizeInfo,\n  LayoutInfo,\n  SizingInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { getElementFromCell } from '../utils/TableDomUtils';\nimport { useContextMenu } from './useContextMenu';\nimport { useTruncationTooltip } from './useTruncationTooltip';\nimport { useFocusHandling } from './useFocusHandling';\nimport { useKeyboardHandling } from './useKeyboardHandling';\nimport { usePointerHandling } from './usePointerHandling';\nimport { useScrollHandling } from './useScrollHandling';\nimport { getHorizontalScrollPosition, getVerticalScrollPosition } from '../utils/TableScrollUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport {\n  CellOverride,\n  ColumnWidths,\n  CurrentCellDetail,\n  RowActionDetail,\n  SortCriterionDetail,\n  ColumnResizeDetail,\n  TableContextMenuConfig,\n  TableHorizontalScrollPosition,\n  TableSelectionDetail,\n  TableVerticalScrollPosition,\n  TableViewHandle\n} from '../../UNSAFE_TableView';\n\ntype UseInteractionManagerOptions<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  ref?: ForwardedRef<TableViewHandle<K, C>>;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  hasMore: boolean;\n  hasFooters: boolean;\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  appliedColumnWidths?: ColumnWidths<C>;\n  layoutInfo: LayoutInfo;\n  sizingInfoRef: MutableRef<SizingInfo>;\n  stickyEdgesState: { start?: number; end?: number };\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void;\n  cellHasRenderer: (cell: ActiveCell<K, C>) => boolean;\n  horizontalScrollPositionOverride?: TableHorizontalScrollPosition<C>;\n  verticalScrollPositionOverride?: TableVerticalScrollPosition<K>;\n  onColumnResizing?: (detail: ColumnResizeDetail<C>) => void;\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void;\n  currentCellOverride?: CellOverride<K, C>;\n  onPersistCurrentCell?: (detail: CurrentCellDetail<K, C>) => void;\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode };\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  isPendingLayout: boolean;\n  contextMenuConfig?: TableContextMenuConfig<K, D, C>;\n};\n\nconst _defaultDisabledRowInteractionKeys: ('enter' | 'space')[] = ['enter'];\n\n/**\n * Hook that manages interactions and events on the Preact Table\n */\nexport function useInteractionManager<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  ref,\n  tableId,\n  tableData,\n  hasMore,\n  hasFooters,\n  isRtl,\n  columnsArray,\n  appliedColumnWidths,\n  layoutInfo,\n  sizingInfoRef,\n  stickyEdgesState,\n  setStickyEdgesState,\n  cellHasRenderer,\n  horizontalScrollPositionOverride,\n  verticalScrollPositionOverride,\n  onColumnResizing,\n  onColumnResize,\n  currentCellOverride,\n  onPersistCurrentCell,\n  selectionMode,\n  selected,\n  onSelectionChange,\n  onRowAction,\n  sortCriterion,\n  onSortCriterionChange,\n  isPendingLayout,\n  contextMenuConfig\n}: UseInteractionManagerOptions<K, D, C>) {\n  // tracks the current column resize state\n  const resizeInfoRef = useRef<ColumnResizeInfo<C>>({\n    isResizing: false,\n    isResizeHover: false,\n    ignoreClick: false\n  });\n\n  // handles default tooltip state management\n  const { tooltipContent, tooltipId, tooltipAnchorRef, showTooltip, hideTooltip } =\n    useTruncationTooltip<K, C>({ rootRef, tableId });\n\n  // whether row selection is triggered on 'enter' keypresses in addition to 'spacebar'\n  const isEmbeddedSelect = useCollectionInteractionContext() === 'embedded';\n  const disabledRowInteractionKeys = isEmbeddedSelect\n    ? undefined\n    : _defaultDisabledRowInteractionKeys;\n\n  // tracks the current selection extension element (if any)\n  const selectionExtensionElementRef = useRef<HTMLElement>();\n\n  // intercept onSelectionChange calls to ensure local selectionExtensionElementRef is cleared\n  const onTableSelectionChange = useMemo(() => {\n    return onSelectionChange != null\n      ? (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => {\n          if (!isExtendableSelection) {\n            selectionExtensionElementRef.current = undefined;\n          }\n          onSelectionChange(detail);\n        }\n      : undefined;\n  }, [onSelectionChange]);\n\n  // setup focus tracking using the useFocusHandling hook\n  const {\n    focusHandlingProps,\n    activeCell,\n    onActiveCellChanged,\n    currentActiveCell,\n    currentCell,\n    isShowFocusRing,\n    isTabbableMode,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge\n  } = useFocusHandling({\n    rootRef,\n    viewportInfo,\n    tableId,\n    tableData,\n    hasMore,\n    hasFooters,\n    columnsArray,\n    sizingInfoRef,\n    selectionExtensionElementRef,\n    isRtl,\n    cellSupportsTabbable: cellHasRenderer,\n    fullColumnWidths: layoutInfo.isLayoutRequired ? undefined : layoutInfo.columnWidthsArray,\n    currentCellOverride,\n    onPersistCurrentCell,\n    showTooltip,\n    hideTooltip,\n    isPendingLayout,\n    isEmbeddedSelect,\n    isDataLoaded: !hasMore || tableData.length > 0\n  });\n\n  const keyboardHandlingProps = useKeyboardHandling({\n    rootRef,\n    viewportInfo,\n    tableId,\n    tableData,\n    isRtl,\n    isTabbableMode,\n    columnsArray,\n    sizingInfoRef,\n    selectionExtensionElementRef,\n    fullColumnWidths: layoutInfo.isLayoutRequired ? undefined : layoutInfo.columnWidthsArray,\n    activeCell,\n    onActiveCellChanged,\n    isDropDownSelection: isEmbeddedSelect,\n    selectionMode,\n    selected,\n    onTableSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    hideTooltip\n  });\n\n  const { hoverColumnKey, pointerHandlingProps } = usePointerHandling({\n    rootRef,\n    viewportInfo,\n    tableId,\n    tableData,\n    isRtl,\n    columnsArray,\n    appliedColumnWidths,\n    resizeInfoRef,\n    selectionExtensionElementRef,\n    fullColumnWidths: layoutInfo.isLayoutRequired ? undefined : layoutInfo.columnWidthsArray,\n    onColumnResizing,\n    onColumnResize,\n    activeCell,\n    onActiveCellChanged,\n    isDropDownSelection: isEmbeddedSelect,\n    selectionMode,\n    selected,\n    onTableSelectionChange,\n    onRowAction,\n    showTooltip,\n    hideTooltip,\n    tooltipId\n  });\n\n  const scrollHandlingProps = useScrollHandling({\n    rootRef,\n    viewportInfo,\n    tableId,\n    layoutInfo,\n    sizingInfoRef,\n    columnsArray,\n    stickyEdgesState,\n    setStickyEdgesState,\n    fullColumnWidths: layoutInfo.isLayoutRequired ? undefined : layoutInfo.columnWidthsArray,\n    horizontalScrollPositionOverride,\n    verticalScrollPositionOverride,\n    tooltipAnchorRef,\n    hideTooltip,\n    isPendingLayout,\n    isRtl\n  });\n\n  const { contextMenuTriggerProps, menuProps, contextMenuContext } = useContextMenu<K, D, C>(\n    tableId,\n    tableData,\n    activeCell,\n    contextMenuConfig\n  );\n\n  const interactionManagerProps = !isPendingLayout\n    ? mergeProps(\n        focusHandlingProps,\n        keyboardHandlingProps,\n        pointerHandlingProps,\n        contextMenuTriggerProps\n      )\n    : focusHandlingProps;\n\n  // setup imperative handle implementation\n  useImperativeHandle(\n    ref!,\n    () => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      return {\n        focus: () => {\n          if (rootElement != null) {\n            if (currentActiveCell != null) {\n              const cellElement = getElementFromCell(rootElement, tableId, currentActiveCell);\n              if (cellElement != null) {\n                cellElement.focus();\n                return;\n              }\n            }\n            // if no current cell element was found, just focus the root element\n            rootElement.focus();\n          }\n        },\n        getHorizontalScrollPosition: () => {\n          if (scrollerElement == null || layoutInfo.isLayoutRequired) {\n            return {};\n          }\n          return getHorizontalScrollPosition<K, D, C>(\n            scrollerElement,\n            columnsArray,\n            layoutInfo.columnWidthsArray\n          );\n        },\n        getVerticalScrollPosition: () => {\n          if (rootElement == null || scrollerElement == null || layoutInfo.isLayoutRequired) {\n            return {};\n          }\n          return getVerticalScrollPosition<K>(rootElement, scrollerElement, tableId);\n        }\n      };\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      currentActiveCell,\n      layoutInfo.isLayoutRequired,\n      layoutInfo.columnWidthsArray\n    ]\n  );\n\n  return {\n    interactionManagerProps,\n    scrollHandlingProps,\n    onTableSelectionChange,\n    isShowFocusRing,\n    isTabbableMode,\n    currentCell,\n    currentActiveCell,\n    resizeInfoRef,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge,\n    hoverColumnKey,\n    tooltipContent,\n    contextMenuContext,\n    menuProps,\n    disabledRowInteractionKeys\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, MutableRef } from 'preact/hooks';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  SizingInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { handleRowActionGesture, handleSortActionGesture } from '../utils/TableActionUtils';\nimport { getElementFromCell } from '../utils/TableDomUtils';\nimport {\n  handleAdjacentRowGesture,\n  handleAdjacentColumnGesture,\n  handlePageRowGesture,\n  handleJumpColumnGesture\n} from '../utils/TableNavigationUtils';\nimport { handleSelectionGesture, handleExtendSelectionGesture } from '../utils/TableSelectionUtils';\nimport { SelectionMode } from '../../UNSAFE_Collection';\nimport { RowActionDetail, SortCriterionDetail, TableSelectionDetail } from '../../UNSAFE_TableView';\n\ntype UseKeyboardHandlingProps<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  isRtl: boolean;\n  isTabbableMode: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  sizingInfoRef: MutableRef<SizingInfo>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  onActiveCellChanged: (detail: ActiveCellDetail<K, C>, isSelectionExtension?: boolean) => void;\n  fullColumnWidths?: number[];\n  activeCell?: ActiveCell<K, C>;\n  isDropDownSelection: boolean;\n  selectionMode?: { row?: SelectionMode; column?: SelectionMode };\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onTableSelectionChange?: (\n    detail: TableSelectionDetail<K, C>,\n    isExtendableSelection: boolean\n  ) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  hideTooltip: (isImmediate?: boolean) => void;\n};\n\n/**\n * Hook that manages keyboard interactions on the Preact Table\n */\nexport function useKeyboardHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  tableData,\n  isRtl,\n  isTabbableMode,\n  columnsArray,\n  sizingInfoRef,\n  selectionExtensionElementRef,\n  fullColumnWidths,\n  activeCell,\n  onActiveCellChanged,\n  isDropDownSelection,\n  selectionMode,\n  selected,\n  onTableSelectionChange,\n  onRowAction,\n  sortCriterion,\n  onSortCriterionChange,\n  hideTooltip\n}: UseKeyboardHandlingProps<K, D, C>) {\n  // Keydown handler for the outer Table. This handles all internal\n  // keyboard navigation for the Table.\n  const _keyDownHandler = useCallback(\n    (event: KeyboardEvent) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null && scrollerElement != null) {\n        const platform = getClientHints().platform;\n        const keyHandlers: Record<string, () => void> = {\n          ' ': function () {\n            if (activeCell != null) {\n              if (!isTabbableMode) {\n                if (onTableSelectionChange != null && !event.repeat) {\n                  handleSelectionGesture(\n                    rootElement,\n                    tableId,\n                    columnsArray,\n                    getElementFromCell(rootElement, tableId, activeCell) as HTMLElement,\n                    true,\n                    onTableSelectionChange,\n                    isDropDownSelection,\n                    selectionMode,\n                    selected\n                  );\n                }\n                event.preventDefault();\n              }\n              if (\n                onRowAction != null &&\n                !event.repeat &&\n                handleRowActionGesture(\n                  rootElement,\n                  tableId,\n                  tableData,\n                  onRowAction,\n                  event.target as HTMLElement,\n                  activeCell\n                )\n              ) {\n                event.stopPropagation();\n              }\n            }\n          },\n          Enter: function () {\n            if (activeCell != null) {\n              if (activeCell.type === 'data') {\n                if (isDropDownSelection && !isTabbableMode) {\n                  if (onTableSelectionChange != null && !event.repeat) {\n                    handleSelectionGesture(\n                      rootElement,\n                      tableId,\n                      columnsArray,\n                      getElementFromCell(rootElement, tableId, activeCell) as HTMLElement,\n                      true,\n                      onTableSelectionChange,\n                      isDropDownSelection,\n                      selectionMode,\n                      selected\n                    );\n                  }\n                  event.preventDefault();\n                }\n                if (\n                  onRowAction != null &&\n                  !event.repeat &&\n                  handleRowActionGesture(\n                    rootElement,\n                    tableId,\n                    tableData,\n                    onRowAction,\n                    event.target as HTMLElement,\n                    activeCell\n                  )\n                ) {\n                  event.stopPropagation();\n                }\n              } else if (\n                activeCell.type === 'header' &&\n                !isTabbableMode &&\n                !event.repeat &&\n                onSortCriterionChange != null &&\n                handleSortActionGesture(\n                  columnsArray,\n                  activeCell.columnKey,\n                  onSortCriterionChange,\n                  sortCriterion\n                )\n              ) {\n                event.stopPropagation();\n              }\n            }\n          },\n          ArrowUp: function () {\n            if (!isTabbableMode && activeCell != null) {\n              let isExtendSelectionGesture = false;\n              if (\n                activeCell.type === 'data' &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.row === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  rootElement,\n                  true,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isDropDownSelection,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n                isExtendSelectionGesture = true;\n              }\n              if (!isExtendSelectionGesture || isDropDownSelection) {\n                handleAdjacentRowGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  activeCell,\n                  onActiveCellChanged,\n                  true,\n                  isExtendSelectionGesture,\n                  isRtl,\n                  hideTooltip,\n                  fullColumnWidths\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          ArrowDown: function () {\n            if (!isTabbableMode && activeCell != null) {\n              let isExtendSelectionGesture = false;\n              if (\n                activeCell.type === 'data' &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.row === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  rootElement,\n                  false,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isDropDownSelection,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n                isExtendSelectionGesture = true;\n              }\n              if (!isExtendSelectionGesture || isDropDownSelection) {\n                handleAdjacentRowGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  activeCell,\n                  onActiveCellChanged,\n                  false,\n                  isExtendSelectionGesture,\n                  isRtl,\n                  hideTooltip,\n                  fullColumnWidths\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          ArrowLeft: function () {\n            if (!isTabbableMode && activeCell != null) {\n              if (\n                (activeCell.type === 'header' || activeCell.type === 'footer') &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.column === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  rootElement,\n                  true,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isDropDownSelection,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentColumnGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  activeCell,\n                  onActiveCellChanged,\n                  !isRtl,\n                  isRtl,\n                  hideTooltip,\n                  fullColumnWidths\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          ArrowRight: function () {\n            if (!isTabbableMode && activeCell != null) {\n              if (\n                (activeCell.type === 'header' || activeCell.type === 'footer') &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.column === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  rootElement,\n                  false,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isDropDownSelection,\n                  isRtl,\n                  fullColumnWidths,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentColumnGesture(\n                  rootElement,\n                  scrollerElement,\n                  viewportInfo,\n                  tableId,\n                  columnsArray,\n                  sizingInfoRef,\n                  activeCell,\n                  onActiveCellChanged,\n                  isRtl,\n                  isRtl,\n                  hideTooltip,\n                  fullColumnWidths\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          PageUp: function () {\n            if (!isTabbableMode && activeCell != null) {\n              handlePageRowGesture(\n                rootElement,\n                scrollerElement,\n                viewportInfo,\n                tableId,\n                columnsArray,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                true,\n                isRtl,\n                hideTooltip,\n                fullColumnWidths\n              );\n              event.preventDefault();\n            }\n          },\n          PageDown: function () {\n            if (!isTabbableMode && activeCell != null) {\n              handlePageRowGesture(\n                rootElement,\n                scrollerElement,\n                viewportInfo,\n                tableId,\n                columnsArray,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                false,\n                isRtl,\n                hideTooltip,\n                fullColumnWidths\n              );\n              event.preventDefault();\n            }\n          },\n          Home: function () {\n            if (!isTabbableMode && activeCell != null) {\n              handleJumpColumnGesture(\n                rootElement,\n                scrollerElement,\n                viewportInfo,\n                tableId,\n                columnsArray,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                true,\n                platform === 'mac' ? event.metaKey : event.ctrlKey,\n                isRtl,\n                hideTooltip,\n                fullColumnWidths\n              );\n              event.preventDefault();\n            }\n          },\n          End: function () {\n            if (!isTabbableMode && activeCell != null) {\n              handleJumpColumnGesture(\n                rootElement,\n                scrollerElement,\n                viewportInfo,\n                tableId,\n                columnsArray,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                false,\n                platform === 'mac' ? event.metaKey : event.ctrlKey,\n                isRtl,\n                hideTooltip,\n                fullColumnWidths\n              );\n              event.preventDefault();\n            }\n          }\n        };\n        if (Object.keys(keyHandlers).includes(event.key)) {\n          keyHandlers[event.key]();\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      tableData,\n      isRtl,\n      isTabbableMode,\n      columnsArray,\n      sizingInfoRef,\n      selectionExtensionElementRef,\n      fullColumnWidths,\n      activeCell,\n      onActiveCellChanged,\n      isDropDownSelection,\n      selectionMode,\n      selected,\n      onTableSelectionChange,\n      onRowAction,\n      sortCriterion,\n      onSortCriterionChange,\n      hideTooltip\n    ]\n  );\n\n  return { onKeyDown: _keyDownHandler };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { SampledWidths, TableColumn, ViewportInfo } from '../Table';\nimport { ColumnWidths } from '../../UNSAFE_TableView';\n\n/**\n * Helper method to extract the individual column widths of the Table\n * depending on its layout. With a 'fixed' layout, an initial 'availableWidth'\n * is required, while with a 'contents' layout, -1 can be provided as the\n * 'availableWidth' initially. This will trigger the layout logic to ensure\n * a non-contstrained Table width is supported, and is needed to match\n * current Redwood behaviors with a 'contents' layout.\n */\nexport function applyLayoutColumnWidths<K, D, C extends string>(\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  innerTableElement: HTMLTableElement,\n  widthOffset: number,\n  tableId: string,\n  isFixed: boolean,\n  sampledColumnWidthsRef: MutableRef<SampledWidths<C> | undefined>,\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  let newColumnWidths;\n  let totalWidth = 0;\n  let widthsArray = [];\n  const tableCols = innerTableElement.querySelectorAll(\n    `[data-oj-table-col='${tableId}']`\n  ) as NodeListOf<HTMLTableColElement>;\n\n  if (isFixed) {\n    newColumnWidths = _getFixedLayoutColumnWidths(availableWidth, columnsArray, staticColumnWidths);\n    for (let i = 0; i < columnsArray.length; i++) {\n      const width = newColumnWidths[columnsArray[i].key];\n      widthsArray.push(width);\n      totalWidth += width;\n    }\n    _updateTableSizing(innerTableElement, tableCols, widthsArray, totalWidth);\n    return newColumnWidths;\n  }\n\n  const headerElements = innerTableElement.querySelectorAll(\n    `[data-oj-table-header-cell='${tableId}']`\n  ) as NodeListOf<HTMLElement>;\n\n  newColumnWidths = _getContentsLayoutColumnWidths(\n    innerTableElement,\n    headerElements,\n    sampledColumnWidthsRef,\n    availableWidth,\n    columnsArray,\n    staticColumnWidths\n  );\n  for (let i = 0; i < columnsArray.length; i++) {\n    const width = newColumnWidths[columnsArray[i].key];\n    widthsArray.push(width);\n    totalWidth += width;\n  }\n  _updateTableSizing(innerTableElement, tableCols, widthsArray, totalWidth);\n\n  if (availableWidth === -1) {\n    // for content sizing, check to see if all space is actually utilized\n    // this supports no width constraint scenarios\n    if (!viewportInfo.isExternalScroller) {\n      availableWidth = scrollerElement.getBoundingClientRect().width - widthOffset;\n    } else {\n      availableWidth = scrollerElement.clientWidth - widthOffset;\n    }\n    if (Math.abs(totalWidth - availableWidth) > 0.005) {\n      newColumnWidths = _getContentsLayoutColumnWidths(\n        innerTableElement,\n        headerElements,\n        sampledColumnWidthsRef,\n        availableWidth,\n        columnsArray,\n        staticColumnWidths\n      );\n      totalWidth = 0;\n      widthsArray = [];\n      for (let i = 0; i < columnsArray.length; i++) {\n        const width = newColumnWidths[columnsArray[i].key];\n        widthsArray.push(width);\n        totalWidth += width;\n      }\n      _updateTableSizing(innerTableElement, tableCols, widthsArray, totalWidth);\n    }\n  }\n  return newColumnWidths;\n}\n\n/**\n * Helper method to extract the individual column widths of the Table\n * for a 'fixed' layout table that already has its root width applied.\n */\nfunction _getFixedLayoutColumnWidths<K, D, C extends string>(\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  const DEFAULT_COLUMN_WEIGHT = 1;\n  const DEFAULT_COLUMN_MIN_WIDTH = 100;\n  const DEFAULT_COLUMN_MAX_WIDTH = undefined;\n\n  let requiresActiveSizing = false;\n  let totalWorkingWeight = 0;\n  let forcedTotalWidth = 0;\n  let pendingTotalWidth = 0;\n  const columnMaxWidthsArray = [];\n  const columnWeightsArray = [];\n  const forcedColumnWidthsArray = [];\n  const newColumnWidthsArray = [];\n  const appliedColumnWidthsArray = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const column = columnsArray[i];\n    let columnMinWidth = column.value.minWidth;\n    if (columnMinWidth == null || columnMinWidth <= 0) {\n      columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;\n    }\n    let columnMaxWidth = column.value.maxWidth;\n    if (columnMaxWidth == null || columnMaxWidth < columnMinWidth) {\n      columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;\n    }\n    columnMaxWidthsArray.push(columnMaxWidth);\n    let columnWeight = column.value.weight;\n    if (columnWeight == null || columnWeight < 1) {\n      columnWeight = DEFAULT_COLUMN_WEIGHT;\n    }\n    columnWeightsArray.push(columnWeight);\n    const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;\n    if (columnWidth != null) {\n      forcedTotalWidth += columnWidth;\n      pendingTotalWidth += columnWidth;\n      forcedColumnWidthsArray.push(columnWidth);\n      newColumnWidthsArray.push(columnWidth);\n      appliedColumnWidthsArray.push(columnWidth);\n    } else {\n      requiresActiveSizing = true;\n      pendingTotalWidth += columnMinWidth;\n      totalWorkingWeight += columnWeight;\n      forcedColumnWidthsArray.push(undefined);\n      newColumnWidthsArray.push(columnMinWidth);\n      appliedColumnWidthsArray.push(columnMinWidth);\n    }\n  }\n\n  // enforce min and max rules if active sizing is required and available space remains\n  if (requiresActiveSizing && pendingTotalWidth < availableWidth) {\n    _enforceFixedMinMaxRules(\n      columnsArray,\n      availableWidth,\n      totalWorkingWeight,\n      forcedTotalWidth,\n      forcedColumnWidthsArray,\n      columnWeightsArray,\n      columnMaxWidthsArray,\n      newColumnWidthsArray,\n      appliedColumnWidthsArray\n    );\n  }\n  return _createColumnWidths(columnsArray, newColumnWidthsArray);\n}\n\n/**\n * Helper function to enforce all of the layout sizing rules on the Table's columns.\n */\nfunction _enforceFixedMinMaxRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalWorkingWeight: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  columnMaxWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  // try and honor the weights of each column combined with the min widths, and then check that against\n  // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width\n  // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.\n  let isMaxRuleApplied = true;\n  while (isMaxRuleApplied) {\n    isMaxRuleApplied = false;\n    _enforceWeightedMinRules(\n      columnsArray,\n      availableWidth,\n      totalWorkingWeight,\n      forcedTotalWidth,\n      forcedColumnWidthsArray,\n      columnWeightsArray,\n      newColumnWidthsArray,\n      appliedColumnWidthsArray\n    );\n    let pendingTotalWidth = 0;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (forcedColumnWidthsArray[i] == null) {\n        const maxWidth = columnMaxWidthsArray[i];\n        if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {\n          isMaxRuleApplied = true;\n          forcedColumnWidthsArray[i] = maxWidth;\n          forcedTotalWidth += maxWidth;\n          totalWorkingWeight -= columnWeightsArray[i];\n          newColumnWidthsArray[i] = maxWidth;\n          appliedColumnWidthsArray[i] = maxWidth;\n        }\n      }\n      pendingTotalWidth += newColumnWidthsArray[i];\n    }\n    isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;\n  }\n}\n\n/**\n * Helper method to extract the individual column widths of the Table\n * for a 'contents' layout table that already has its root width applied.\n */\nfunction _getContentsLayoutColumnWidths<K, D, C extends string>(\n  innerTableElement: HTMLTableElement,\n  headerElements: NodeListOf<HTMLElement>,\n  sampledColumnWidthsRef: MutableRef<SampledWidths<C> | undefined>,\n  availableWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  const DEFAULT_COLUMN_MIN_WIDTH = undefined;\n  const DEFAULT_COLUMN_MAX_WIDTH = undefined;\n\n  let requiresActiveSizing = false;\n  const columnMinWidthsArray = [] as (number | undefined)[];\n  const columnMaxWidthsArray = [];\n  const forcedColumnWidthsArray = [];\n  const newColumnWidthsArray = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const column = columnsArray[i];\n    let columnMinWidth = column.value.minWidth;\n    if (columnMinWidth == null || columnMinWidth <= 0) {\n      columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;\n    }\n    columnMinWidthsArray.push(columnMinWidth);\n    let columnMaxWidth = column.value.maxWidth;\n    if (columnMaxWidth == null || columnMaxWidth < (columnMinWidth != null ? columnMinWidth : 0)) {\n      columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;\n    }\n    columnMaxWidthsArray.push(columnMaxWidth);\n    const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;\n    if (columnWidth != null) {\n      forcedColumnWidthsArray.push(columnWidth);\n      newColumnWidthsArray[i] = columnWidth;\n    } else {\n      requiresActiveSizing = true;\n      forcedColumnWidthsArray.push(undefined);\n    }\n  }\n\n  // short-circuit normal contents sizing if each column specifies a 'width' value\n  if (requiresActiveSizing) {\n    // if active sizing is required, update min width values to reflect actual widths\n    // performance note - this should be the only logic that requires DOM measurements\n    let forcedTotalWidth = 0;\n    let pendingTotalWidth = 0;\n    let totalPreferredWidth = 0;\n    let totalWorkingWeight = 0;\n    let totalRemainingWeight = 0;\n    const sampledWidths = sampledColumnWidthsRef.current;\n    const sampledMinWidthsArray = [];\n    const sampledWeightWidthsArray = [] as number[];\n    const appliedColumnWidthsArray = [];\n    if (sampledWidths != null) {\n      for (let i = 0; i < columnsArray.length; i++) {\n        sampledMinWidthsArray.push(sampledWidths.minWidths[columnsArray[i].key]);\n        sampledWeightWidthsArray.push(sampledWidths.weightWidths[columnsArray[i].key]);\n      }\n    } else {\n      sampledColumnWidthsRef.current = {\n        minWidths: {} as ColumnWidths<C>,\n        weightWidths: {} as ColumnWidths<C>\n      };\n      // when sampledColumnWidths are not populated, table has 'max-content' width applied,\n      // which allows for measurements to represent the column weights\n      for (let i = 0; i < headerElements.length; i++) {\n        const sampledWeightWidth = (headerElements[i] as HTMLElement).getBoundingClientRect().width;\n        sampledWeightWidthsArray.push(sampledWeightWidth);\n        sampledColumnWidthsRef.current.weightWidths[columnsArray[i].key] = sampledWeightWidth;\n      }\n      // specify 'min-content' width, allowing measurements to represent minimum auto-resizable column widths\n      innerTableElement.style.width = 'min-content';\n      for (let i = 0; i < headerElements.length; i++) {\n        const sampledMinWidth = (headerElements[i] as HTMLElement).getBoundingClientRect().width;\n        sampledMinWidthsArray.push(sampledMinWidth);\n        sampledColumnWidthsRef.current.minWidths[columnsArray[i].key] = sampledMinWidth;\n      }\n    }\n\n    for (let i = 0; i < sampledMinWidthsArray.length; i++) {\n      const forcedWidth = forcedColumnWidthsArray[i];\n      if (forcedWidth == null) {\n        let columnWidth;\n        const sampledMinWidth = sampledMinWidthsArray[i];\n        const minWidth = columnMinWidthsArray[i];\n        const maxWidth = columnMaxWidthsArray[i];\n        if (minWidth != null && minWidth >= sampledMinWidth) {\n          columnWidth = minWidth;\n        } else if (maxWidth != null && sampledMinWidth >= maxWidth) {\n          columnWidth = maxWidth;\n        } else {\n          columnWidth = sampledMinWidth;\n        }\n        pendingTotalWidth += columnWidth;\n        // replace sampled weight with min width if needed\n        const columnWeight =\n          minWidth != null && minWidth >= sampledWeightWidthsArray[i]\n            ? minWidth\n            : sampledWeightWidthsArray[i];\n        sampledWeightWidthsArray[i] = columnWeight;\n        totalPreferredWidth +=\n          maxWidth != null && maxWidth <= columnWeight ? maxWidth : columnWeight;\n        totalWorkingWeight += columnWeight;\n        totalRemainingWeight += columnWeight - columnWidth;\n        // newColumnWidthsArray already has content, so update in place rather than 'push'\n        newColumnWidthsArray[i] = columnWidth;\n        appliedColumnWidthsArray.push(columnWidth);\n      } else {\n        forcedTotalWidth += forcedWidth;\n        pendingTotalWidth += forcedWidth;\n        totalPreferredWidth += forcedWidth;\n        appliedColumnWidthsArray.push(forcedWidth);\n      }\n    }\n    // special case for initial rendering where we don't know if overall width is constrained\n    if (availableWidth === -1) {\n      availableWidth = totalPreferredWidth;\n    }\n    if (pendingTotalWidth < availableWidth) {\n      _enforceContentsMinMaxRules(\n        columnsArray,\n        availableWidth,\n        totalPreferredWidth,\n        totalRemainingWeight,\n        totalWorkingWeight,\n        pendingTotalWidth,\n        forcedTotalWidth,\n        forcedColumnWidthsArray,\n        sampledWeightWidthsArray,\n        columnMaxWidthsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    }\n  }\n  return _createColumnWidths(columnsArray, newColumnWidthsArray);\n}\n\n/**\n * Helper function to enforce all of the layout sizing rules on the Table's columns.\n */\nfunction _enforceContentsMinMaxRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalPreferredWidth: number,\n  totalRemainingWeight: number,\n  totalWorkingWeight: number,\n  appliedPendingTotalWidth: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  columnMaxWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  // try and honor the weights of each column combined with the min widths, and then check that against\n  // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width\n  // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.\n  let isMaxRuleApplied = true;\n  while (isMaxRuleApplied) {\n    isMaxRuleApplied = false;\n    if (totalPreferredWidth > availableWidth) {\n      _enforceConstrainedWeightRules(\n        columnsArray,\n        availableWidth - appliedPendingTotalWidth,\n        totalRemainingWeight,\n        columnWeightsArray,\n        forcedColumnWidthsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    } else {\n      _enforceWeightedMinRules(\n        columnsArray,\n        availableWidth,\n        totalWorkingWeight,\n        forcedTotalWidth,\n        forcedColumnWidthsArray,\n        columnWeightsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    }\n\n    let pendingTotalWidth = 0;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (forcedColumnWidthsArray[i] == null) {\n        const maxWidth = columnMaxWidthsArray[i];\n        if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {\n          isMaxRuleApplied = true;\n          forcedColumnWidthsArray[i] = maxWidth;\n          forcedTotalWidth += maxWidth;\n          appliedPendingTotalWidth += maxWidth - appliedColumnWidthsArray[i];\n          totalWorkingWeight -= columnWeightsArray[i];\n          newColumnWidthsArray[i] = maxWidth;\n          appliedColumnWidthsArray[i] = maxWidth;\n        }\n      }\n      pendingTotalWidth += newColumnWidthsArray[i];\n    }\n    isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;\n  }\n}\n\n/**\n * Helper function to enforce constrained weights / min width rules on the Table's columns.\n */\nfunction _enforceConstrainedWeightRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  initialExtraWidth: number,\n  totalRemainingWeight: number,\n  columnWeightsArray: number[],\n  forcedColumnWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  if (initialExtraWidth > 0) {\n    let availableWidth = initialExtraWidth;\n    let currentWeightTotal = totalRemainingWeight;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (currentWeightTotal > 0 && forcedColumnWidthsArray[i] == null) {\n        const currentWeight = columnWeightsArray[i] - appliedColumnWidthsArray[i];\n        const weightWidth = (currentWeight / currentWeightTotal) * availableWidth;\n        newColumnWidthsArray[i] = weightWidth + appliedColumnWidthsArray[i];\n        availableWidth -= weightWidth;\n        currentWeightTotal -= currentWeight;\n      }\n    }\n  }\n}\n\n/**\n * Helper function to enforce the weights / min width rules on the Table's columns.\n */\nfunction _enforceWeightedMinRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalWeight: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  const pendingForcedColumnWidths = [] as (number | undefined)[];\n  let isMinRuleApplied = true;\n  while (isMinRuleApplied) {\n    isMinRuleApplied = false;\n    let currentWeightTotal = totalWeight;\n    let widthDiff = availableWidth - forcedTotalWidth;\n    if (widthDiff > 0) {\n      for (let i = 0; i < columnsArray.length; i++) {\n        if (\n          currentWeightTotal > 0 &&\n          forcedColumnWidthsArray[i] == null &&\n          pendingForcedColumnWidths[i] == null\n        ) {\n          const currentWeight = columnWeightsArray[i];\n          const newWidth = (currentWeight / currentWeightTotal) * widthDiff;\n\n          // if calculated width breaks min width requirement, force min width as needed\n          const minWidth = appliedColumnWidthsArray[i];\n          if (newWidth < minWidth) {\n            // the preferred weighted size conflicts with the min size, so set pending to min size\n            pendingForcedColumnWidths[i] = minWidth;\n            forcedTotalWidth += minWidth;\n            newColumnWidthsArray[i] = minWidth;\n            isMinRuleApplied = true;\n            totalWeight -= currentWeight;\n            break;\n          }\n          newColumnWidthsArray[i] = newWidth;\n          widthDiff -= newWidth;\n          currentWeightTotal -= currentWeight;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Helper function to create a ColumnWidths object from a TableColumn array and a widths array.\n */\nfunction _createColumnWidths<K, D, C extends string>(\n  columnsArray: TableColumn<K, D, C>[],\n  columnWidthsArray: number[]\n) {\n  const columnWidths = {} as ColumnWidths<C>;\n  for (let i = 0; i < columnsArray.length; i++) {\n    columnWidths[columnsArray[i].key] = columnWidthsArray[i];\n  }\n  return columnWidths;\n}\n\n/**\n * Helper method to apply the given sizing object to the currently rendered Table\n * and column elements.\n */\nfunction _updateTableSizing(\n  innerTableElement: HTMLTableElement,\n  tableCols: NodeListOf<HTMLTableColElement>,\n  widthsArray: number[],\n  totalWidth: number\n) {\n  for (let i = 0; i < tableCols.length; i++) {\n    const tableCol = tableCols[i];\n    tableCol.style.width = `${widthsArray[i]}px`;\n  }\n  innerTableElement.style.width = `${totalWidth}px`;\n  innerTableElement.style.tableLayout = 'fixed';\n}\n\n/**\n * Helper function to compare two ColumnWidths instances for equality.\n */\nexport const columnWidthsComparator = <C extends string>(\n  columnWidths1: ColumnWidths<C>,\n  columnWidths2: ColumnWidths<C>\n) => {\n  const keys1 = Object.keys(columnWidths1);\n  const keys2 = Object.keys(columnWidths2);\n  if (keys1.length === keys2.length) {\n    for (const key of keys1) {\n      const columnKey = key as C;\n      if (columnWidths1[columnKey] !== columnWidths2[columnKey]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useLayoutEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport { useResizeObserver } from '../../hooks/UNSAFE_useResizeObserver';\nimport { Column, Columns, ColumnWidths, TableViewportConfig } from '../../UNSAFE_TableView';\nimport { LayoutInfo, SampledWidths, SizingInfo, TableData } from '../Table';\nimport { applyLayoutColumnWidths, columnWidthsComparator } from '../utils/TableLayoutUtils';\nimport {\n  applyOverflowStatus,\n  applyUnderflowStatus,\n  getViewportConfig,\n  updateStickyColumns,\n  updateStickyEdges\n} from '../utils/TableScrollUtils';\n\ntype UseSizingManagerProps<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  scrollerRef: RefObject<HTMLDivElement>;\n  innerTableRef: RefObject<HTMLTableElement>;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  viewportConfig?: TableViewportConfig;\n  layout?: 'contents' | 'fixed' | 'pending';\n  columns: Columns<K, D, C>;\n  columnOrder?: C[];\n  columnWidths?: ColumnWidths<C>;\n  isRtl: boolean;\n};\n\n/**\n * Hook that manages column sizing on the Preact Table\n */\nexport function useSizingManager<K extends string | number, D, C extends string>({\n  rootRef,\n  scrollerRef,\n  innerTableRef,\n  tableId,\n  tableData,\n  viewportConfig,\n  layout,\n  columns,\n  columnOrder,\n  columnWidths,\n  isRtl\n}: UseSizingManagerProps<K, D, C>) {\n  // state to force a rerender following the initial render where scrollbars are forced\n  const [_isScrollbarSizeKnown, setIsScrollbarSizeKnown] = useState<boolean>(false);\n\n  // column width state information\n  const sampledColumnWidthsRef = useRef<SampledWidths<C>>();\n  const [appliedColumnWidths, setAppliedColumnWidths] = useState<ColumnWidths<C>>();\n\n  const [innerTableHeight, setInnerTableHeight] = useState<number | undefined>();\n  const [hasVerticalUnderflow, setHasVerticalUnderflow] = useState<boolean>(false);\n\n  // general table sizing state information\n  const sizingInfoRef = useRef<SizingInfo>({\n    isInitialRender: true,\n    isScrollbarSizeKnown: false\n  });\n  const pendingResizeEntriesRef = useRef<{\n    scroller?: ResizeObserverEntry | undefined;\n    innerTable?: ResizeObserverEntry | undefined;\n  }>({});\n\n  // scrollbar overflow state\n  const overflowRef = useRef<{ isHorizontal: boolean; isVertical: boolean }>({\n    isHorizontal: false,\n    isVertical: false\n  });\n\n  // sticky edge state management\n  const [stickyEdgesState, setStickyEdgesState] = useState<{ start?: number; end?: number }>({});\n\n  // current viewport information\n  const viewportInfo = useMemo(() => {\n    const tableViewportConfig = getViewportConfig(scrollerRef, viewportConfig);\n    return {\n      isExternalScroller: viewportConfig?.scroller() != null,\n      viewportConfig: tableViewportConfig\n    };\n  }, [scrollerRef, viewportConfig]);\n\n  // memoize realized columns array on 'columns' and 'columnOrder'\n  const columnsArray = useMemo(() => {\n    const newColumnsArray = [];\n    if (columnOrder != null) {\n      for (const key of columnOrder) {\n        if (columns[key] != null) {\n          newColumnsArray.push({\n            key: key,\n            value: columns[key]\n          });\n        }\n      }\n    } else {\n      for (const [key, value] of Object.entries(columns)) {\n        newColumnsArray.push({\n          key: key as C,\n          value: value as Column<K, D, C>\n        });\n      }\n    }\n    return newColumnsArray;\n  }, [columnOrder, columns]);\n\n  // determine if a new layout is required\n  let isLayoutRequired = false;\n  const columnWidthsArray = [];\n  if (appliedColumnWidths != null) {\n    for (let i = 0; i < columnsArray.length; i++) {\n      const key = columnsArray[i].key;\n      const appliedWidth = appliedColumnWidths[key];\n      const staticWidth = columnWidths != null ? columnWidths[key] : undefined;\n      if (appliedWidth == null || (staticWidth != null && staticWidth !== appliedWidth)) {\n        isLayoutRequired = true;\n        break;\n      }\n      columnWidthsArray.push(appliedWidth);\n    }\n  } else {\n    isLayoutRequired = true;\n  }\n  const layoutInfo = {\n    isLayoutRequired: isLayoutRequired,\n    columnWidthsArray: isLayoutRequired ? undefined : columnWidthsArray\n  } as LayoutInfo;\n\n  // ensure sampled column sizes are cleared if 'columns', 'columnOrder', or 'layout' is updated\n  useLayoutEffect(() => {\n    sampledColumnWidthsRef.current = undefined;\n    setAppliedColumnWidths(undefined);\n  }, [columns, columnOrder, layout]);\n\n  // ensure applied column widths are cleared if 'columnWidths' is updated\n  useLayoutEffect(() => {\n    setAppliedColumnWidths(undefined);\n  }, [columnWidths]);\n\n  // setup sizing calculation updates for subsequent renders\n  useLayoutEffect(() => {\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    const innerTableElement = innerTableRef.current;\n    if (\n      layout !== 'pending' &&\n      scrollerElement != null &&\n      innerTableElement != null &&\n      !sizingInfoRef.current.isInitialRender &&\n      (viewportInfo.isExternalScroller || sizingInfoRef.current.isScrollbarSizeKnown) &&\n      layoutInfo.isLayoutRequired &&\n      columnsArray.length > 0\n    ) {\n      let widthOffset = 0;\n      if (viewportInfo.isExternalScroller) {\n        const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;\n        if (scrollerOffsetStart != null) {\n          widthOffset += scrollerOffsetStart;\n        }\n        const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;\n        if (scrollerOffsetEnd != null) {\n          widthOffset += scrollerOffsetEnd;\n        }\n      } else if (sizingInfoRef.current.isScrollbarSizeKnown) {\n        widthOffset = sizingInfoRef.current.defaultScrollbarWidth;\n      }\n      const totalWidth = layout === 'fixed' ? sizingInfoRef.current.contentWidth - widthOffset : -1;\n      const newColumnWidths = applyLayoutColumnWidths(\n        scrollerElement,\n        viewportInfo,\n        innerTableElement,\n        widthOffset,\n        tableId,\n        layout === 'fixed',\n        sampledColumnWidthsRef,\n        totalWidth,\n        columnsArray,\n        columnWidths\n      );\n      setAppliedColumnWidths(newColumnWidths);\n    }\n  }, [\n    viewportInfo,\n    innerTableRef,\n    tableId,\n    columnsArray,\n    columnWidths,\n    layout,\n    layoutInfo.isLayoutRequired\n  ]);\n\n  useLayoutEffect(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (\n      layout !== 'pending' &&\n      rootElement != null &&\n      scrollerElement != null &&\n      appliedColumnWidths != null\n    ) {\n      updateStickyColumns(\n        rootElement,\n        scrollerElement,\n        viewportInfo,\n        tableId,\n        isRtl,\n        columnsArray,\n        appliedColumnWidths,\n        stickyEdgesState,\n        setStickyEdgesState,\n        viewportInfo.isExternalScroller || overflowRef.current.isHorizontal\n      );\n    }\n  }, [\n    tableData,\n    rootRef,\n    viewportInfo,\n    tableId,\n    appliedColumnWidths,\n    columnsArray,\n    layout,\n    stickyEdgesState,\n    isRtl\n  ]);\n\n  // helper method to update the sticky edge styling due to resize events\n  const _updateStickyEdgesFromResize = useCallback(\n    (scrollerElement: HTMLElement) => {\n      if (appliedColumnWidths != null) {\n        if (viewportInfo.isExternalScroller || overflowRef.current.isHorizontal) {\n          // ensure sticky edges are applied correctly if horizontal overflow is present\n          const fullColumnWidths = [];\n          for (let i = 0; i < columnsArray.length; i++) {\n            const width = appliedColumnWidths[columnsArray[i].key];\n            fullColumnWidths.push(width);\n          }\n          updateStickyEdges(\n            scrollerElement,\n            columnsArray,\n            fullColumnWidths,\n            stickyEdgesState,\n            setStickyEdgesState\n          );\n        } else if (stickyEdgesState.start != null || stickyEdgesState.end != null) {\n          // otherwise clear sticky edges if necessary\n          setStickyEdgesState({});\n        }\n      }\n    },\n    [appliedColumnWidths, columnsArray, stickyEdgesState, viewportInfo]\n  );\n\n  // callback function to handle resizes of the scroller and inner table elements\n  const handleResizeCallback = useCallback(() => {\n    let currentEntry = pendingResizeEntriesRef.current.scroller;\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    const innerTableElement = innerTableRef.current;\n    let isOveralSizeHandled = false;\n\n    // handle scroller element resize notification\n    if (\n      currentEntry != null &&\n      rootElement != null &&\n      scrollerElement != null &&\n      innerTableElement != null\n    ) {\n      const newContentWidth = currentEntry.contentBoxSize[0].inlineSize;\n      const newContentHeight = currentEntry.contentBoxSize[0].blockSize;\n      const newBoxWidth = currentEntry.borderBoxSize[0].inlineSize;\n      const newBoxHeight = currentEntry.borderBoxSize[0].blockSize;\n\n      if (newBoxWidth !== 0 || newBoxHeight !== 0) {\n        isOveralSizeHandled = true;\n        let availableWidth;\n        let availableWidthOffset = 0;\n        let defaultScrollbarWidth = 0;\n        if (viewportInfo.isExternalScroller) {\n          const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;\n          if (scrollerOffsetStart != null) {\n            availableWidthOffset += scrollerOffsetStart;\n          }\n          const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;\n          if (scrollerOffsetEnd != null) {\n            availableWidthOffset += scrollerOffsetEnd;\n          }\n          if (sizingInfoRef.current.isScrollbarSizeKnown) {\n            sizingInfoRef.current = {\n              isInitialRender: false,\n              contentWidth: newContentWidth,\n              boxWidth: newBoxWidth,\n              contentHeight: newContentHeight,\n              boxHeight: newBoxHeight,\n              isScrollbarSizeKnown: true,\n              defaultScrollbarWidth: sizingInfoRef.current.defaultScrollbarWidth,\n              defaultScrollbarHeight: sizingInfoRef.current.defaultScrollbarHeight\n            };\n          } else {\n            sizingInfoRef.current = {\n              isInitialRender: false,\n              contentWidth: newContentWidth,\n              boxWidth: newBoxWidth,\n              contentHeight: newContentHeight,\n              boxHeight: newBoxHeight,\n              isScrollbarSizeKnown: false\n            };\n          }\n          availableWidth = newContentWidth - availableWidthOffset;\n        } else {\n          const isInitialRender = sizingInfoRef.current.isInitialRender;\n          if (sizingInfoRef.current.isScrollbarSizeKnown) {\n            availableWidthOffset = sizingInfoRef.current.defaultScrollbarWidth;\n            sizingInfoRef.current = {\n              isInitialRender: false,\n              contentWidth: newContentWidth,\n              boxWidth: newBoxWidth,\n              contentHeight: newContentHeight,\n              boxHeight: newBoxHeight,\n              isScrollbarSizeKnown: true,\n              defaultScrollbarWidth: sizingInfoRef.current.defaultScrollbarWidth,\n              defaultScrollbarHeight: sizingInfoRef.current.defaultScrollbarHeight\n            };\n          } else {\n            // on the first render that does not specify an external scroller, horizontal and\n            // vertical scrollbars are forced in order to determine default browser sizes\n            availableWidthOffset = newBoxWidth - newContentWidth;\n            sizingInfoRef.current = {\n              isInitialRender: false,\n              contentWidth: newContentWidth,\n              boxWidth: newBoxWidth,\n              contentHeight: newContentHeight,\n              boxHeight: newBoxHeight,\n              isScrollbarSizeKnown: true,\n              defaultScrollbarWidth: availableWidthOffset,\n              defaultScrollbarHeight: newBoxHeight - newContentHeight\n            };\n            setIsScrollbarSizeKnown(true);\n          }\n          defaultScrollbarWidth = sizingInfoRef.current.defaultScrollbarWidth;\n          availableWidth = !isInitialRender || layout === 'fixed' ? newContentWidth : -1;\n        }\n        if (columnsArray.length > 0) {\n          let newColumnWidths;\n          if (layout !== 'pending') {\n            newColumnWidths = applyLayoutColumnWidths(\n              scrollerElement,\n              viewportInfo,\n              innerTableElement,\n              availableWidthOffset,\n              tableId,\n              layout === 'fixed',\n              sampledColumnWidthsRef,\n              availableWidth,\n              columnsArray,\n              columnWidths\n            );\n            if (\n              appliedColumnWidths == null ||\n              !columnWidthsComparator(appliedColumnWidths, newColumnWidths)\n            ) {\n              setAppliedColumnWidths(newColumnWidths);\n            } else {\n              newColumnWidths = undefined;\n            }\n          }\n          // ensure scrollbars are applied correctly - a scrollbar could be needed\n          if (viewportInfo.isExternalScroller) {\n            applyUnderflowStatus(rootElement, tableId, setHasVerticalUnderflow);\n          } else {\n            const innerTableRect = innerTableElement.getBoundingClientRect();\n            applyOverflowStatus(\n              rootElement,\n              scrollerElement,\n              tableId,\n              innerTableRect.width,\n              newContentWidth,\n              innerTableRect.height,\n              newContentHeight,\n              defaultScrollbarWidth,\n              overflowRef,\n              setHasVerticalUnderflow\n            );\n          }\n          if (layout !== 'pending') {\n            if (newColumnWidths != null) {\n              updateStickyColumns(\n                rootElement,\n                scrollerElement,\n                viewportInfo,\n                tableId,\n                isRtl,\n                columnsArray,\n                newColumnWidths,\n                stickyEdgesState,\n                setStickyEdgesState,\n                viewportInfo.isExternalScroller || overflowRef.current.isHorizontal\n              );\n            } else {\n              _updateStickyEdgesFromResize(scrollerElement);\n            }\n          }\n        }\n      }\n    }\n    currentEntry = pendingResizeEntriesRef.current.innerTable;\n    if (currentEntry != null) {\n      const newBoxWidth = currentEntry.borderBoxSize[0].inlineSize;\n      const newBoxHeight = currentEntry.borderBoxSize[0].blockSize;\n      // if only an inner table resize occurred, ensure scrollbars are applied correctly\n      if (\n        !isOveralSizeHandled &&\n        rootElement != null &&\n        scrollerElement != null &&\n        columnsArray.length > 0 &&\n        (newBoxWidth !== 0 || newBoxHeight !== 0)\n      ) {\n        if (viewportInfo.isExternalScroller) {\n          applyUnderflowStatus(rootElement, tableId, setHasVerticalUnderflow);\n        } else if (sizingInfoRef.current.isScrollbarSizeKnown) {\n          applyOverflowStatus(\n            rootElement,\n            scrollerElement,\n            tableId,\n            newBoxWidth,\n            sizingInfoRef.current.contentWidth,\n            newBoxHeight,\n            sizingInfoRef.current.contentHeight,\n            sizingInfoRef.current.defaultScrollbarWidth,\n            overflowRef,\n            setHasVerticalUnderflow\n          );\n        }\n        if (layout !== 'pending') {\n          _updateStickyEdgesFromResize(scrollerElement);\n        }\n      }\n      setInnerTableHeight(newBoxHeight);\n    }\n    pendingResizeEntriesRef.current = {};\n  }, [\n    rootRef,\n    viewportInfo,\n    innerTableRef,\n    tableId,\n    layout,\n    columnsArray,\n    columnWidths,\n    appliedColumnWidths,\n    stickyEdgesState,\n    isRtl,\n    _updateStickyEdgesFromResize\n  ]);\n\n  // ensure resize observers have access to the latest state information\n  const handleResizeCallbackRef = useRef<() => void>(handleResizeCallback);\n  handleResizeCallbackRef.current = handleResizeCallback;\n\n  // resize observer callback functions are static to avoid hook re-subscribing each render\n  const staticHandleScrollerResize = useCallback((entry: ResizeObserverEntry) => {\n    // only queue up an animation frame if there isn't one already pending\n    if (\n      pendingResizeEntriesRef.current.scroller == null ||\n      pendingResizeEntriesRef.current.innerTable == null\n    ) {\n      window.requestAnimationFrame(() => {\n        handleResizeCallbackRef.current();\n      });\n    }\n    pendingResizeEntriesRef.current.scroller = entry;\n  }, []);\n  const staticHandleInnerTableResize = useCallback((entry: ResizeObserverEntry) => {\n    // only queue up an animation frame if there isn't one already pending\n    if (\n      pendingResizeEntriesRef.current.scroller == null ||\n      pendingResizeEntriesRef.current.innerTable == null\n    ) {\n      window.requestAnimationFrame(() => {\n        handleResizeCallbackRef.current();\n      });\n    }\n    pendingResizeEntriesRef.current.innerTable = entry;\n  }, []);\n  useResizeObserver(viewportInfo.viewportConfig.scroller(), staticHandleScrollerResize);\n  useResizeObserver(innerTableRef, staticHandleInnerTableResize);\n\n  return {\n    layoutInfo,\n    viewportInfo,\n    columnsArray,\n    appliedColumnWidths,\n    sizingInfoRef,\n    innerTableHeight,\n    hasVerticalUnderflow,\n    stickyEdgesState,\n    setStickyEdgesState,\n    overflowRef\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useRef } from 'preact/hooks';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { JSXInternal } from 'preact/src/jsx';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { Cell, CellOverride, Column, ColumnWidths, TableViewportConfig } from '../UNSAFE_TableView';\nimport { TableColGroup } from './TableColGroup';\nimport { TableBody } from './TableBody';\nimport { TableHeader } from './TableHeader';\nimport { TableFooter } from './TableFooter';\nimport { TableDragIndicator } from './TableDragIndicator';\nimport { TableSkeletonRow } from './TableSkeletonRow';\nimport { TableContextMenu } from './TableContextMenu';\nimport { FocusTracker } from '../PRIVATE_FocusTracker';\nimport { Props, TableViewHandle } from '../UNSAFE_TableView';\nimport { useDataManager } from './hooks/useDataManager';\nimport { useInteractionManager } from './hooks/useInteractionManager';\nimport { useSizingManager } from './hooks/useSizingManager';\nimport { innerTableStyles, scrollerStyles } from './themes/Table.css';\nimport { tableSkeletonStyles, tableSkeletonStylesHC } from './themes/TableSkeletonStyles.css';\nimport { TableVariantOptions } from './themes/TableStyles.css';\nimport { TableRedwoodTheme } from './themes/redwood/TableTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { useTestId } from '../hooks/UNSAFE_useTestId';\n\nexport type ActiveCell<K, C> =\n  | Cell<K, C>\n  | {\n      rowKey?: never;\n      columnKey: C;\n      type: 'loading';\n    }\n  | {\n      rowKey?: never;\n      columnKey: C;\n      type: 'loadMore';\n    }\n  | {\n      rowKey?: never;\n      columnKey?: never;\n      type: 'pending';\n    };\n\nexport type ActiveCellDetail<K, C> = {\n  value?: ActiveCell<K, C>;\n};\n\nexport type TableColumn<K, D, C> = {\n  key: C;\n  value: Column<K, D, C>;\n};\n\nexport type TableData<K, D> = {\n  data: D;\n  metadata: K;\n};\n\nexport type CurrencyStatus<K, D, C> = {\n  activeCell?: ActiveCell<K, C>;\n  currentCell?: Cell<K, C>;\n  currentCellOverride?: CellOverride<K, C>;\n  hasPendingCurrentCellOverride: boolean;\n  hasPendingCurrentCellOverrideScroll: boolean;\n  previousEmbeddedSelectCurrentCell?: Cell<K, C>;\n  loadMoreInitialData?: TableData<K, D>[];\n};\n\nexport type SampledWidths<C extends string> = {\n  minWidths: ColumnWidths<C>;\n  weightWidths: ColumnWidths<C>;\n};\n\nexport type ViewportInfo = {\n  isExternalScroller: boolean;\n  viewportConfig: TableViewportConfig;\n};\n\nexport type SizingInfo =\n  | {\n      isInitialRender: true;\n      boxWidth?: number;\n      contentWidth?: number;\n      boxHeight?: number;\n      contentHeight?: number;\n      isScrollbarSizeKnown: false;\n      defaultScrollbarWidth?: number;\n      defaultScrollbarHeight?: number;\n    }\n  | {\n      isInitialRender: false;\n      boxWidth: number;\n      contentWidth: number;\n      boxHeight: number;\n      contentHeight: number;\n      isScrollbarSizeKnown: true;\n      defaultScrollbarWidth: number;\n      defaultScrollbarHeight: number;\n    }\n  | {\n      isInitialRender: false;\n      boxWidth: number;\n      contentWidth: number;\n      boxHeight: number;\n      contentHeight: number;\n      isScrollbarSizeKnown: false;\n      defaultScrollbarWidth?: number;\n      defaultScrollbarHeight?: number;\n    };\n\nexport type LayoutInfo =\n  | {\n      isLayoutRequired: true;\n      columnWidthsArray?: number[];\n    }\n  | {\n      isLayoutRequired: false;\n      columnWidthsArray: number[];\n    };\n\nexport type ColumnResizeInfo<C> =\n  | {\n      isResizing: false;\n      isResizeHover: boolean;\n      key?: C;\n      startX?: never;\n      delta?: never;\n      fullColumnWidths?: never;\n      ignoreClick: boolean;\n    }\n  | {\n      isResizing: true;\n      isResizeHover: boolean;\n      key: C;\n      startX: number;\n      delta: number;\n      fullColumnWidths: number[];\n      ignoreClick: boolean;\n    };\n\nexport type ScrollDetail<K, C> = {\n  cell: ActiveCell<K, C> | Cell<K, C>;\n  locationX?: 'inView' | 'start' | 'end';\n  locationY?: 'inView' | 'top' | 'bottom';\n};\n\nconst _defaultSelected = {\n  row: { all: false, keys: new Set() },\n  column: { all: false, keys: new Set() }\n};\n\nconst _disabledHeaderFooterInteractionKeys: ('enter' | 'space')[] = ['enter'];\n\n/**\n * Component that renders data in a flat table.\n */\nexport const Table = forwardRef(function Table<K extends string | number, D, C extends string>(\n  {\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledBy,\n    getAccessibleRowHeaders,\n    columns,\n    columnOrder,\n    columnWidths,\n    contextMenuConfig,\n    viewportConfig,\n    layout = 'contents',\n    data,\n    getRowKey,\n    hasMore = false,\n    onLoadMore = () => {},\n    currentCellOverride,\n    onPersistCurrentCell,\n    currentRowVariant = 'none',\n    gridlines,\n    selectionMode,\n    selected = _defaultSelected as NonNullable<Props<K, D, C>['selected']>,\n    onSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    horizontalScrollPositionOverride,\n    verticalScrollPositionOverride,\n    columnResizingIndicator,\n    onColumnResizing,\n    onColumnResize,\n    noDataRenderer,\n    testId\n  }: Props<K, D, C>,\n  ref?: ForwardedRef<TableViewHandle<K, C>>\n) {\n  const tableId = useId();\n  const testIdProps = useTestId(testId);\n\n  const rootRef = useRef<HTMLDivElement>(null);\n  const scrollerRef = useRef<HTMLDivElement>(null);\n  const innerTableRef = useRef<HTMLTableElement>(null);\n\n  const { direction, forcedColors } = useUser();\n  const isHighContrast = forcedColors === 'active';\n  const isRtl = direction === 'rtl';\n\n  const { tableData, onTableLoadMore } = useDataManager<K, D>({\n    data,\n    getRowKey,\n    hasMore,\n    onLoadMore\n  });\n\n  const {\n    layoutInfo,\n    viewportInfo,\n    columnsArray,\n    appliedColumnWidths,\n    sizingInfoRef,\n    innerTableHeight,\n    hasVerticalUnderflow,\n    stickyEdgesState,\n    setStickyEdgesState,\n    overflowRef\n  } = useSizingManager<K, D, C>({\n    rootRef,\n    scrollerRef,\n    innerTableRef,\n    tableId,\n    tableData,\n    viewportConfig,\n    layout,\n    columns,\n    columnOrder,\n    columnWidths,\n    isRtl\n  });\n\n  const cellHasRenderer = useCallback(\n    (cell: ActiveCell<K, C>) => {\n      let hasRenderer = false;\n      if (cell.type === 'noData') {\n        hasRenderer = noDataRenderer != null;\n      } else if (cell.type !== 'loadMore' && cell.type !== 'loading' && cell.type !== 'pending') {\n        for (const column of columnsArray) {\n          if (column.key === cell.columnKey) {\n            if (cell.type === 'data') {\n              hasRenderer = column.value.renderer != null;\n            } else if (cell.type === 'header') {\n              hasRenderer = column.value.headerRenderer != null;\n            } else if (cell.type === 'footer') {\n              hasRenderer = column.value.footerRenderer != null;\n            }\n            break;\n          }\n        }\n      }\n      return hasRenderer;\n    },\n    [columnsArray, noDataRenderer]\n  );\n\n  const isPendingLayout = layout === 'pending';\n\n  // aria-rowcount includes header and footer rows\n  const hasFooters = columnsArray.some((column: TableColumn<K, D, C>) => {\n    return column.value.footerRenderer != null || column.value.footerText != null;\n  });\n  const ariaRowCount = hasMore || isPendingLayout ? -1 : tableData.length + (hasFooters ? 2 : 1);\n  const ariaColumnCount = Math.max(columnsArray.length, 1);\n\n  const {\n    interactionManagerProps,\n    scrollHandlingProps,\n    onTableSelectionChange,\n    isShowFocusRing,\n    isTabbableMode,\n    currentCell,\n    currentActiveCell,\n    resizeInfoRef,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge,\n    hoverColumnKey,\n    tooltipContent,\n    contextMenuContext,\n    menuProps,\n    disabledRowInteractionKeys\n  } = useInteractionManager<K, D, C>({\n    rootRef,\n    viewportInfo,\n    ref,\n    tableId,\n    tableData,\n    hasMore,\n    hasFooters,\n    isRtl,\n    columnsArray,\n    appliedColumnWidths,\n    layoutInfo,\n    sizingInfoRef,\n    stickyEdgesState,\n    setStickyEdgesState,\n    cellHasRenderer,\n    horizontalScrollPositionOverride,\n    verticalScrollPositionOverride,\n    onColumnResizing,\n    onColumnResize,\n    currentCellOverride,\n    onPersistCurrentCell,\n    selectionMode,\n    selected,\n    onSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    isPendingLayout,\n    contextMenuConfig\n  });\n\n  // initialize base Table style classes\n  const { classes: themeClasses } = useComponentTheme<TableVariantOptions>(TableRedwoodTheme, {\n    pendingLayout: isPendingLayout ? 'isPendingLayout' : 'notPendingLayout',\n    showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing',\n    externalScroller: viewportInfo.isExternalScroller ? 'isExternalScroller' : 'notExternalScroller'\n  });\n\n  let scrollerStyle;\n  let scrollerPadding = '';\n  const scrollerClassArray = [scrollerStyles.base];\n  if (viewportInfo.isExternalScroller) {\n    scrollerClassArray.push(scrollerStyles.externalScroller);\n  } else if (!sizingInfoRef.current.isScrollbarSizeKnown) {\n    scrollerClassArray.push(scrollerStyles.forceScroll);\n  } else {\n    if (overflowRef.current.isHorizontal) {\n      scrollerClassArray.push(scrollerStyles.horizontalScroll);\n    } else {\n      scrollerClassArray.push(scrollerStyles.noHorizontalScroll);\n    }\n    if (overflowRef.current.isVertical) {\n      scrollerClassArray.push(scrollerStyles.verticalScroll);\n    } else {\n      scrollerClassArray.push(scrollerStyles.noVerticalScroll);\n      scrollerPadding = `padding-inline-end: ${sizingInfoRef.current.defaultScrollbarWidth}px;`;\n    }\n  }\n  // hide the table contents when layout is required and otherwise valid\n  if (layoutInfo.isLayoutRequired && columnsArray.length > 0) {\n    scrollerStyle = `${scrollerPadding}opacity:0.001;`;\n  } else {\n    scrollerStyle = scrollerPadding;\n  }\n\n  const scrollerClasses = classNames(scrollerClassArray);\n\n  const classes = classNames([themeClasses]);\n  const tableClasses = classNames([innerTableStyles.base]);\n\n  const startStickyEdge = stickyEdgesState.start;\n  const endStickyEdge = stickyEdgesState.end;\n\n  const hasVerticalGridlines = gridlines?.vertical === 'visible';\n  const hasHorizontalGridlines = gridlines?.horizontal !== 'hidden';\n\n  const isRowSelectionEnabled =\n    selectionMode?.row === 'single' || selectionMode?.row === 'multiple';\n  const isColumnSelectionEnabled =\n    selectionMode?.column === 'single' || selectionMode?.column === 'multiple';\n\n  const getTableBodyProps = () => {\n    return {\n      rootRef: rootRef,\n      viewportInfo: viewportInfo,\n      tableId: tableId,\n      isValidRender: columnsArray.length > 0,\n      tableData: tableData,\n      columnsArray: columnsArray,\n      getAccessibleRowHeaders: getAccessibleRowHeaders,\n      hasVerticalGridlines: hasVerticalGridlines,\n      hasHorizontalGridlines: hasHorizontalGridlines,\n      hasFooters: hasFooters,\n      hasVerticalUnderflow: hasVerticalUnderflow,\n      selected: selected,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      isSingleRowSelectionEnabled: selectionMode?.row === 'single',\n      activeCell: currentActiveCell,\n      currentRowKey: currentCell?.type === 'data' ? currentCell.rowKey : undefined,\n      currentRowVariant: currentRowVariant,\n      isShowFocusRing: isShowFocusRing,\n      isTabbableMode: isTabbableMode,\n      hasMore: hasMore,\n      onLoadMore: onTableLoadMore,\n      noDataRenderer: noDataRenderer,\n      disabledInteractionKeys: disabledRowInteractionKeys,\n      onSelectionChange: onTableSelectionChange,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isRtl: isRtl,\n      isHighContrast: isHighContrast\n    };\n  };\n\n  const getTableColGroupProps = () => {\n    let columnWidthsArray;\n    if (!layoutInfo.isLayoutRequired) {\n      columnWidthsArray = layoutInfo.columnWidthsArray;\n    } else if (layout === 'fixed') {\n      // default to 100px for each column when layout is not yet available\n      columnWidthsArray = [];\n      for (let i = 0; i < columnsArray.length; i++) {\n        columnWidthsArray[i] = 100;\n      }\n    } else {\n      columnWidthsArray = [];\n      for (let i = 0; i < columnsArray.length; i++) {\n        columnWidthsArray[i] = undefined;\n      }\n    }\n    return {\n      tableId: tableId,\n      isRendered: columnsArray.length > 0,\n      columnWidthsArray: columnWidthsArray\n    };\n  };\n\n  const getTableHeaderProps = () => {\n    return {\n      tableId: tableId,\n      isRendered: columnsArray.length > 0,\n      columnsArray: columnsArray,\n      hasVerticalGridlines: hasVerticalGridlines,\n      activeKey: currentActiveCell?.type === 'header' ? currentActiveCell.columnKey : undefined,\n      isTabbableMode: isTabbableMode,\n      selectedColumnKeys: selected.column,\n      selectedRowKeys: selected.row,\n      isColumnSelectionEnabled: isColumnSelectionEnabled,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      disabledInteractionKeys: _disabledHeaderFooterInteractionKeys,\n      onSelectionChange: onTableSelectionChange,\n      isForceSortIcons: layout === 'contents' && layoutInfo.isLayoutRequired,\n      hoverColumnKey: hoverColumnKey,\n      sortCriterion: sortCriterion,\n      onSortCriterionChange: onSortCriterionChange,\n      isShowFocusRing: isShowFocusRing,\n      stickyTopOffset: viewportInfo.viewportConfig.scrollerOffsetTop,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      isResizeHover: resizeInfoRef.current.isResizeHover,\n      isRtl: isRtl,\n      isHighContrast: isHighContrast\n    };\n  };\n\n  const getTableFooterProps = () => {\n    return {\n      tableId: tableId,\n      isRendered: hasFooters,\n      columnsArray: columnsArray,\n      hasVerticalGridlines: hasVerticalGridlines,\n      activeKey: currentActiveCell?.type === 'footer' ? currentActiveCell.columnKey : undefined,\n      isTabbableMode: isTabbableMode,\n      selectedKeys: selected.column,\n      isColumnSelectionEnabled: isColumnSelectionEnabled,\n      isShowFocusRing: isShowFocusRing,\n      disabledInteractionKeys: _disabledHeaderFooterInteractionKeys,\n      stickyBottomOffset: viewportInfo.viewportConfig.scrollerOffsetBottom,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      dataRowCount: tableData.length,\n      isRtl: isRtl,\n      isHighContrast: isHighContrast\n    };\n  };\n\n  const getTableDragIndicator = () => {\n    if (columnResizingIndicator != null && !layoutInfo.isLayoutRequired) {\n      let position = 0;\n      for (let i = 0; i < columnsArray.length; i++) {\n        position += layoutInfo.columnWidthsArray[i];\n        if (columnsArray[i].key === columnResizingIndicator.key) {\n          if (columnResizingIndicator.delta != null) {\n            position += columnResizingIndicator.delta;\n          }\n          break;\n        }\n      }\n      return <TableDragIndicator position={position} isRtl={isRtl} height={innerTableHeight} />;\n    }\n    return undefined;\n  };\n\n  const getTableStyle = () => {\n    if (!layoutInfo.isLayoutRequired) {\n      let totalWidth = 0;\n      for (let i = 0; i < layoutInfo.columnWidthsArray.length; i++) {\n        totalWidth += layoutInfo.columnWidthsArray[i];\n      }\n      return `width:${totalWidth}px;table-layout:fixed;`;\n    } else if (columnsArray.length > 0) {\n      if (layout === 'fixed') {\n        // default to 100px for each column when layout is not yet available\n        return `width:${columnsArray.length * 100}px;table-layout:fixed;`;\n      } else {\n        // shrink table down as much as possible when a 'contents' layout is required, otherwise\n        // the sampled column widths will not reflect the true weight sizes with line-clamping\n        return 'width:max-content;will-change:width;';\n      }\n    }\n    // no columns are present\n    return 'width:100%;';\n  };\n\n  const skeletonStyles = isHighContrast ? tableSkeletonStylesHC : tableSkeletonStyles;\n  const getPendingLayoutSkeletons = () => {\n    return isPendingLayout ? (\n      <div class={skeletonStyles.pendingLayout}>\n        <table role={'presentation'} style={'width:100%;table-layout:fixed;'}>\n          <tbody role={'presentation'}>\n            <TableSkeletonRow\n              tableId={tableId}\n              hasTabIndex={currentActiveCell?.type === 'pending'}\n              colspan={ariaColumnCount}\n              isPendingLayout={true}\n              isShowFocusRing={false}\n              isHighContrast={isHighContrast}\n            />\n          </tbody>\n        </table>\n      </div>\n    ) : undefined;\n  };\n\n  return (\n    <>\n      <div\n        {...testIdProps}\n        ref={rootRef}\n        aria-colcount={ariaColumnCount}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        aria-rowcount={ariaRowCount}\n        {...(selectionMode?.column === 'multiple' || selectionMode?.row === 'multiple'\n          ? { 'aria-multiselectable': true }\n          : {})}\n        class={classes}\n        id={tableId}\n        role={'grid'}\n        tabIndex={currentActiveCell != null ? -1 : 0}\n        {...interactionManagerProps}>\n        <div\n          ref={scrollerRef}\n          class={scrollerClasses}\n          role={'rowgroup'}\n          style={scrollerStyle}\n          tabIndex={-1}\n          {...scrollHandlingProps}>\n          <FocusTracker\n            isDisabled={!isTabbableMode}\n            onFocusStartEdge={onFocusStartEdge}\n            onFocusEndEdge={onFocusEndEdge}\n            onStartTracking={onStartFocusTracking}>\n            <TabbableModeContext.Provider value={{ isTabbable: isTabbableMode }}>\n              <table\n                ref={innerTableRef}\n                aria-hidden={isPendingLayout ? true : undefined}\n                class={tableClasses}\n                role={'presentation'}\n                style={getTableStyle()}\n                data-oj-table-inner-table={tableId}>\n                <TableColGroup {...getTableColGroupProps()} />\n                <TableHeader {...getTableHeaderProps()} />\n                <TableBody {...getTableBodyProps()} />\n                <TableFooter {...getTableFooterProps()} />\n              </table>\n            </TabbableModeContext.Provider>\n            {getTableDragIndicator()}\n          </FocusTracker>\n          {tooltipContent}\n        </div>\n        {getPendingLayoutSkeletons()}\n      </div>\n      {contextMenuConfig != null && contextMenuContext != null && (\n        <TableContextMenu\n          {...menuProps}\n          contextMenuConfig={contextMenuConfig}\n          contextMenuContext={contextMenuContext}\n        />\n      )}\n    </>\n  );\n}) as <K extends string | number, D, C extends string>(\n  p: Props<K, D, C> & { ref?: ForwardedRef<TableViewHandle<K, C>> }\n) => JSXInternal.Element;\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useMemo, useRef } from 'preact/hooks';\nimport { TableData } from '../Table';\n\ntype UseDataManagerProps<K, D> = {\n  data?: D[];\n  getRowKey: (data: D) => K;\n  hasMore: boolean;\n  onLoadMore: () => void;\n};\n\n/**\n * Hook that manages data on the Preact Table\n */\nexport function useDataManager<K extends string | number, D>({\n  data,\n  getRowKey,\n  hasMore,\n  onLoadMore\n}: UseDataManagerProps<K, D>) {\n  const tableData = useMemo(() => {\n    const newDataArray =\n      data != null\n        ? data.map((d: D) => {\n            const key = getRowKey(d);\n            return { data: d, metadata: key };\n          })\n        : [];\n    return newDataArray as Array<TableData<K, D>>;\n  }, [data, getRowKey]);\n\n  // debounce loadMore calls to prevent state changes from triggering multiple calls\n  const loadMoreDataRef = useRef<TableData<K, D>[]>();\n  if (!hasMore) {\n    // clear loadMoreData cache once more data is not available\n    loadMoreDataRef.current = undefined;\n  }\n  const onTableLoadMore = useCallback(() => {\n    if (tableData === loadMoreDataRef.current) {\n      return;\n    }\n    loadMoreDataRef.current = tableData;\n    return onLoadMore();\n  }, [tableData, onLoadMore]);\n\n  return { tableData, onTableLoadMore };\n}\n"],"names":["TableColGroup","tableId","isRendered","columnWidthsArray","getColStyle","columnWidth","_jsx","jsx","children","map","style","skeletonDimensionInterpolation","Array","from","x","dimensionInterpolations","interpolations","Object","values","SkeletonInterpolations","mergeInterpolations","TableSkeleton","props","skeletonStyles","isHighContrast","tableSkeletonStylesHC","tableSkeletonStyles","classes","classNames","bar","skeletonDimensions","width","class","TableSkeletonRow","colspan","hasTabIndex","isShowFocusRing","isPendingLayout","isLoadMore","translations","useTranslationBundle","cellClassArray","cell","push","focus","cellClasses","innerCellClasses","innerCell","rowClasses","row","rowHeight","firstRowClasses","headerHeight","accCellContent","collection_loading","LOADMORE_STYLE_CLASS","role","colSpan","tabIndex","_jsxs","_element","index","height","getDataCellClassArray","isFirstColumnIndex","isFinalColumnIndex","isFirstRowIndex","isFinalRowIndex","hasVerticalGridlines","hasHorizontalGridlines","hasLastHorizontalGridline","isRowSelected","isPreviousRowSelected","isColumnSelected","isPreviousColumnSelected","isSticky","isRowSelectionEnabled","isRowSingleSelection","isActive","isHover","isPseudoHover","isStickyStartEdge","isStickyEndEdge","isRtl","horizontalAlignment","verticalAlignment","variant","padding","cellStyles","tableCellStylesHC","tableCellStyles","classArray","base","isTopPadding","isBottomPadding","isStartPadding","isEndPadding","_getPaddingInfo","_applyAlignmentStyling","_applyStickyStyling","active","hover","pseudoHover","rowHighlight","_applyFocusStyling","hasBackground","selectedBackground","horizontalSelectedGridTop","selectedBorderTopPadding","selectedBorderTopNoPadding","horizontalGridTop","borderTopPadding","borderTopNoPadding","topSpacerPadding","topSpacerNoPadding","lastRow","horizontalSelectedGridBottom","selectedBorderBottomPadding","selectedBorderBottomNoPadding","horizontalGridBottom","borderBottomPadding","borderBottomNoPadding","bottomSpacerPadding","bottomSpacerNoPadding","notLastRow","bottomPadding","bottomNoPadding","_applySelectedColumnStyling","background","_applyColumnStyling","getHeaderFooterCellClassArray","isHeader","isColumnSelectionEnabled","isSelected","isColumnSelectable","previousInteractiveBorderStart","previousInteractiveBorderStartNoPadding","previousPseudoHoverBorderStart","previousPseudoHoverBorderStartNoPadding","tableHeaderCellStylesHC","headerPreviousInteractiveBorderStartHC","headerPreviousPseudoHoverBorderStartHC","headerPreviousInteractiveBorderStartNoPaddingHC","headerPreviousPseudoHoverBorderStartNoPaddingHC","tableHeaderCellStyles","headerPreviousInteractiveBorderStart","headerPreviousPseudoHoverBorderStart","headerPreviousInteractiveBorderStartNoPadding","headerPreviousPseudoHoverBorderStartNoPadding","tableFooterCellStylesHC","footerPreviousInteractiveBorderStartHC","footerPreviousInteractiveBorderStartNoPaddingHC","footerPreviousPseudoHoverBorderStartHC","footerPreviousPseudoHoverBorderStartNoPaddingHC","tableFooterCellStyles","footerPreviousInteractiveBorderStart","footerPreviousInteractiveBorderStartNoPadding","footerPreviousPseudoHoverBorderStart","footerPreviousPseudoHoverBorderStartNoPadding","topPadding","topNoPadding","additionalStyles","startInteractivePaddingStyles","startInteractiveNoPaddingStyles","interactiveStyles","selectedStyle","activeSelected","notSelectedStyle","borderStartStyle","activeBorderStart","borderStartNoPaddingStyle","activeBorderStartNoPadding","borderEndStyle","activeBorderEnd","borderEndNoPaddingStyle","activeBorderEndNoPadding","hoverSelected","hoverBorderStart","hoverBorderStartNoPadding","hoverBorderEnd","hoverBorderEndNoPadding","pseudoHoverSelected","pseudoHoverBorderStart","pseudoHoverBorderStartNoPadding","pseudoHoverBorderEnd","pseudoHoverBorderEndNoPadding","isPaddingDisabled","isComplexPadding","bottom","end","start","top","textAlignStyles","verticalAlignStyles","focused","stickyColumn","stickyEdge","stickyEdgeLeft","stickyEdgeRight","verticalSelectedGridStart","selectedBorderStartPadding","selectedBorderStartNoPadding","verticalGridStart","borderStartPadding","borderStartNoPadding","startSpacerPadding","startSpacerNoPadding","endSpacerPadding","endSpacerNoPadding","endPadding","endNoPadding","verticalSelectedGridEnd","selectedBorderEndPadding","selectedBorderEndNoPadding","getCellType","element","dataset","getRowKey","Number","getRowKeyForRowIndex","rootElement","rowElements","querySelectorAll","length","getRowIndexForRowElement","rowElement","prototype","indexOf","call","getColumnKey","getColumnIndexForHeaderFooterElement","cellElement","columnElements","logicalCellExtractor","columnsArray","cellSelector","onlyAncestors","selectorString","startingElement","parentElement","closest","cellType","rowKey","keyExtractor","columnKey","type","getBoundaryColumnKey","getElementFromCell","headerElements","headerElement","footerElements","footerElement","cellElements","querySelector","getScrollerTopOffset","headerRowElement","getBoundingClientRect","getScrollerBottomOffset","footerRowElement","getFirstFocusableRowKey","firstRowElement","getLastFocusableRowKey","rowCount","isFirst","key","hasNoDataCell","getNoDataCellElement","hasFooterCells","hasTruncatedText","getAttribute","String","innerText","trim","walker","document","createTreeWalker","NodeFilter","SHOW_TEXT","nextNode","range","Range","textNode","currentNode","selectNodeContents","untruncatedTextLength","firstParent","parentStyles","getComputedStyle","visibility","parseFloat","paddingLeft","paddingRight","border","borderLeft","borderRight","handleLeaveTableTooltipGesture","event","hideTooltip","tooltipId","targetElement","relatedTarget","boundingRect","clientX","left","right","clientY","preventBrowserTooltipProps","onPointerEnter","target","classList","add","preventBrowserTooltipStyle","onPointerLeave","remove","_defaultCellRenderer","rowData","field","undefined","TableCell","columnIndex","rowIndex","hasFooters","hasVerticalUnderflow","hasMore","isTabbableMode","isRowHeader","renderer","selectorRenderer","applyActiveStyle","applyHoverStyle","applyPseudoHoverStyle","tooltip","browser","getClientHints","rowContext","data","columnPadding","supportsDefaultTooltip","cellRendererProps","selector","isTabbable","MemoizeTableRow","memo","isFinalRow","rowHeaderColumnKeys","isPreviousSelected","isSingleRowSelectionEnabled","selectedRowKeys","all","keys","Set","activeColumnKey","selectedColumnKeys","disabledInteractionKeys","onSelectionChange","startStickyEdge","endStickyEdge","interactionProps","useInteractionStyle","disabledKeys","rowStyles","tableRowStylesHC","tableRowStyles","lastRowHeight","accessibleRowName","toString","handleRowSelectorChange","detail","value","column","Selector","collection_selectRow","ROW_NAME","onChange","selectedKeys","containsKey","cellProps","sticky","has","alignment","horizontal","vertical","prev","next","columnsArray1","columnsArray2","i","_areColumnsArraysEquivalent","set1","set2","size","every","isSameKey","TableNoData","rootRef","columnsCount","ariaRowIndex","themeClasses","useComponentTheme","TableNoDataRedwoodTheme","defaultRenderer","showFocusRing","contentRenderer","collection_noData","useLayoutEffect","current","tableBodyElement","noDataElement","TableBody","viewportInfo","isValidRender","getAccessibleRowHeaders","tableData","onLoadMore","activeCell","currentRowKey","currentRowVariant","selected","noDataRenderer","getRowContext","useCallback","context","metadata","isShowEmptyLoading","isShowNoData","loadMoreViewportConfig","scroller","viewportConfig","backgroundStyles","inherit","getNoDataProps","jsxs","Fragment","LoadMoreCollection","loadMoreIndicator","tableRowContext","containsActiveCell","rowProps","TableHeaderCell","headerText","stickyTopOffset","isShowSortIcon","sortable","sortDirection","onSortCriterionChange","selectorAllState","deletedKeys","handleSelectorChange","SelectorAll","collection_selectAllRows","handleSortGesture","iconClassArray","tableHeaderSortIconStyles","visible","hidden","iconClasses","headerCellRendererProps","sortControl","EmbeddedIconButton","collection_sortEnabled","collection_sortDisabled","isDisabled","onAction","SortDescendingIcon","SortAscendingIcon","getHeaderCellRenderer","text","tableHeaderCellTextStyles","defaultRendererSpan","isIconFirst","containerClasses","tableHeaderSortContainerStyles","justifyContentStyles","getAriaSort","TableHeader","activeKey","isForceSortIcons","hoverColumnKey","sortCriterion","isResizeHover","tableHeaderRowStyles","criterion","headerCellProps","selectable","headerRenderer","headerPadding","headerTooltip","headerAlignment","_defaultFooterCellRenderer","footerText","TableFooterCell","stickyBottomOffset","footerCellRendererProps","TableFooter","dataRowCount","tableFooterRowStyles","Math","max","footerCellProps","footerRenderer","footerPadding","footerAlignment","TableDragIndicator","position","tableDragIndicatorClasses","tableDragIndicatorStyles","heightString","getDragIndicatorStyle","TableContextMenu","contextMenuConfig","contextMenuContext","menuProps","accessibleLabel","Menu","isOpen","itemsRenderer","_scrollRowIntoView","scrollerElement","scrollbarHeight","location","topOffset","bottomOffset","isExternalScroller","scrollerOffsetTop","scrollerOffsetBottom","verticalOverflowDiff","_getVerticalOverflowDiff","topOverflowDiff","hasTopOverflow","bottomOverflowDiff","hasBottomOverflow","abs","scrollTop","_roundScrollValue","isOver","ceil","floor","_getHorizontalOverflowDiff","startOffset","endOffset","scrollbarWidth","elementRect","scrollerRect","setHorizontalScrollPosition","fullColumnWidths","horizontalScrollPosition","scrollPosition","useColumn","offsetX","getHorizontalScrollPosition","_getScrollLeftFromScrollPosition","scrollLeft","setVerticalScrollPosition","verticalScrollPosition","y","useRow","offsetY","getVerticalScrollPosition","_getScrollTopFromScrollPosition","newScrollLeft","columnEnd","newScrollTop","rowBottom","applyScrollDetail","sizingInfo","scrollDetail","findElementByKey","locationY","isInitialRender","boxHeight","contentHeight","locationX","columnElement","scrollerOffsetStart","scrollerOffsetEnd","stickyColumns","getStickyColumnIndicies","stickyIndex","horizontalOverflowDiff","leftOverflowDiff","hasLeftOverflow","rightOverflowDiff","hasRightOverflow","_scrollColumnIntoView","boxWidth","contentWidth","updateStickyColumns","appliedColumnWidths","stickyEdgesState","setStickyEdgesState","isHorizontalScroll","stickyStartOffset","stickyEndOffset","stickyIndicies","_applyStickyColumnOffset","updateStickyEdges","stickyOffset","isStart","styleProperty","styleValue","j","currentScrollIndex","newScrollPosition","startIndex","currentIndex","endIndex","currentWidth","endOverflow","scrollWidth","clientWidth","resetVerticalScrollPosition","applyOverflowStatus","availableWidth","availableHeight","overflowRef","setHasVerticalUnderflow","hasHorizontalOverflow","hasVerticalOverflow","scrollerStyles","noHorizontalScroll","horizontalScroll","noVerticalScroll","verticalScroll","paddingInlineEnd","isHorizontal","isVertical","applyUnderflowStatus","spacerRowElement","offsetHeight","cellComparator","cell1","cell2","_getCellFromCellOverride","cellOverride","currentCell","cellRowKey","cellColumnKey","_renderIncludesCell","isColumnValid","menuPropGestureStates","mouse","initialFocus","placement","offsetValue","keyboard","touch","_initialMenuProps","anchorRef","SMALL_INTERACTION_DELAY","TABLE_HIDE_TOOLTIP_DELAY","min","SHOW_TOOLTIP_DELAY","HIDE_TOOLTIP_DELAY","MOUSE_FOCUS_SHIFT_TIMEOUT","TOUCH_FOCUS_SHIFT_TIMEOUT","NAVIGATION_KEYS","SCROLL_KEYS","useFocusHandling","sizingInfoRef","selectionExtensionElementRef","cellSupportsTabbable","currentCellOverride","onPersistCurrentCell","showTooltip","isEmbeddedSelect","isDataLoaded","blurFromWindowRef","useRef","isRenderCycle","blurredRenderCycleElementRef","isPendingLayoutFocusRef","hasFocusRef","setIsTabbableMode","useState","setIsShowFocusRing","recentPointerRef","pointerTimerRef","isShowFocusRingOverrideRef","setActiveCell","currencyStatusRef","hasPendingCurrentCellOverride","hasPendingCurrentCellOverrideScroll","currentActiveCell","firstColumnKey","defaultFirstCell","previousEmbeddedSelectCurrentCell","realizedCell","overrideCellType","_getCellTypeFromCellOverride","initialData","loadMoreInitialData","determineActiveCell","onActiveCellChanged","useMemo","isSelectionExtension","newActiveCell","isTransientCell","newCurrentCell","_setAsInactive","_enableNavigationMode","skipScrollCellIntoView","focusRingState","handleNavigationTooltipGesture","_enableTabbableMode","isKeyboard","_disableTabbableMode","preventScroll","notifyFocusFromPointer","isTouch","clearTimeout","setTimeout","_pointerDownHandler","pointerType","_pointerUpHandler","_onBlurHandler","activeElement","isUnknownRelatedTarget","getElementContainsFunc","_onKeyDownHandler","isNavigationKey","onStartFocusTracking","handleEnterActionableMode","hasFocusWithin","allTabbableElements","onFocusStartEdge","handleWrapActionableFocus","tabbableElements","onFocusEndEdge","useEffect","applyCurrentCellOverride","blurredRenderCycleElement","getActiveElement","getBodyElement","isTabbableElement","focusHandlingProps","onPointerDown","onPointerUp","onFocus","onBlur","onKeyDown","handleRowActionGesture","onRowAction","targetCell","rowActionContext","targetCellElement","_getRowActionGestureContext","handleAdjacentRowGesture","initialCell","isPrevious","isExtendSelectionGesture","newCell","newColumnKey","currentRowElement","adjacentRowElement","previousElementSibling","nextElementSibling","handlePageRowGesture","verticalRowIndex","getRowIndexForRowKey","targetRowIndex","scrollerBottom","newRowKey","handleAdjacentColumnGesture","newKey","initialKey","_getAdjacentColumnKey","handleJumpColumnGesture","includeRows","handleSelectionGesture","isMultiSelectGesture","isDropDownSelection","selectionMode","emptyKeys","selectedRows","selectedColumns","isMultiSelectRowGesture","removeKey","addKey","_applyRangeSelection","isRowGesture","previousEndIndex","handleExtendSelectionGesture","activeCellElement","startElement","isRow","extendedElement","cursorElement","extensionElement","extensionCell","_updateResizingState","resizeInfoRef","cellRect","endEdge","pageX","edgeResizable","cursor","handleColumnResizeEndGesture","onColumnResize","isResizing","rect","currentX","delta","startX","allColumnWidths","ignoreClick","usePointerHandling","onColumnResizing","onTableSelectionChange","selectionTouchRef","setHoverColumnKey","pointerInfoRef","_pointerMoveHandler","tooltipShown","handleMoveTooltipGesture","handleColumnResizingGesture","handleOverResizeRegionGesture","_pointerOverHandler","handleOverColumnHeaderGesture","shiftKey","isRangeSelectionGesture","getIsSelectionPending","preventDefault","pointerX","resizeColumnWidths","handleColumnResizeStartGesture","_pointerLeaveHandler","handleLeaveColumnHeaderGesture","handleLeaveResizingGesture","_pointerEnterHandler","buttons","handleEnterResizingGesture","_clickHandler","platform","endElement","previousElement","handleRangeSelectionGesture","metaKey","ctrlKey","stopPropagation","pointerHandlingProps","onPointerOver","onPointerMove","onClick","useScrollHandling","layoutInfo","horizontalScrollPositionOverride","verticalScrollPositionOverride","tooltipAnchorRef","horizontalScrollPositionOverrideRef","verticalScrollPositionOverrideRef","isLayoutRequired","_scrollHandler","offsetWidth","hideOutOfViewTooltip","scrollerEventElement","body","documentElement","window","addEventListener","removeEventListener","onScroll","_defaultDisabledRowInteractionKeys","useInteractionManager","ref","cellHasRenderer","tooltipContent","globalTooltipManager","getGlobalTooltipManager","useId","tooltipCellRef","pendingShowTooltipCellRef","tooltipTextRef","tooltipText","setTooltipText","pointerDownRef","pointerDownTimeoutRef","showTooltipTimeoutRef","hideTooltipTimeoutRef","_clearHideTooltipTimeout","_clearShowTooltipTimeout","_setupShowTooltipTimeout","_setupHideTooltipTimeout","anchorCell","isImmediate","_event","isOpenOverrideRef","tooltipPointerProps","renderRawContent","TooltipContent","id","isDatatip","scale","useScale","mainAxisOffset","crossAxisOffset","currentColorScheme","useColorScheme","getWrappedTooltipContent","mainAxis","crossAxis","destroyCallback","register","unregister","useTruncationTooltip","useCollectionInteractionContext","disabledRowInteractionKeys","isExtendableSelection","keyboardHandlingProps","_keyDownHandler","keyHandlers","repeat","Enter","_isSortActionGesture","handleSortActionGesture","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","PageUp","PageDown","Home","End","includes","useKeyboardHandling","scrollHandlingProps","contextMenuTriggerProps","setContextMenuContext","setMenuProps","currentCellElementRef","triggerProps","useContextMenuGesture","gesture","anchor","cellContext","getCellContextFromCell","anchorBasedOnGesture","handleCloseContextMenu","reason","onClose","useContextMenu","interactionManagerProps","mergeProps","useImperativeHandle","applyLayoutColumnWidths","innerTableElement","widthOffset","isFixed","sampledColumnWidthsRef","staticColumnWidths","newColumnWidths","totalWidth","widthsArray","tableCols","DEFAULT_COLUMN_WEIGHT","DEFAULT_COLUMN_MIN_WIDTH","DEFAULT_COLUMN_MAX_WIDTH","requiresActiveSizing","totalWorkingWeight","forcedTotalWidth","pendingTotalWidth","columnMaxWidthsArray","columnWeightsArray","forcedColumnWidthsArray","newColumnWidthsArray","appliedColumnWidthsArray","columnMinWidth","minWidth","columnMaxWidth","maxWidth","columnWeight","weight","isMaxRuleApplied","_enforceWeightedMinRules","_enforceFixedMinMaxRules","_createColumnWidths","_getFixedLayoutColumnWidths","_updateTableSizing","_getContentsLayoutColumnWidths","columnMinWidthsArray","totalPreferredWidth","totalRemainingWeight","sampledWidths","sampledMinWidthsArray","sampledWeightWidthsArray","minWidths","weightWidths","sampledWeightWidth","sampledMinWidth","forcedWidth","appliedPendingTotalWidth","_enforceConstrainedWeightRules","_enforceContentsMinMaxRules","initialExtraWidth","currentWeightTotal","currentWeight","weightWidth","totalWeight","pendingForcedColumnWidths","isMinRuleApplied","widthDiff","newWidth","columnWidths","tableLayout","useSizingManager","scrollerRef","innerTableRef","layout","columns","columnOrder","_isScrollbarSizeKnown","setIsScrollbarSizeKnown","setAppliedColumnWidths","innerTableHeight","setInnerTableHeight","isScrollbarSizeKnown","pendingResizeEntriesRef","tableViewportConfig","config","getViewportConfig","newColumnsArray","entries","appliedWidth","staticWidth","defaultScrollbarWidth","_updateStickyEdgesFromResize","handleResizeCallback","currentEntry","isOveralSizeHandled","newContentWidth","contentBoxSize","inlineSize","newContentHeight","blockSize","newBoxWidth","borderBoxSize","newBoxHeight","availableWidthOffset","defaultScrollbarHeight","columnWidths1","columnWidths2","keys1","keys2","columnWidthsComparator","innerTableRect","innerTable","handleResizeCallbackRef","staticHandleScrollerResize","entry","requestAnimationFrame","staticHandleInnerTableResize","useResizeObserver","_defaultSelected","_disabledHeaderFooterInteractionKeys","Table","forwardRef","ariaLabel","ariaLabelledBy","gridlines","columnResizingIndicator","testId","testIdProps","useTestId","direction","forcedColors","useUser","onTableLoadMore","d","loadMoreDataRef","useDataManager","hasRenderer","some","ariaRowCount","ariaColumnCount","TableRedwoodTheme","pendingLayout","externalScroller","scrollerStyle","scrollerPadding","scrollerClassArray","forceScroll","scrollerClasses","tableClasses","innerTableStyles","_Fragment","FocusTracker","onStartTracking","TabbableModeContext","Provider","getTableStyle","getTableColGroupProps","getTableDragIndicator"],"mappings":"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9kB,GAAgC,MAAd0F,EAAoB,CACzC,IAAI+U,GAA2B,EAET,SAApB/U,EAAWzK,MACXmD,EAAM0gB,UACoB,MAA1BX,GACuB,aAAvBpC,GAAeltB,MAEf4tB,GACEjjB,EACAyS,EACA5G,EACAxZ,EACAyO,EACAwa,EACAtb,GACA,EACAkM,EACAqP,EACAoJ,EACArC,EACA/qB,EACA6c,EACAmO,EACAlW,GAEF4U,GAA2B,GAExBA,IAA4BqB,GAC/BxB,GACE9gB,EACAyS,EACA5G,EACAxZ,EACAyO,EACAwa,EACApP,EACAsR,GACA,EACAyD,EACA1pB,EACAsN,EACAuP,GAGJxP,EAAM6gB,gBACP,CACF,EACD8F,UAAW,WACT,IAAK/kB,GAAgC,MAAd0F,EAAoB,CACzC,IAAI+U,GAA2B,EAET,SAApB/U,EAAWzK,MACXmD,EAAM0gB,UACoB,MAA1BX,GACuB,aAAvBpC,GAAeltB,MAEf4tB,GACEjjB,EACAyS,EACA5G,EACAxZ,EACAyO,EACAwa,EACAtb,GACA,EACAkM,EACAqP,EACAoJ,EACArC,EACA/qB,EACA6c,EACAmO,EACAlW,GAEF4U,GAA2B,GAExBA,IAA4BqB,GAC/BxB,GACE9gB,EACAyS,EACA5G,EACAxZ,EACAyO,EACAwa,EACApP,EACAsR,GACA,EACAyD,EACA1pB,EACAsN,EACAuP,GAGJxP,EAAM6gB,gBACP,CACF,EACD+F,UAAW,WACJhlB,GAAgC,MAAd0F,IAEE,WAApBA,EAAWzK,MAAyC,WAApByK,EAAWzK,OAC5CmD,EAAM0gB,UACoB,MAA1BX,GAC0B,aAA1BpC,GAAelZ,OAqBfyY,GACE9hB,EACAyS,EACA5G,EACAxZ,EACAyO,EACAwa,EACApP,EACAsR,GACCjmB,EACDA,EACAsN,EACAuP,GA/BF6O,GACEjjB,EACAyS,EACA5G,EACAxZ,EACAyO,EACAwa,EACAtb,GACA,EACAkM,EACAqP,EACAoJ,EACArC,EACA/qB,EACA6c,EACAmO,EACAlW,GAkBJzH,EAAM6gB,iBAET,EACDgG,WAAY,WACLjlB,GAAgC,MAAd0F,IAEE,WAApBA,EAAWzK,MAAyC,WAApByK,EAAWzK,OAC5CmD,EAAM0gB,UACoB,MAA1BX,GAC0B,aAA1BpC,GAAelZ,OAqBfyY,GACE9hB,EACAyS,EACA5G,EACAxZ,EACAyO,EACAwa,EACApP,EACAsR,EACAjmB,EACAA,EACAsN,EACAuP,GA/BF6O,GACEjjB,EACAyS,EACA5G,EACAxZ,EACAyO,EACAwa,EACAtb,GACA,EACAkM,EACAqP,EACAoJ,EACArC,EACA/qB,EACA6c,EACAmO,EACAlW,GAkBJzH,EAAM6gB,iBAET,EACDiG,OAAQ,WACDllB,GAAgC,MAAd0F,IACrBsV,GACExhB,EACAyS,EACA5G,EACAxZ,EACAyO,EACAwa,EACApP,EACAsR,GACA,EACAjmB,EACAsN,EACAuP,GAEFxP,EAAM6gB,iBAET,EACDkG,SAAU,WACHnlB,GAAgC,MAAd0F,IACrBsV,GACExhB,EACAyS,EACA5G,EACAxZ,EACAyO,EACAwa,EACApP,EACAsR,GACA,EACAjmB,EACAsN,EACAuP,GAEFxP,EAAM6gB,iBAET,EACDmG,KAAM,WACCplB,GAAgC,MAAd0F,IACrBgW,GACEliB,EACAyS,EACA5G,EACAxZ,EACAyO,EACAwa,EACApP,EACAsR,GACA,EACa,QAAb4I,EAAqBxhB,EAAM4hB,QAAU5hB,EAAM6hB,QAC3ClvB,EACAsN,EACAuP,GAEFxP,EAAM6gB,iBAET,EACDoG,IAAK,WACErlB,GAAgC,MAAd0F,IACrBgW,GACEliB,EACAyS,EACA5G,EACAxZ,EACAyO,EACAwa,EACApP,EACAsR,GACA,EACa,QAAb4I,EAAqBxhB,EAAM4hB,QAAU5hB,EAAM6hB,QAC3ClvB,EACAsN,EACAuP,GAEFxP,EAAM6gB,iBAET,GAECpyB,OAAO4U,KAAKgjB,GAAaa,SAASlnB,EAAMhC,MAC1CqoB,EAAYrmB,EAAMhC,MAErB,IAEH,CACEkI,EACAe,EACAxZ,EACA2Z,EACAzU,EACAiP,EACA1F,EACAwa,EACAC,EACAnH,EACAlI,EACAsR,EACA8E,EACAC,EACAlW,EACAsY,EACAlE,EACAvQ,EACAlC,EACAnJ,I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"}