{"version":3,"file":"ConveyorBeltItem-2fc9f829.js","sources":["../../src/UNSAFE_ConveyorBelt/ConveyorBelt.tsx","../../src/UNSAFE_ConveyorBelt/ConveyorBeltItem.tsx"],"sourcesContent":["import { ComponentChildren } from 'preact';\nimport { useEffect, useRef, useState, useCallback, useMemo, useLayoutEffect } from 'preact/hooks';\nimport { BaseButton } from '../UNSAFE_BaseButton';\nimport { ButtonLayout } from '../UNSAFE_ButtonLayout';\nimport { ChevronLeft } from '../UNSAFE_RedwoodIcons/ChevronLeft';\nimport { ChevronRight } from '../UNSAFE_RedwoodIcons/ChevronRight';\nimport { classNames as clsx } from '../utils/UNSAFE_classNames';\nimport { styles } from './themes/ConveyorBeltStyles.css';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { ConveyorBeltContext } from './ConveyorBeltContext';\nimport { TestIdProps, useTestId } from '../hooks/UNSAFE_useTestId';\n\nexport type ConveyorBeltProps = TestIdProps & {\n  /**\n   * ConveyorBelt Component content\n   */\n  children?: ComponentChildren;\n  /**\n   * Sets the number of pixels that an element's content is scrolled from its initial position.\n   */\n  scrollPosition?: number;\n  /**\n   * Callback that is executed every time conveyor belt is scrolled and the scroll position is changed.\n   * @param value The value is the new scroll position of the conveyor belt.\n   * @returns\n   */\n  onScrollPositionChanged?: (value?: number) => void;\n  /**\n   * Indicates whether overflow content arrows are visible or hidden.\n   * \"auto\" show overflow arrows on desktop, hide on mobile.\n   * \"visible\" always show overflow arrows.\n   * \"hidden\" never show overflow arrows.\n   */\n  arrowVisibility?: 'auto' | 'visible' | 'hidden';\n};\n\n/**\n * Helper function to determine whether the current device is a mobile device\n * @returns true if runnning on a mobile device, false otherwise\n */\nfunction isMobile() {\n  const deviceType = getClientHints().deviceType;\n  return deviceType === 'phone' || deviceType === 'tablet';\n}\n\ntype ConveyorItemElement = {\n  item: HTMLElement;\n  isVisible: boolean;\n  isCurrent: boolean;\n  index: number;\n};\n\n// utility hook that calculates which conveyorbelt items are visible inside conveyorbelt viewport\n// and which are hidden\nconst useConveyorElementsVisible = (\n  root: HTMLDivElement,\n  prevBtn?: HTMLDivElement,\n  nextBtn?: HTMLDivElement,\n  direction?: 'ltr' | 'rtl'\n) => {\n  const observerRef = useRef<IntersectionObserver>();\n  const targets = useRef<ConveyorItemElement[]>([]);\n\n  useEffect(() => {\n    if (targets.current && targets.current.length > 0 && root) {\n      // IntersectionObserver calls visibility change only when item is\n      // fully visible inside (threshold: 1)\n      // conveyorbelt viewport (root),\n      // taking arrow buttons into the account\n      // and viewport should be smaller by the buttons width (rootMargin)\n      const rootMargin =\n        direction === 'ltr'\n          ? `0px ${nextBtn ? -nextBtn.offsetWidth : 0}px 0px ${\n              prevBtn ? -prevBtn.offsetWidth : 0\n            }px`\n          : `0px ${prevBtn ? -prevBtn.offsetWidth : 0}px 0px ${\n              nextBtn ? -nextBtn.offsetWidth : 0\n            }px`;\n\n      observerRef.current = new IntersectionObserver(onVisibilityChange, {\n        root,\n        rootMargin: rootMargin,\n        threshold: 1\n      });\n      for (const target of targets.current) {\n        if (target != null) observerRef.current.observe(target.item);\n      }\n    }\n    return () => {\n      for (const target of targets.current) {\n        if (observerRef.current && target != null) observerRef.current.unobserve(target.item);\n      }\n    };\n  }, [targets, root, nextBtn, prevBtn, direction]);\n\n  // handle visibility changes\n  const onVisibilityChange = (entries: IntersectionObserverEntry[]) => {\n    const newItems: ConveyorItemElement[] = targets.current.map((conveyorItem, index) => {\n      const foundEntry = entries.find((entry) => entry.target === conveyorItem.item);\n      // if visibility changed for the item, change isVisible property,\n      // otherwise just return the original\n      if (foundEntry) {\n        return {\n          item: foundEntry.target as HTMLDivElement,\n          isVisible: foundEntry.isIntersecting,\n          isCurrent: conveyorItem.isCurrent,\n          index: index\n        };\n      } else {\n        return conveyorItem;\n      }\n    });\n    targets.current = newItems;\n  };\n\n  return useMemo(\n    () => ({\n      itemElementsRef: targets\n    }),\n    [targets]\n  );\n};\n\n/**\n * The Conveyor belt component is a container element that manages\n * overflow for its child elements and allows scrolling among them\n */\nexport const ConveyorBelt = ({\n  children,\n  scrollPosition,\n  onScrollPositionChanged,\n  arrowVisibility = 'auto',\n  testId\n}: ConveyorBeltProps) => {\n  const [canPaginateNext, setCanPaginateNext] = useState(false);\n  const [canPaginatePrevious, setCanPaginatePrevious] = useState(false);\n  const overflowContainerRef = useRef<HTMLDivElement | null>(null);\n  const contentContainerRef = useRef<HTMLDivElement | null>(null);\n  const nextButtonContainerRef = useRef<HTMLDivElement | null>(null);\n  const prevButtonContainerRef = useRef<HTMLDivElement | null>(null);\n  const baseRef = useRef<HTMLDivElement | null>(null);\n  const leftRef = useRef<HTMLDivElement | null>(null);\n  const rightRef = useRef<HTMLDivElement | null>(null);\n  const observerRef = useRef<any>(null);\n  const currentItemRef = useRef<HTMLElement | null>(null);\n  const [currentItem, _setCurrentItem] = useState<HTMLElement | null>(null);\n  const isMountedRef = useRef(false);\n  const [buttonsHidden, setButtonsHidden] = useState(\n    (isMobile() && arrowVisibility === 'auto') || arrowVisibility === 'hidden'\n  );\n  const { direction } = useUser();\n\n  const { itemElementsRef } = useConveyorElementsVisible(\n    overflowContainerRef.current!,\n    prevButtonContainerRef.current!,\n    nextButtonContainerRef.current!,\n    direction\n  );\n\n  const testIdProps = useTestId(testId);\n  const leftArrowTestIdProps = 'leftArrow' + testId;\n  const rightArrowTestIdProps = 'rightArrow' + testId;\n\n  useLayoutEffect(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  // utility method to get all conveyorbelt items\n  const _getConveyorItems = () => {\n    return contentContainerRef.current\n      ? Array.from(contentContainerRef.current.querySelectorAll('[data-oj-conveyorbelt-item]'))\n      : [];\n  };\n\n  useEffect(() => {\n    if (isMountedRef.current == true && itemElementsRef.current.length == 0) {\n      const conveyorContentChildren = _getConveyorItems();\n      if (conveyorContentChildren) {\n        let index = -1;\n        for (const child of conveyorContentChildren) {\n          index++;\n          const element = child as HTMLElement;\n          if (element) {\n            const item = itemElementsRef.current.find((item) => item.item === element);\n            if (item == null) {\n              itemElementsRef.current.push({\n                item: element!,\n                isVisible: false,\n                index: index,\n                isCurrent: false\n              });\n            }\n          }\n        }\n      }\n    }\n\n  }, [isMountedRef, itemElementsRef]);\n\n  const scrollEndHandler = useCallback(() => {\n    if (onScrollPositionChanged) onScrollPositionChanged(overflowContainerRef.current?.scrollLeft);\n  }, [onScrollPositionChanged]);\n\n  useEffect(() => {\n    setButtonsHidden((isMobile() && arrowVisibility === 'auto') || arrowVisibility === 'hidden');\n  }, [arrowVisibility]);\n\n  useEffect(() => {\n    if (!overflowContainerRef.current) return;\n    overflowContainerRef.current.scrollTo({\n      left: scrollPosition\n    });\n  }, [scrollPosition]);\n\n  // useEffect hook that calculates when arrow buttons should become visible or hidden\n  // using IntersectionObserver\n  useEffect(() => {\n    const overflowContainer = overflowContainerRef.current;\n    const leftGuard = leftRef.current;\n    const rightGuard = rightRef.current;\n\n    if (overflowContainer && leftGuard && rightGuard) {\n      if (!buttonsHidden) {\n        observerRef.current = new IntersectionObserver(\n          (entries) => {\n            entries.forEach((entry) => {\n              if (entry.target.getAttribute('data-intersection-id') === 'left') {\n                setCanPaginatePrevious(!entry.isIntersecting);\n              } else {\n                setCanPaginateNext(!entry.isIntersecting);\n              }\n            });\n          },\n          {\n            root: overflowContainer\n          }\n        );\n        observerRef.current.observe(leftGuard);\n        observerRef.current.observe(rightGuard);\n      }\n      overflowContainer.addEventListener('scrollend', scrollEndHandler);\n    }\n\n    // Clean-up\n    return () => {\n      if (!overflowContainer) return;\n      overflowContainer.removeEventListener('scrollend', scrollEndHandler);\n      observerRef.current?.unobserve(leftGuard);\n      observerRef.current?.unobserve(rightGuard);\n    };\n  }, [buttonsHidden, scrollEndHandler]);\n\n\n  const scrollIntoView = useCallback(\n    (element: HTMLElement) => {\n       // utility method to check if the element is closer to the end edge of the conveyorbelt\n      const _shouldSnapToTheEndEdge = (\n        ltr: boolean,\n        elem?: HTMLElement | null,\n        scroller?: HTMLDivElement | null\n      ) => {\n        if (!elem || !scroller) return false;\n        let right;\n        let left;\n\n        if (scroller === document.documentElement) {\n          left = 0;\n          right = document.documentElement.clientWidth;\n        } else {\n          const scrollerBounds = scroller.getBoundingClientRect();\n          right = canPaginateNext\n            ? scrollerBounds.right - nextButtonContainerRef.current?.offsetWidth!\n            : scrollerBounds.right;\n          left = canPaginateNext\n            ? scrollerBounds.left - nextButtonContainerRef.current?.offsetWidth!\n            : scrollerBounds.left;\n        }\n        const bounds = elem.getBoundingClientRect();\n        if (ltr) {\n          return bounds.right > right;\n        } else {\n          return bounds.left < left;\n        }\n      };\n\n      // utility method to check that an element is fully visible inside conveyorbelt\n      const _isElementInsideHorizontalScrollerBounds = (\n        elem?: HTMLElement | null,\n        scroller?: HTMLDivElement | null\n      ) => {\n        if (!elem || !scroller) return false;\n        let left;\n        let right;\n        if (scroller === document.documentElement) {\n          left = 0;\n          right = document.documentElement.clientWidth;\n        } else {\n          const scrollerBounds = scroller.getBoundingClientRect();\n          left = canPaginatePrevious\n            ? scrollerBounds.left + prevButtonContainerRef.current?.offsetWidth!\n            : scrollerBounds.left;\n          right = canPaginateNext\n            ? scrollerBounds.right - nextButtonContainerRef.current?.offsetWidth!\n            : scrollerBounds.right;\n        }\n        const bounds = elem.getBoundingClientRect();\n        return (\n          bounds.left <= right && bounds.right <= right && bounds.left >= left && bounds.right >= left\n        );\n      };\n\n      const isElementVisible = _isElementInsideHorizontalScrollerBounds(\n        element,\n        overflowContainerRef.current\n      );\n      if (isElementVisible) {\n        return;\n      }\n      if (!overflowContainerRef.current || !contentContainerRef.current) return;\n\n      if (direction === 'ltr') {\n        const shouldSnapEnd = _shouldSnapToTheEndEdge(\n          direction === 'ltr',\n          element,\n          overflowContainerRef.current\n        );\n        if (shouldSnapEnd) {\n          overflowContainerRef.current.scrollTo({\n            left:\n              element.offsetLeft +\n              element.offsetWidth -\n              overflowContainerRef.current.offsetWidth +\n              (nextButtonContainerRef.current?.offsetWidth\n                ? nextButtonContainerRef.current?.offsetWidth + 1\n                : 0),\n            behavior: 'smooth'\n          });\n        } else {\n          overflowContainerRef.current.scrollTo({\n            left:\n              element.offsetLeft -\n              (prevButtonContainerRef.current?.offsetWidth\n                ? prevButtonContainerRef.current?.offsetWidth + 1\n                : 0),\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        const shouldSnapEnd = _shouldSnapToTheEndEdge(false, element, overflowContainerRef.current);\n        if (shouldSnapEnd) {\n          overflowContainerRef.current.scrollTo({\n            left:\n              element.offsetLeft -\n              contentContainerRef.current?.offsetWidth! +\n              overflowContainerRef.current.offsetWidth -\n              (nextButtonContainerRef.current?.offsetWidth\n                ? nextButtonContainerRef.current?.offsetWidth + 1\n                : 0),\n            behavior: 'smooth'\n          });\n        } else {\n          overflowContainerRef.current.scrollTo({\n            left:\n              element.offsetLeft +\n              element.offsetWidth -\n              contentContainerRef.current?.offsetWidth! +\n              (prevButtonContainerRef.current?.offsetWidth\n                ? prevButtonContainerRef.current?.offsetWidth + 1\n                : 0),\n            behavior: 'smooth'\n          });\n        }\n      }\n    },\n    [canPaginateNext, canPaginatePrevious, direction]\n  );\n\n  // paginates to the previous partially visible or hidden item in the conveyorbelt,\n  // so that it is the last visible of the conveyorbelt view port\n  function scrollPrevious(\n    direction: 'ltr' | 'rtl',\n    overflowContainer?: HTMLDivElement | null,\n    scrollAmount?: number\n  ) {\n    if (overflowContainer && scrollAmount) {\n      const previousInvisible: HTMLElement | undefined = getPreviousInvisible();\n      if (direction === 'ltr') {\n        if (!previousInvisible) {\n          overflowContainer.scrollTo({\n            left: overflowContainer.scrollLeft - scrollAmount,\n            behavior: 'smooth'\n          });\n        } else {\n          overflowContainer.scrollTo({\n            left:\n              previousInvisible.offsetLeft +\n              previousInvisible.offsetWidth -\n              overflowContainer.offsetWidth +\n              (prevButtonContainerRef.current?.offsetWidth\n                ? prevButtonContainerRef.current?.offsetWidth + 1\n                : 0),\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        if (!previousInvisible) {\n          overflowContainer.scrollTo({\n            left: overflowContainer.scrollLeft + scrollAmount,\n            behavior: 'smooth'\n          });\n        } else {\n          overflowContainer.scrollTo({\n            left:\n              previousInvisible.offsetLeft -\n              contentContainerRef.current?.offsetWidth! +\n              overflowContainer.offsetWidth -\n              (prevButtonContainerRef.current?.offsetWidth\n                ? prevButtonContainerRef.current?.offsetWidth + 1\n                : 0),\n            behavior: 'smooth'\n          });\n        }\n      }\n    }\n  }\n\n  // paginates to the next partially visible or hidden item in the conveyorbelt,\n  // so that it is the first at the start of the conveyorbelt view port\n  function scrollNext(\n    direction: 'ltr' | 'rtl',\n    overflowContainer?: HTMLDivElement | null,\n    scrollAmount?: number\n  ) {\n    if (overflowContainer && scrollAmount) {\n      const nextInvisible: HTMLElement | undefined = getNextInvisible();\n      if (direction === 'ltr') {\n        if (!nextInvisible) {\n          overflowContainer.scrollTo({\n            left: overflowContainer.scrollLeft + scrollAmount,\n            behavior: 'smooth'\n          });\n        } else {\n          overflowContainer.scrollTo({\n            left:\n              (nextInvisible?.offsetLeft ?? 0) -\n              (nextButtonContainerRef.current?.offsetWidth\n                ? nextButtonContainerRef.current?.offsetWidth + 1\n                : 0),\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        if (!nextInvisible) {\n          overflowContainer.scrollTo({\n            left: overflowContainer.scrollLeft - scrollAmount,\n            behavior: 'smooth'\n          });\n        } else {\n          overflowContainer.scrollTo({\n            left:\n              -(contentContainerRef.current?.offsetWidth! - (nextInvisible?.offsetLeft ?? 0)) +\n              (nextInvisible?.offsetWidth ?? 0) +\n              (nextButtonContainerRef.current?.offsetWidth\n                ? nextButtonContainerRef.current?.offsetWidth + 1\n                : 0),\n            behavior: 'smooth'\n          });\n        }\n      }\n    }\n  }\n\n  const getNextInvisible = () => {\n    const nextInvisible = itemElementsRef.current.find((item) => {\n      if (\n        item.isVisible == false &&\n        item.index >= 1 &&\n        itemElementsRef.current[item.index - 1].isVisible == true\n      ) {\n        return true;\n      }\n      return false;\n    });\n    return nextInvisible?.item;\n  };\n\n  const getPreviousInvisible = () => {\n    const previousInvisible = itemElementsRef.current.find((item) => {\n      if (\n        item.isVisible == false &&\n        item.index < itemElementsRef.current.length - 1 &&\n        itemElementsRef.current[item.index + 1].isVisible == true\n      ) {\n        return true;\n      }\n      return false;\n    });\n    return previousInvisible?.item;\n  };\n\n  const setCurrentItem = useCallback((node: HTMLElement | null) => {\n    if (currentItemRef.current !== node) {\n      // this logic below is needed to make sure only one item is current\n      const item = itemElementsRef.current.find((item) => item.item === node);\n      const currentItem = itemElementsRef.current.find((item) => item.isCurrent === true);\n      if (item === currentItem || !item) return;\n      if (currentItem) currentItem.isCurrent = false;\n      item!.isCurrent = true;\n\n      currentItemRef.current = node;\n      _setCurrentItem(node);\n    }\n  }, [itemElementsRef]);\n\n  useEffect(() => {\n    if (currentItem && currentItemRef.current) {\n      scrollIntoView(currentItemRef.current);\n    }\n  }, [currentItem]);// eslint warning about scrollIntoView should be ignored.\n\n  //the clipPathStyle const replaces the following inline style applied with conditions\n  /* style= {\n          ...!buttonsHidden\n          ? { clipPath:\n            direction === 'ltr'\n              ? `inset(0rem ${canPaginateNext ? xUnits(11) : '0rem'} 0rem ${\n                  canPaginatePrevious ? xUnits(11) : 0\n                })`\n              : `inset(0rem ${canPaginatePrevious ? xUnits(11) : '0rem'} 0rem ${\n                  canPaginateNext ? xUnits(11) : 0\n                })`\n            }\n          : { }\n        }} */\n  const clipPathStyle = !buttonsHidden\n    ? direction === 'ltr'\n      ? canPaginateNext && canPaginatePrevious\n        ? styles.bothButtonClipPath\n        : canPaginatePrevious\n        ? styles.previousButtonClipPath\n        : canPaginateNext\n        ? styles.nextButtonClipPath\n        : false\n      : canPaginateNext && canPaginatePrevious\n      ? styles.bothButtonClipPath\n      : canPaginateNext\n      ? styles.previousButtonClipPath\n      : canPaginatePrevious\n      ? styles.nextButtonClipPath\n      : false\n    : false;\n\n  return (\n    <ConveyorBeltContext.Provider value={{ setCurrentItem }}>\n      <div ref={baseRef} className={clsx([styles.baseStyle])} {...testIdProps}>\n        {canPaginatePrevious && !buttonsHidden && (\n          <div\n            ref={prevButtonContainerRef}\n            class={clsx([\n              styles.buttonContainer,\n              direction === 'ltr' ? styles.previousButton : styles.nextButton\n            ])}>\n            <BaseButton\n              elementDetails={{ type: 'span', isFocusable: false }}\n              styling={['min']}\n              variant={'borderless'}\n              onAction={() =>\n                scrollPrevious(\n                  direction,\n                  overflowContainerRef.current,\n                  overflowContainerRef.current?.clientWidth\n                )\n              }\n              aria-hidden={true}\n              testId={leftArrowTestIdProps}>\n              <ButtonLayout\n                display={'icons'}\n                startIcon={direction === 'ltr' ? <ChevronLeft /> : <ChevronRight />}></ButtonLayout>\n            </BaseButton>\n          </div>\n        )}\n        <div className={clsx([styles.overflowContainer, clipPathStyle])} ref={overflowContainerRef}>\n          <div className={styles.contentContainer} ref={contentContainerRef}>\n            <div data-intersection-id=\"left\" ref={leftRef} style={{ minWidth: 1 }} />\n            {children}\n            <div data-intersection-id=\"right\" ref={rightRef} style={{ minWidth: 1 }} />\n          </div>\n        </div>\n        {canPaginateNext && !buttonsHidden && (\n          <div\n            ref={nextButtonContainerRef}\n            class={clsx([\n              styles.buttonContainer,\n              direction === 'ltr' ? styles.nextButton : styles.previousButton\n            ])}>\n            <BaseButton\n              elementDetails={{ type: 'span', isFocusable: false }}\n              styling={['min']}\n              variant={'borderless'}\n              onAction={() =>\n                scrollNext(\n                  direction,\n                  overflowContainerRef.current,\n                  overflowContainerRef.current?.clientWidth\n                )\n              }\n              aria-hidden={true}\n              testId={rightArrowTestIdProps}>\n              <ButtonLayout\n                display={'icons'}\n                startIcon={direction === 'ltr' ? <ChevronRight /> : <ChevronLeft />}></ButtonLayout>\n            </BaseButton>\n          </div>\n        )}\n      </div>\n    </ConveyorBeltContext.Provider>\n  );\n};\n","import { ComponentChildren } from 'preact';\nimport { useConveyorBeltItem } from './useConveyorBeltItem';\n\ntype ConveyorBeltItemProps = {\n  /**\n   * The ConveyorBeltItem content\n   */\n  children?: ComponentChildren,\n  /**\n   * Specifies the current item which should be scrolled into view\n   */\n  isCurrent?: boolean\n}\n/**\n * A wrapper component for one conveyor belt item/child element.\n * It takes care of correctly mark the child components as conveyor belt items.\n * @param param0 ConveyorBeltItemProps\n * @returns\n */\nexport const ConveyorBeltItem = ({\n  children,\n  isCurrent\n}: ConveyorBeltItemProps) => {\n\n  const props = useConveyorBeltItem({\n     isCurrent: isCurrent  });\n  return (\n    <div {...props}>\n      {children}\n    </div>);\n};"],"names":["isMobile","deviceType","getClientHints","children","scrollPosition","onScrollPositionChanged","arrowVisibility","testId","canPaginateNext","setCanPaginateNext","useState","canPaginatePrevious","setCanPaginatePrevious","overflowContainerRef","useRef","contentContainerRef","nextButtonContainerRef","prevButtonContainerRef","baseRef","leftRef","rightRef","observerRef","currentItemRef","currentItem","_setCurrentItem","isMountedRef","buttonsHidden","setButtonsHidden","direction","useUser","itemElementsRef","root","prevBtn","nextBtn","targets","useEffect","current","length","rootMargin","offsetWidth","IntersectionObserver","onVisibilityChange","threshold","target","observe","item","unobserve","entries","newItems","map","conveyorItem","index","foundEntry","find","entry","isVisible","isIntersecting","isCurrent","useMemo","useConveyorElementsVisible","testIdProps","useTestId","leftArrowTestIdProps","rightArrowTestIdProps","useLayoutEffect","conveyorContentChildren","Array","from","querySelectorAll","child","element","push","scrollEndHandler","useCallback","scrollLeft","scrollTo","left","overflowContainer","leftGuard","rightGuard","forEach","getAttribute","addEventListener","removeEventListener","scrollIntoView","_shouldSnapToTheEndEdge","ltr","elem","scroller","right","document","documentElement","clientWidth","scrollerBounds","getBoundingClientRect","bounds","_isElementInsideHorizontalScrollerBounds","offsetLeft","behavior","getNextInvisible","nextInvisible","getPreviousInvisible","previousInvisible","setCurrentItem","node","clipPathStyle","styles","bothButtonClipPath","previousButtonClipPath","nextButtonClipPath","_jsx","ConveyorBeltContext","Provider","value","_jsxs","ref","className","clsx","classNames","baseStyle","jsx","class","buttonContainer","previousButton","nextButton","BaseButton","elementDetails","type","isFocusable","styling","variant","onAction","scrollAmount","scrollPrevious","ButtonLayout","display","startIcon","ChevronLeft","ChevronRight","SvgChevronRight","contentContainer","style","minWidth","scrollNext","props","useConveyorBeltItem"],"mappings":"sWAyCA,SAASA,IACP,MAAMC,EAAaC,mBAAiBD,WACpC,MAAsB,UAAfA,GAAyC,WAAfA,CACnC,gBAoF4B,EAC1BE,WACAC,iBACAC,0BACAC,kBAAkB,OAClBC,aAEA,MAAOC,EAAiBC,GAAsBC,EAAQA,UAAC,IAChDC,EAAqBC,GAA0BF,EAAQA,UAAC,GACzDG,EAAuBC,SAA8B,MACrDC,EAAsBD,SAA8B,MACpDE,EAAyBF,SAA8B,MACvDG,EAAyBH,SAA8B,MACvDI,EAAUJ,SAA8B,MACxCK,EAAUL,SAA8B,MACxCM,EAAWN,SAA8B,MACzCO,EAAcP,SAAY,MAC1BQ,EAAiBR,SAA2B,OAC3CS,EAAaC,GAAmBd,EAAQA,SAAqB,MAC9De,EAAeX,UAAO,IACrBY,EAAeC,GAAoBjB,WACvCV,KAAkC,SAApBM,GAAmD,WAApBA,IAE1CsB,UAAEA,GAAcC,EAAAA,WAEhBC,gBAAEA,GAlGyB,EACjCC,EACAC,EACAC,EACAL,KAEA,MAAMP,EAAcP,EAAAA,SACdoB,EAAUpB,SAA8B,IAE9CqB,EAAAA,WAAU,KACR,GAAID,EAAQE,SAAWF,EAAQE,QAAQC,OAAS,GAAKN,EAAM,CAMzD,MAAMO,EACU,QAAdV,EACI,OAAOK,GAAWA,EAAQM,YAAc,WACtCP,GAAWA,EAAQO,YAAc,MAEnC,OAAOP,GAAWA,EAAQO,YAAc,WACtCN,GAAWA,EAAQM,YAAc,MAGzClB,EAAYe,QAAU,IAAII,qBAAqBC,EAAoB,CACjEV,OACAO,WAAYA,EACZI,UAAW,IAEb,IAAK,MAAMC,KAAUT,EAAQE,QACb,MAAVO,GAAgBtB,EAAYe,QAAQQ,QAAQD,EAAOE,KAE1D,CACD,MAAO,KACL,IAAK,MAAMF,KAAUT,EAAQE,QACvBf,EAAYe,SAAqB,MAAVO,GAAgBtB,EAAYe,QAAQU,UAAUH,EAAOE,KACjF,CACF,GACA,CAACX,EAASH,EAAME,EAASD,EAASJ,IAGrC,MAAMa,EAAsBM,IAC1B,MAAMC,EAAkCd,EAAQE,QAAQa,KAAI,CAACC,EAAcC,KACzE,MAAMC,EAAaL,EAAQM,MAAMC,GAAUA,EAAMX,SAAWO,EAAaL,OAGzE,OAAIO,EACK,CACLP,KAAMO,EAAWT,OACjBY,UAAWH,EAAWI,eACtBC,UAAWP,EAAaO,UACxBN,MAAOA,GAGFD,CACR,IAEHhB,EAAQE,QAAUY,CAAQ,EAG5B,OAAOU,EAAOA,SACZ,KAAO,CACL5B,gBAAiBI,KAEnB,CAACA,GACF,EAgC2ByB,CAC1B9C,EAAqBuB,QACrBnB,EAAuBmB,QACvBpB,EAAuBoB,QACvBR,GAGIgC,EAAcC,YAAUtD,GACxBuD,EAAuB,YAAcvD,EACrCwD,EAAwB,aAAexD,EAE7CyD,EAAAA,iBAAgB,KACdvC,EAAaW,SAAU,EAChB,KACLX,EAAaW,SAAU,CAAK,IAE7B,IASHD,EAAAA,WAAU,KACR,GAA4B,GAAxBV,EAAaW,SAAqD,GAAlCN,EAAgBM,QAAQC,OAAa,CACvE,MAAM4B,EAPDlD,EAAoBqB,QACvB8B,MAAMC,KAAKpD,EAAoBqB,QAAQgC,iBAAiB,gCACxD,GAMF,GAAIH,EAAyB,CAC3B,IAAId,GAAS,EACb,IAAK,MAAMkB,KAASJ,EAAyB,CAC3Cd,IACA,MAAMmB,EAAUD,EAChB,GAAIC,EAAS,CAEC,MADCxC,EAAgBM,QAAQiB,MAAMR,GAASA,EAAKA,OAASyB,KAEhExC,EAAgBM,QAAQmC,KAAK,CAC3B1B,KAAMyB,EACNf,WAAW,EACXJ,MAAOA,EACPM,WAAW,GAGhB,CACF,CACF,CACF,IAEA,CAAChC,EAAcK,IAElB,MAAM0C,EAAmBC,EAAAA,aAAY,KAC/BpE,GAAyBA,EAAwBQ,EAAqBuB,SAASsC,WAAW,GAC7F,CAACrE,IAEJ8B,EAAAA,WAAU,KACRR,EAAkB3B,KAAkC,SAApBM,GAAmD,WAApBA,EAA6B,GAC3F,CAACA,IAEJ6B,EAAAA,WAAU,KACHtB,EAAqBuB,SAC1BvB,EAAqBuB,QAAQuC,SAAS,CACpCC,KAAMxE,GACN,GACD,CAACA,IAIJ+B,EAAAA,WAAU,KACR,MAAM0C,EAAoBhE,EAAqBuB,QACzC0C,EAAY3D,EAAQiB,QACpB2C,EAAa3D,EAASgB,QAyB5B,OAvBIyC,GAAqBC,GAAaC,IAC/BrD,IACHL,EAAYe,QAAU,IAAII,sBACvBO,IACCA,EAAQiC,SAAS1B,IAC2C,SAAtDA,EAAMX,OAAOsC,aAAa,wBAC5BrE,GAAwB0C,EAAME,gBAE9B/C,GAAoB6C,EAAME,eAC3B,GACD,GAEJ,CACEzB,KAAM8C,IAGVxD,EAAYe,QAAQQ,QAAQkC,GAC5BzD,EAAYe,QAAQQ,QAAQmC,IAE9BF,EAAkBK,iBAAiB,YAAaV,IAI3C,KACAK,IACLA,EAAkBM,oBAAoB,YAAaX,GACnDnD,EAAYe,SAASU,UAAUgC,GAC/BzD,EAAYe,SAASU,UAAUiC,GAAW,CAC3C,GACA,CAACrD,EAAe8C,IAGnB,MAAMY,EAAiBX,eACpBH,IAEC,MAAMe,EAA0B,CAC9BC,EACAC,EACAC,KAEA,IAAKD,IAASC,EAAU,OAAO,EAC/B,IAAIC,EACAb,EAEJ,GAAIY,IAAaE,SAASC,gBACxBf,EAAO,EACPa,EAAQC,SAASC,gBAAgBC,gBAC5B,CACL,MAAMC,EAAiBL,EAASM,wBAChCL,EAAQjF,EACJqF,EAAeJ,MAAQzE,EAAuBoB,SAASG,YACvDsD,EAAeJ,MACnBb,EAAOpE,EACHqF,EAAejB,KAAO5D,EAAuBoB,SAASG,YACtDsD,EAAejB,IACpB,CACD,MAAMmB,EAASR,EAAKO,wBACpB,OAAIR,EACKS,EAAON,MAAQA,EAEfM,EAAOnB,KAAOA,CACtB,EAiCH,IA7BiD,EAC/CW,EACAC,KAEA,IAAKD,IAASC,EAAU,OAAO,EAC/B,IAAIZ,EACAa,EACJ,GAAID,IAAaE,SAASC,gBACxBf,EAAO,EACPa,EAAQC,SAASC,gBAAgBC,gBAC5B,CACL,MAAMC,EAAiBL,EAASM,wBAChClB,EAAOjE,EACHkF,EAAejB,KAAO3D,EAAuBmB,SAASG,YACtDsD,EAAejB,KACnBa,EAAQjF,EACJqF,EAAeJ,MAAQzE,EAAuBoB,SAASG,YACvDsD,EAAeJ,KACpB,CACD,MAAMM,EAASR,EAAKO,wBACpB,OACEC,EAAOnB,MAAQa,GAASM,EAAON,OAASA,GAASM,EAAOnB,MAAQA,GAAQmB,EAAON,OAASb,CACxF,EAGqBoB,CACvB1B,EACAzD,EAAqBuB,UAKlBvB,EAAqBuB,SAAYrB,EAAoBqB,QAE1D,GAAkB,QAAdR,EAAqB,CACDyD,EACN,QAAdzD,EACA0C,EACAzD,EAAqBuB,SAGrBvB,EAAqBuB,QAAQuC,SAAS,CACpCC,KACEN,EAAQ2B,WACR3B,EAAQ/B,YACR1B,EAAqBuB,QAAQG,aAC5BvB,EAAuBoB,SAASG,YAC7BvB,EAAuBoB,SAASG,YAAc,EAC9C,GACN2D,SAAU,WAGZrF,EAAqBuB,QAAQuC,SAAS,CACpCC,KACEN,EAAQ2B,YACPhF,EAAuBmB,SAASG,YAC7BtB,EAAuBmB,SAASG,YAAc,EAC9C,GACN2D,SAAU,UAGf,KAAM,CACiBb,GAAwB,EAAOf,EAASzD,EAAqBuB,SAEjFvB,EAAqBuB,QAAQuC,SAAS,CACpCC,KACEN,EAAQ2B,WACRlF,EAAoBqB,SAASG,YAC7B1B,EAAqBuB,QAAQG,aAC5BvB,EAAuBoB,SAASG,YAC7BvB,EAAuBoB,SAASG,YAAc,EAC9C,GACN2D,SAAU,WAGZrF,EAAqBuB,QAAQuC,SAAS,CACpCC,KACEN,EAAQ2B,WACR3B,EAAQ/B,YACRxB,EAAoBqB,SAASG,aAC5BtB,EAAuBmB,SAASG,YAC7BtB,EAAuBmB,SAASG,YAAc,EAC9C,GACN2D,SAAU,UAGf,IAEH,CAAC1F,EAAiBG,EAAqBiB,IAkGzC,MAAMuE,EAAmB,KACvB,MAAMC,EAAgBtE,EAAgBM,QAAQiB,MAAMR,GAE9B,GAAlBA,EAAKU,WACLV,EAAKM,OAAS,GACuC,GAArDrB,EAAgBM,QAAQS,EAAKM,MAAQ,GAAGI,YAM5C,OAAO6C,GAAevD,IAAI,EAGtBwD,EAAuB,KAC3B,MAAMC,EAAoBxE,EAAgBM,QAAQiB,MAAMR,GAElC,GAAlBA,EAAKU,WACLV,EAAKM,MAAQrB,EAAgBM,QAAQC,OAAS,GACO,GAArDP,EAAgBM,QAAQS,EAAKM,MAAQ,GAAGI,YAM5C,OAAO+C,GAAmBzD,IAAI,EAG1B0D,EAAiB9B,eAAa+B,IAClC,GAAIlF,EAAec,UAAYoE,EAAM,CAEnC,MAAM3D,EAAOf,EAAgBM,QAAQiB,MAAMR,GAASA,EAAKA,OAAS2D,IAC5DjF,EAAcO,EAAgBM,QAAQiB,MAAMR,IAA4B,IAAnBA,EAAKY,YAChE,GAAIZ,IAAStB,IAAgBsB,EAAM,OAC/BtB,IAAaA,EAAYkC,WAAY,GACzCZ,EAAMY,WAAY,EAElBnC,EAAec,QAAUoE,EACzBhF,EAAgBgF,EACjB,IACA,CAAC1E,IAEJK,EAAAA,WAAU,KACJZ,GAAeD,EAAec,SAChCgD,EAAe9D,EAAec,QAC/B,GACA,CAACb,IAgBJ,MAAMkF,GAAiB/E,IACL,QAAdE,EACEpB,GAAmBG,EACjB+F,EAAAA,OAAOC,mBACPhG,EACA+F,EAAAA,OAAOE,yBACPpG,GACAkG,EAAAA,OAAOG,mBAETrG,GAAmBG,EACnB+F,EAAAA,OAAOC,mBACPnG,EACAkG,EAAAA,OAAOE,yBACPjG,GACA+F,EAAAA,OAAOG,oBAIb,OACEC,MAACC,EAAmBA,oBAACC,SAAS,CAAAC,MAAO,CAAEV,kBACrCpG,SAAA+G,EAAAA,KAAA,MAAA,CAAKC,IAAKjG,EAASkG,UAAWC,EAAIC,WAAC,CAACZ,EAAAA,OAAOa,eAAiB3D,EACzDzD,SAAA,CAAAQ,IAAwBe,GACvBoF,EAAAU,IAAA,MAAA,CACEL,IAAKlG,EACLwG,MAAOJ,EAAAA,WAAK,CACVX,EAAAA,OAAOgB,gBACO,QAAd9F,EAAsB8E,EAAAA,OAAOiB,eAAiBjB,EAAMA,OAACkB,sBAEvDd,MAACe,EAAAA,WACC,CAAAC,eAAgB,CAAEC,KAAM,OAAQC,aAAa,GAC7CC,QAAS,CAAC,OACVC,QAAS,aACTC,SAAU,IA3LtB,SACEvG,EACAiD,EACAuD,GAEA,GAAIvD,GAAqBuD,EAAc,CACrC,MAAM9B,EAA6CD,IACjC,QAAdzE,EACG0E,EAMHzB,EAAkBF,SAAS,CACzBC,KACE0B,EAAkBL,WAClBK,EAAkB/D,YAClBsC,EAAkBtC,aACjBtB,EAAuBmB,SAASG,YAC7BtB,EAAuBmB,SAASG,YAAc,EAC9C,GACN2D,SAAU,WAbZrB,EAAkBF,SAAS,CACzBC,KAAMC,EAAkBH,WAAa0D,EACrClC,SAAU,WAeTI,EAMHzB,EAAkBF,SAAS,CACzBC,KACE0B,EAAkBL,WAClBlF,EAAoBqB,SAASG,YAC7BsC,EAAkBtC,aACjBtB,EAAuBmB,SAASG,YAC7BtB,EAAuBmB,SAASG,YAAc,EAC9C,GACN2D,SAAU,WAbZrB,EAAkBF,SAAS,CACzBC,KAAMC,EAAkBH,WAAa0D,EACrClC,SAAU,UAejB,CACF,CA+IamC,CACEzG,EACAf,EAAqBuB,QACrBvB,EAAqBuB,SAASwD,aAC/B,eAEU,EACbrF,OAAQuD,WACRgD,EAACU,IAAAc,EAAYA,aACX,CAAAC,QAAS,QACTC,UAAyB,QAAd5G,EAAsBkF,EAACU,IAAAiB,iBAAc,CAAA,GAAG3B,EAAAA,IAAC4B,EAAYC,gBAAG,CAAA,SAI3E7B,EAAAA,IAAA,MAAA,CAAKM,UAAWC,EAAAA,WAAK,CAACX,EAAAA,OAAO7B,kBAAmB4B,IAAiBU,IAAKtG,EACpEV,SAAA+G,OAAA,MAAA,CAAKE,UAAWV,EAAAA,OAAOkC,iBAAkBzB,IAAKpG,EAAmBZ,SAAA,CAC/D2G,EAAAA,IAA0B,MAAA,CAAA,uBAAA,OAAOK,IAAKhG,EAAS0H,MAAO,CAAEC,SAAU,KACjE3I,EACD2G,oCAA0B,QAAQK,IAAK/F,EAAUyH,MAAO,CAAEC,SAAU,UAGvEtI,IAAoBkB,GACnBoF,MAAA,MAAA,CACEK,IAAKnG,EACLyG,MAAOJ,EAAAA,WAAK,CACVX,EAAAA,OAAOgB,gBACO,QAAd9F,EAAsB8E,EAAAA,OAAOkB,WAAalB,EAAMA,OAACiB,0BAEnDb,MAACe,EAAAA,WACC,CAAAC,eAAgB,CAAEC,KAAM,OAAQC,aAAa,GAC7CC,QAAS,CAAC,OACVC,QAAS,aACTC,SAAU,IA3KtB,SACEvG,EACAiD,EACAuD,GAEA,GAAIvD,GAAqBuD,EAAc,CACrC,MAAMhC,EAAyCD,IAC7B,QAAdvE,EACGwE,EAMHvB,EAAkBF,SAAS,CACzBC,MACGwB,GAAeH,YAAc,IAC7BjF,EAAuBoB,SAASG,YAC7BvB,EAAuBoB,SAASG,YAAc,EAC9C,GACN2D,SAAU,WAXZrB,EAAkBF,SAAS,CACzBC,KAAMC,EAAkBH,WAAa0D,EACrClC,SAAU,WAaTE,EAMHvB,EAAkBF,SAAS,CACzBC,OACI7D,EAAoBqB,SAASG,aAAgB6D,GAAeH,YAAc,KAC3EG,GAAe7D,aAAe,IAC9BvB,EAAuBoB,SAASG,YAC7BvB,EAAuBoB,SAASG,YAAc,EAC9C,GACN2D,SAAU,WAZZrB,EAAkBF,SAAS,CACzBC,KAAMC,EAAkBH,WAAa0D,EACrClC,SAAU,UAcjB,CACF,CAkIa6C,CACEnH,EACAf,EAAqBuB,QACrBvB,EAAqBuB,SAASwD,aAC/B,eAEU,EACbrF,OAAQwD,EAAqB5D,SAC7B2G,EAAAA,IAACwB,EAAAA,cACCC,QAAS,QACTC,UAAyB,QAAd5G,EAAsBkF,EAAAA,IAAC4B,EAAYC,gBAAG,IAAG7B,MAAC2B,EAAAA,eAAW,CAAA,aAM5E,qBCzlB4B,EAC9BtI,WACAsD,gBAGA,MAAMuF,EAAQC,EAAAA,oBAAoB,CAC/BxF,UAAWA,IACd,OACEqD,EAAAA,IAAS,MAAA,IAAAkC,WACN7I,GACK"}