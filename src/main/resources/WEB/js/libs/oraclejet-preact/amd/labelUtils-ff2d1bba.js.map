{"version":3,"file":"labelUtils-ff2d1bba.js","sources":["../../src/UNSAFE_Axis/utils/axisDefaults.ts","../../src/UNSAFE_Axis/utils/labelUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport const AXIS_DEFAULTS = {\n  titleGap: 6,\n  labelGap: 6\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { TextDimensions, useTextDimensions } from '../../hooks/PRIVATE_useTextDimensions';\nimport { isHeightOverlap, isWidthOverlap } from '../../utils/UNSAFE_visUtils';\nimport { AxisPosition, Dimension } from '../axis.types';\nimport { AXIS_DEFAULTS } from './axisDefaults';\n\ntype GetTextDimensions = NonNullable<ReturnType<typeof useTextDimensions>['getTextDimensions']>;\n/**\n * Calculates the number of skips between axis labels and the dimensions of unskipped labels.\n * @param labels The labels to render.\n * @param getLabelDims The function that returns dimension of given label.\n * @param isHoriz Whether the axis is horizontal.\n * @param numOfSafeSkips The no of labels to skip safely.\n * @returns\n */\nexport function skipLabelsUniform(\n  labels: (string | undefined)[],\n  getLabelDims: (label: string | undefined, index: number) => Dimension,\n  isHoriz: boolean,\n  numOfSafeSkips?: number\n) {\n  let numOfSkips = numOfSafeSkips || 0;\n  let dimsA: TextDimensions;\n  let dimsB: TextDimensions;\n  const dims: TextDimensions[] = [getLabelDims(labels[0], 0)];\n  const isOverlapping = isHoriz ? isWidthOverlap : isHeightOverlap;\n\n  let indexA = 0;\n  let indexB = numOfSkips + 1;\n  while (indexB < labels.length) {\n    dimsA = dims[indexA] || getLabelDims(labels[indexA], indexA);\n    if (!dims[indexA]) dims[indexA] = dimsA;\n    dimsB = dims[indexB] || getLabelDims(labels[indexB], indexB);\n    if (!dims[indexB]) dims[indexB] = dimsB;\n    if (isOverlapping(dimsA, dimsB)) {\n      numOfSkips += 1;\n      indexA = 0;\n      indexB = numOfSkips + 1;\n    } else {\n      indexA = indexB;\n      indexB = indexA + numOfSkips + 1;\n    }\n  }\n  return { numOfSkips, dims };\n}\n\n/**\n * Greedily skip labels. We will skip next label if it overlaps with the previous one.\n * This might not result in uniformly spaced labels.\n * @param labels\n * @param getLabelDims\n * @param isHoriz\n * @returns\n */\nexport function skipLabelsGreedy(\n  labels: string[],\n  getLabelDims: (label: string, index: number) => Dimension,\n  isHoriz: boolean\n) {\n  const isOverlapping = isHoriz ? isWidthOverlap : isHeightOverlap;\n  let currentDims = getLabelDims(labels[0], 0);\n\n  const renderedLabels = [\n    {\n      label: labels[0],\n      index: 0,\n      labelProps: currentDims\n    }\n  ];\n  let maxWidth = currentDims.width;\n  let maxHeight = currentDims.height;\n  for (let j = 1; j < labels.length; j++) {\n    if (!labels[j]) continue;\n    const labelDim = getLabelDims(labels[j], j);\n    if (!isOverlapping(currentDims, getLabelDims(labels[j], j))) {\n      currentDims = labelDim;\n      renderedLabels.push({\n        label: labels[j],\n        index: j,\n        labelProps: labelDim\n      });\n\n      maxWidth = Math.max(maxWidth, labelDim.width);\n      maxHeight = Math.max(maxHeight, labelDim.height);\n    }\n  }\n  return { tickLabels: renderedLabels, maxWidth, maxHeight };\n}\n\n/**\n * Retuns the max dimension of the rendered labels after skipping overlapping labels.\n * @param labels An array of labels.\n * @param getLabelDims The function called to get dimension of the given label.\n * @param isHoriz If the overlap be measured in horizontal direction.\n * @param numOfSafeSkips Predetermined number labels to safely skip. This will optimize label\n * measurement as we don't have to measure all the labels.\n * @returns\n */\nexport function getMaxTextDimensions(\n  labels: (string | undefined)[],\n  getLabelDims: (label: string | undefined, index: number) => TextDimensions,\n  isHoriz: boolean,\n  numOfSafeSkips?: number\n) {\n  const { numOfSkips, dims } = skipLabelsUniform(labels, getLabelDims, isHoriz, numOfSafeSkips);\n  const tickLabels = [];\n  let maxWidth = 0;\n  let maxHeight = 0;\n\n  for (let i = 0; i < labels.length; i += numOfSkips + 1) {\n    maxWidth = Math.max(maxWidth, dims[i].width);\n    maxHeight = Math.max(maxHeight, dims[i].height);\n    tickLabels.push({\n      index: i,\n      label: labels[i],\n      labelProps: dims[i]\n    });\n  }\n  return {\n    maxHeight,\n    maxWidth,\n    tickLabels,\n    numOfSkips\n  };\n}\n\nexport function updateLabelsDims(\n  maxWidth: number,\n  maxHeight: number,\n  renderedLabelsInfo: any[],\n  getAxisPos: (index: number) => number,\n  availSpace: Dimension,\n  position: AxisPosition\n) {\n  renderedLabelsInfo.forEach((info) => {\n    const dim: TextDimensions = info.labelProps;\n    let x: number;\n    let y: number;\n    if (position === 'left') {\n      x = availSpace.x + maxWidth;\n      y = getAxisPos(info.index);\n    } else if (position === 'right') {\n      x = availSpace.x + availSpace.width - maxWidth;\n      y = getAxisPos(info.index);\n    } else if (position === 'top') {\n      x = getAxisPos(info.index);\n      y = availSpace.y + maxHeight - dim.height / 2;\n    } else {\n      x = getAxisPos(info.index);\n      y = availSpace.y + availSpace.height - maxHeight + dim.height / 2;\n    }\n    dim.x = x;\n    dim.y = y;\n  });\n}\n\n/**\n * Updates the given available space after labels are rendered.\n * @param availSpace The avaialable space.\n * @param position The position of the axis.\n * @param maxWidth The maximum width of rendered labels.\n * @param maxHeight The maxium height of the rendered labels.\n */\nexport function updateAvailableSpace(\n  availSpace: Dimension,\n  position: AxisPosition,\n  maxWidth: number,\n  maxHeight: number\n) {\n  if (position == 'left') {\n    availSpace.x += maxWidth;\n    availSpace.width -= maxWidth;\n  } else if (position === 'right') {\n    availSpace.x -= maxWidth;\n  } else if (position === 'top') {\n    availSpace.y += maxHeight;\n    availSpace.height -= maxHeight;\n  } else {\n    availSpace.height -= maxHeight;\n  }\n}\n\n/**\n * Returns the enclosing rect for the label of given dimension.\n * @param dims The dimension\n * @param axisPosition The position of the axis.\n * @returns\n */\nexport function getEnclosingRectDims(dims: Dimension, axisPosition: AxisPosition) {\n  let x: number;\n  let y: number;\n\n  if (axisPosition === 'left') {\n    x = dims.x - dims.width;\n    y = dims.y - dims.height / 2;\n  } else if (axisPosition === 'right') {\n    x = dims.x;\n    y = dims.y - dims.height / 2;\n  } else {\n    x = dims.x - dims.width / 2;\n    y = dims.y - dims.height / 2;\n  }\n  const width = dims.width;\n  const height = dims.height;\n\n  return { x, y, width, height };\n}\n\n/**\n * Retuns the unaligned label dimensions that can be used by skipLabels.\n * @param coord\n * @param label\n * @param labelStyle\n * @param isHoriz\n * @param availSpace\n * @param getTextDimensions\n * @returns\n */\nexport function getLabelDimensions(\n  coord: number,\n  label: string | undefined,\n  labelStyle: Partial<CSSStyleDeclaration>,\n  isHoriz: boolean,\n  availSpace: Dimension,\n  getTextDimensions?: GetTextDimensions\n) {\n  if (!getTextDimensions || !label) {\n    return { width: 0, height: 0, x: 0, y: 0 };\n  }\n\n  const gap = AXIS_DEFAULTS.labelGap;\n  const { width, height } = getTextDimensions(label, labelStyle as any);\n  const labelWidth = isHoriz ? width + gap : width;\n  const labelHeight = isHoriz ? height : height + gap;\n  return {\n    x: isHoriz ? coord - labelWidth / 2 : availSpace.x,\n    width: labelWidth,\n    height,\n    y: isHoriz ? availSpace.y : coord + labelHeight / 2\n  };\n}\n"],"names":["AXIS_DEFAULTS","titleGap","labelGap","dims","axisPosition","x","y","width","height","coord","label","labelStyle","isHoriz","availSpace","getTextDimensions","gap","labelWidth","labelHeight","labels","getLabelDims","numOfSafeSkips","numOfSkips","dimsA","dimsB","isOverlapping","isWidthOverlap","isHeightOverlap","indexA","indexB","length","skipLabelsUniform","tickLabels","maxWidth","maxHeight","i","Math","max","push","index","labelProps","currentDims","renderedLabels","j","labelDim","renderedLabelsInfo","getAxisPos","position","forEach","info","dim"],"mappings":"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"}